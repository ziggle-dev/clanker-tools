import React from 'react';

interface ToolResult {
    success: boolean;
    output?: string;
    error?: string;
    data?: unknown;
}

/**
 * Core types for the dynamic tool registry system
 */

/**
 * Tool metadata for registration and discovery
 */
interface ToolMetadata {
    id: string;
    name: string;
    description: string;
    version?: string;
    author?: string;
    tags?: string[];
    category?: ToolCategory;
    capabilities?: ToolCapability[];
}
/**
 * Tool categories for organization
 */
declare enum ToolCategory {
    FileSystem = "filesystem",
    System = "system",
    Search = "search",
    Development = "development",
    Task = "task",
    Utility = "utility",
    Composition = "composition"
}
/**
 * Tool capabilities for permission checking
 */
declare enum ToolCapability {
    FileRead = "file:read",
    FileWrite = "file:write",
    SystemExecute = "system:execute",
    NetworkAccess = "network:access",
    UserConfirmation = "user:confirmation"
}
/**
 * Argument type definitions
 */
type ArgumentType = 'string' | 'number' | 'boolean' | 'array' | 'object' | 'any';
/**
 * Argument specification for tools
 */
interface ArgumentSpec {
    name: string;
    type: ArgumentType;
    description: string;
    required?: boolean;
    default?: string | number | boolean | unknown[] | Record<string, unknown>;
    enum?: Array<string | number | boolean>;
    validate?: (value: unknown) => boolean | string;
}
/**
 * Tool arguments definition
 */
type ToolArguments = Record<string, unknown>;
/**
 * Tool execution context
 */
interface ToolContext {
    registry: ToolRegistry;
    workingDirectory: string;
    confirmationService?: unknown;
    logger?: ToolLogger;
    state?: Map<string, unknown>;
}
/**
 * Tool execution function
 */
type ToolExecutor = (args: ToolArguments, context: ToolContext) => Promise<ToolResult>;
/**
 * Tool result render function for custom UI display
 */
type ToolResultRenderer = (args: {
    toolName: string;
    arguments: ToolArguments;
    result?: ToolResult;
    isExecuting: boolean;
}) => React.ReactElement | null;
/**
 * Complete tool definition
 */
interface ToolDefinition extends ToolMetadata {
    arguments?: ArgumentSpec[];
    execute: ToolExecutor;
    initialize?: (context: ToolContext) => Promise<void>;
    cleanup?: (context: ToolContext) => Promise<void>;
    inputSchema?: Schema;
    outputSchema?: Schema;
    composable?: boolean;
    renderResult?: ToolResultRenderer;
    examples?: {
        description: string;
        arguments: ToolArguments;
        result?: string;
    }[];
}
/**
 * Registered tool instance
 */
interface RegisteredTool {
    definition: ToolDefinition;
    initialized: boolean;
    lastExecuted?: Date;
    executionCount: number;
    totalDuration: number;
    hash?: string;
    filePath?: string;
}
/**
 * Schema for type validation in compositions
 */
interface Schema {
    type: ArgumentType;
    properties?: Record<string, Schema>;
    items?: Schema;
    required?: string[];
}
/**
 * Composition patterns
 */
type CompositionPattern = 'pipeline' | 'parallel' | 'conditional' | 'map' | 'reduce';
/**
 * Composed tool that can be registered
 */
interface ComposedTool extends ToolDefinition {
    pattern: CompositionPattern;
    tools: string[];
    config?: Record<string, unknown>;
}
/**
 * Tool registry for managing tools
 */
interface ToolRegistry {
    register(tool: ToolDefinition): void;
    unregister(toolId: string): void;
    get(toolId: string): RegisteredTool | undefined;
    list(filter?: ToolFilter): ToolDefinition[];
    search(query: string): ToolDefinition[];
    execute(toolId: string, args: ToolArguments): Promise<ToolResult>;
    compose(pattern: CompositionPattern, tools: string[], config?: Record<string, unknown>): ComposedTool;
    validateArguments(toolId: string, args: ToolArguments): ValidationResult;
}
/**
 * Tool filter options
 */
interface ToolFilter {
    category?: ToolCategory;
    capabilities?: ToolCapability[];
    tags?: string[];
    composable?: boolean;
}
/**
 * Validation result
 */
interface ValidationResult {
    valid: boolean;
    errors?: ValidationError[];
}
/**
 * Validation error
 */
interface ValidationError {
    field: string;
    message: string;
    expected?: unknown;
    received?: unknown;
}
/**
 * Tool logger interface
 */
interface ToolLogger {
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    error(message: string, ...args: unknown[]): void;
}
/**
 * Extract argument types from tool definition
 */
type ExtractToolArgs<T extends ToolDefinition> = T extends {
    arguments: infer Args;
} ? Args extends readonly ArgumentSpec[] ? {
    [K in Args[number] as K['name']]: unknown;
} : Record<string, unknown> : Record<string, unknown>;

/**
 * Core tool registry implementation
 */

/**
 * Main tool registry implementation
 */
declare class ToolRegistryImpl implements ToolRegistry {
    private tools;
    private context;
    constructor(workingDirectory?: string);
    /**
     * Register a new tool
     */
    register(tool: ToolDefinition): void;
    /**
     * Unregister a tool
     */
    unregister(toolId: string): Promise<void>;
    /**
     * Get a registered tool
     */
    get(toolId: string): RegisteredTool | undefined;
    /**
     * List tools with optional filter
     */
    list(filter?: ToolFilter): ToolDefinition[];
    /**
     * Search tools by query
     */
    search(query: string): ToolDefinition[];
    /**
     * Execute a tool
     */
    execute(toolId: string, args: ToolArguments): Promise<ToolResult>;
    /**
     * Create a composed tool
     */
    compose(pattern: CompositionPattern, toolIds: string[], config?: Record<string, unknown>): ComposedTool;
    /**
     * Validate tool arguments
     */
    validateArguments(toolId: string, args: ToolArguments): ValidationResult;
    /**
     * Get the registry context
     */
    getContext(): ToolContext;
    /**
     * Update working directory
     */
    setWorkingDirectory(dir: string): void;
    /**
     * Get tool statistics
     */
    getStats(): {
        totalTools: number;
        byCategory: Record<string, number>;
        byCapability: Record<string, number>;
        mostUsed: Array<{
            toolId: string;
            count: number;
        }>;
    };
    /**
     * Get execution stats in the format expected by tests
     */
    getExecutionStats(): Record<string, {
        executionCount: number;
        totalDuration: number;
    }>;
}
/**
 * Create a new tool registry instance
 */
declare function createToolRegistry(workingDirectory?: string): ToolRegistry;

/**
 * Tool builder for creating tools with a fluent API
 */

/**
 * Builder for creating tool definitions
 */
declare class ToolBuilder {
    private metadata;
    private args;
    private executor?;
    private initHook?;
    private cleanupHook?;
    private schemas;
    private isComposable?;
    private renderer?;
    private examplesList?;
    /**
     * Set tool ID (required)
     */
    id(id: string): ToolBuilder;
    /**
     * Set tool name
     */
    name(name: string): ToolBuilder;
    /**
     * Set tool description
     */
    description(description: string): ToolBuilder;
    /**
     * Set tool version
     */
    version(version: string): ToolBuilder;
    /**
     * Set tool author
     */
    author(author: string): ToolBuilder;
    /**
     * Set tool category
     */
    category(category: ToolCategory): ToolBuilder;
    /**
     * Add tags
     */
    tags(...tags: string[]): ToolBuilder;
    /**
     * Add capabilities
     */
    capabilities(...capabilities: ToolCapability[]): ToolBuilder;
    /**
     * Add an argument
     */
    argument(spec: ArgumentSpec): ToolBuilder;
    /**
     * Add a string argument (convenience method)
     */
    stringArg(name: string, description: string, options?: {
        required?: boolean;
        default?: string;
        enum?: string[];
        validate?: (value: string) => true | string;
    }): ToolBuilder;
    /**
     * Add a number argument (convenience method)
     */
    numberArg(name: string, description: string, options?: {
        required?: boolean;
        default?: number;
        validate?: (value: number) => true | string;
    }): ToolBuilder;
    /**
     * Add a boolean argument (convenience method)
     */
    booleanArg(name: string, description: string, options?: {
        required?: boolean;
        default?: boolean;
    }): ToolBuilder;
    /**
     * Add an array argument (convenience method)
     */
    arrayArg(name: string, description: string, options?: {
        required?: boolean;
        default?: unknown[];
        validate?: (value: unknown[]) => boolean | string;
    }): ToolBuilder;
    /**
     * Set input schema for composition
     */
    inputSchema(schema: Schema): ToolBuilder;
    /**
     * Set output schema for composition
     */
    outputSchema(schema: Schema): ToolBuilder;
    /**
     * Make tool composable
     */
    composable(value?: boolean): ToolBuilder;
    /**
     * Set execution function
     */
    execute(executor: ToolExecutor): ToolBuilder;
    /**
     * Set initialization hook
     */
    onInitialize(hook: (context: ToolContext) => Promise<void>): ToolBuilder;
    /**
     * Set cleanup hook
     */
    onCleanup(hook: (context: ToolContext) => Promise<void>): ToolBuilder;
    /**
     * Set custom result renderer
     */
    renderResult(renderer: ToolResultRenderer): ToolBuilder;
    /**
     * Add examples for better AI understanding
     */
    examples(examples: {
        description: string;
        arguments: ToolArguments;
        result?: string;
    }[]): ToolBuilder;
    /**
     * Build the tool definition
     */
    build(): ToolDefinition;
}
/**
 * Create a new tool builder
 */
declare function createTool(): ToolBuilder;

/**
 * Tool composition patterns
 */

/**
 * Create a composed tool based on pattern
 */
declare function createComposedTool(pattern: CompositionPattern, tools: ToolDefinition[], config?: Record<string, unknown>): ComposedTool;
/**
 * Composition builder with fluent API
 */
declare class CompositionBuilder {
    private registry;
    constructor(registry: {
        get(id: string): {
            definition: ToolDefinition;
        } | undefined;
    });
    /**
     * Create a pipeline composition
     */
    pipeline(...toolIds: string[]): ComposedTool;
    /**
     * Create a parallel composition
     */
    parallel(...toolIds: string[]): ComposedTool;
    /**
     * Create a conditional composition
     */
    conditional(condition: string | ((args: ToolArguments, context: ToolContext) => string | Promise<string>), branches: Record<string, string>): ComposedTool;
    /**
     * Create a map composition
     */
    map(toolId: string, options?: {
        concurrency?: number;
        continueOnError?: boolean;
    }): ComposedTool;
    /**
     * Create a reduce composition
     */
    reduce(toolId: string, reducer: (acc: unknown, value: unknown, index: number) => unknown, initialValue?: unknown): ComposedTool;
}

interface GrokTool {
    type: "function";
    function: {
        name: string;
        description: string;
        parameters: {
            type: "object";
            properties: Record<string, unknown>;
            required: string[];
        };
    };
}

/**
 * Adapters for converting between tool formats
 */

/**
 * Convert a ToolDefinition to GrokTool format
 */
declare function toolDefinitionToGrokTool(tool: ToolDefinition): GrokTool;
/**
 * Generate all Grok tools from registry
 */
declare function generateGrokTools(registry: ToolRegistry): GrokTool[];
/**
 * Create a legacy tool wrapper for backward compatibility
 */
declare function createLegacyToolWrapper(tool: ToolDefinition, context: ToolContext): {
    name: string;
    description: string;
    execute: (...args: unknown[]) => Promise<ToolResult>;
};
/**
 * Create a tool execution wrapper for Grok agent
 */
declare function createToolExecutor(registry: ToolRegistry): (toolName: string, args: unknown) => Promise<ToolResult>;
/**
 * Create dynamic tool descriptions for prompts
 */
declare function generateToolPromptSection(tools: ToolDefinition[]): string;

/**
 * Argument validation utilities
 */

/**
 * Validate arguments against specifications
 */
declare function validateArguments(specs: ArgumentSpec[], args: ToolArguments): ValidationResult;
/**
 * Apply default values to arguments
 */
declare function applyDefaults(specs: ArgumentSpec[], args: ToolArguments): ToolArguments;
/**
 * Coerce argument types
 */
declare function coerceArguments(specs: ArgumentSpec[], args: ToolArguments): ToolArguments;
/**
 * Format validation errors for display
 */
declare function formatValidationErrors(errors: ValidationError[]): string;
/**
 * Create a validation function for common patterns
 */
declare const validators: {
    /**
     * String validators
     */
    minLength: (min: number) => (value: string) => string | true;
    maxLength: (max: number) => (value: string) => string | true;
    pattern: (regex: RegExp) => (value: string) => true | "Does not match required pattern";
    email: () => (value: string) => true | "Must be a valid email address";
    url: () => (value: string) => true | "Must be a valid URL";
    /**
     * Number validators
     */
    min: (min: number) => (value: number) => string | true;
    max: (max: number) => (value: number) => string | true;
    integer: () => (value: number) => true | "Must be an integer";
    positive: () => (value: number) => true | "Must be positive";
    /**
     * Array validators
     */
    minItems: (min: number) => (value: unknown[]) => string | true;
    maxItems: (max: number) => (value: unknown[]) => string | true;
    unique: () => (value: unknown[]) => true | "Items must be unique";
    /**
     * Combine multiple validators
     */
    combine: (...validators: Array<(value: unknown) => boolean | string>) => (value: unknown) => string | boolean;
};

/**
 * Dynamic tool loader with clean, reusable directory scanning
 */

/**
 * Options for loading tools
 */
interface LoaderOptions {
    /**
     * Base directories to search for tools
     * Defaults to ['.', '~/.clank']
     */
    directories?: string[];
    /**
     * Whether to search recursively
     * Defaults to true
     */
    recursive?: boolean;
    /**
     * File extensions to load
     * Defaults to ['.ts', '.tsx', '.js', '.jsx']
     */
    extensions?: string[];
    /**
     * Whether to watch for changes
     */
    watch?: boolean;
    /**
     * Whether to load built-in tools
     * Defaults to true
     */
    loadBuiltins?: boolean;
}
/**
 * Tool loader for dynamic tool discovery
 */
declare class ToolLoader {
    private registry;
    private options;
    private loadedTools;
    private watcherCleanup;
    private fileWatchers;
    constructor(registry: ToolRegistry, options?: LoaderOptions);
    /**
     * Load all tools from configured directories
     */
    loadTools(): Promise<void>;
    /**
     * Load built-in tools from the package
     */
    private loadBuiltinTools;
    /**
     * Load tools from a directory
     */
    private loadFromDirectory;
    /**
     * Recursively scan a directory for tool files
     */
    private scanDirectory;
    /**
     * Load a single tool file
     */
    private loadToolFile;
    /**
     * Import a module handling TypeScript if needed
     */
    private importModule;
    /**
     * Extract tool from module exports
     */
    private extractTool;
    /**
     * Validate if an object is a valid tool
     */
    private isValidTool;
    /**
     * Check if a file should be loaded as a tool
     */
    private isToolFile;
    /**
     * Check if a path exists
     */
    private exists;
    /**
     * Compute hash of a file
     */
    private computeFileHash;
    /**
     * Unload a tool and run cleanup
     */
    private unloadTool;
    /**
     * Reload all tools (for --watch-tools command)
     */
    reloadAllTools(): Promise<void>;
    /**
     * Set up file watchers for hot reloading
     */
    private setupWatchers;
    /**
     * Find tool ID by file path
     */
    private findToolByPath;
    /**
     * Get loaded tools info
     */
    getLoadedTools(): Array<{
        toolId: string;
        filePath: string;
        hash: string;
    }>;
    /**
     * Reload all tools
     */
    reloadTools(): Promise<void>;
    /**
     * Clean up resources
     */
    cleanup(): Promise<void>;
    /**
     * Load a module with shared dependencies from the main clanker package
     */
    private loadWithSharedDependencies;
    /**
     * Create a tool template file
     */
    static createToolTemplate(toolName: string, baseDir?: string): Promise<void>;
}
/**
 * Create a tool loader instance
 */
declare function createToolLoader(registry: ToolRegistry, options?: LoaderOptions): ToolLoader;

/**
 * Logger implementation for tool execution
 */

/**
 * Console logger implementation
 */
declare class ConsoleLogger implements ToolLogger {
    private prefix;
    private enabled;
    constructor(prefix?: string, enabled?: boolean);
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    error(message: string, ...args: unknown[]): void;
}
/**
 * Create a logger instance for a specific tool
 */
declare function createToolLogger(toolId: string, enabled?: boolean): ToolLogger;
/**
 * Null logger that discards all messages
 */
declare class NullLogger implements ToolLogger {
    debug(): void;
    info(): void;
    warn(): void;
    error(): void;
}

export { type ArgumentSpec, type ArgumentType, type ComposedTool, CompositionBuilder, type CompositionPattern, ConsoleLogger, type ExtractToolArgs, type LoaderOptions, NullLogger, type RegisteredTool, type Schema, type ToolArguments, ToolBuilder, ToolCapability, ToolCategory, type ToolContext, type ToolDefinition, type ToolExecutor, type ToolFilter, ToolLoader, type ToolLogger, type ToolMetadata, type ToolRegistry, ToolRegistryImpl, type ToolResult, type ToolResultRenderer, type ValidationError, type ValidationResult, applyDefaults, coerceArguments, createComposedTool, createLegacyToolWrapper, createTool, createToolExecutor, createToolLoader, createToolLogger, createToolRegistry, formatValidationErrors, generateGrokTools, generateToolPromptSection, toolDefinitionToGrokTool, validateArguments, validators };
