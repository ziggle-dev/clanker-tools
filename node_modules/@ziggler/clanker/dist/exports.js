var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/tsup/assets/esm_shims.js
import path from "path";
import { fileURLToPath } from "url";
var getFilename, getDirname, __dirname;
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
    getFilename = () => fileURLToPath(import.meta.url);
    getDirname = () => path.dirname(getFilename());
    __dirname = /* @__PURE__ */ getDirname();
  }
});

// src/registry/types.ts
var ToolCategory, ToolCapability;
var init_types = __esm({
  "src/registry/types.ts"() {
    init_esm_shims();
    ToolCategory = /* @__PURE__ */ ((ToolCategory2) => {
      ToolCategory2["FileSystem"] = "filesystem";
      ToolCategory2["System"] = "system";
      ToolCategory2["Search"] = "search";
      ToolCategory2["Development"] = "development";
      ToolCategory2["Task"] = "task";
      ToolCategory2["Utility"] = "utility";
      ToolCategory2["Composition"] = "composition";
      return ToolCategory2;
    })(ToolCategory || {});
    ToolCapability = /* @__PURE__ */ ((ToolCapability2) => {
      ToolCapability2["FileRead"] = "file:read";
      ToolCapability2["FileWrite"] = "file:write";
      ToolCapability2["SystemExecute"] = "system:execute";
      ToolCapability2["NetworkAccess"] = "network:access";
      ToolCapability2["UserConfirmation"] = "user:confirmation";
      return ToolCapability2;
    })(ToolCapability || {});
  }
});

// src/registry/validation.ts
function validateArguments(specs, args) {
  const errors = [];
  for (const spec of specs) {
    const value = args[spec.name];
    if (spec.required && (value === void 0 || value === null)) {
      errors.push({
        field: spec.name,
        message: `Required argument '${spec.name}' is missing`,
        expected: spec.type
      });
      continue;
    }
    if (value === void 0 || value === null) {
      continue;
    }
    const typeError = validateType(value, spec.type, spec.name);
    if (typeError) {
      errors.push(typeError);
      continue;
    }
    if (spec.enum && !spec.enum.includes(value)) {
      errors.push({
        field: spec.name,
        message: `Value must be one of: ${spec.enum.join(", ")}`,
        expected: spec.enum,
        received: value
      });
    }
    if (spec.validate) {
      const result = spec.validate(value);
      if (typeof result === "string") {
        errors.push({
          field: spec.name,
          message: result,
          received: value
        });
      } else if (result === false) {
        errors.push({
          field: spec.name,
          message: `Validation failed for '${spec.name}'`,
          received: value
        });
      }
    }
  }
  const knownArgs = new Set(specs.map((s) => s.name));
  for (const key of Object.keys(args)) {
    if (!knownArgs.has(key)) {
      errors.push({
        field: key,
        message: `Unknown argument '${key}'`
      });
    }
  }
  return {
    valid: errors.length === 0,
    errors: errors.length > 0 ? errors : void 0
  };
}
function validateType(value, expectedType, fieldName) {
  const actualType = getActualType(value);
  if (expectedType === "any") {
    return null;
  }
  if (actualType !== expectedType) {
    if (expectedType === "number" && actualType === "string" && !isNaN(Number(value))) {
      return null;
    }
    return {
      field: fieldName,
      message: `Expected ${expectedType} but got ${actualType}`,
      expected: expectedType,
      received: actualType
    };
  }
  return null;
}
function getActualType(value) {
  if (value === null || value === void 0) {
    return "any";
  }
  if (Array.isArray(value)) {
    return "array";
  }
  const type = typeof value;
  switch (type) {
    case "string":
    case "number":
    case "boolean":
      return type;
    case "object":
      return "object";
    default:
      return "any";
  }
}
function applyDefaults(specs, args) {
  const result = { ...args };
  for (const spec of specs) {
    if (spec.default !== void 0 && result[spec.name] === void 0) {
      result[spec.name] = spec.default;
    }
  }
  return result;
}
function coerceArguments(specs, args) {
  const result = { ...args };
  for (const spec of specs) {
    const value = result[spec.name];
    if (value === void 0 || value === null) {
      continue;
    }
    result[spec.name] = coerceValue(value, spec.type);
  }
  return result;
}
function coerceValue(value, targetType) {
  const actualType = getActualType(value);
  if (actualType === targetType || targetType === "any") {
    return value;
  }
  if (targetType === "number" && actualType === "string") {
    const num = Number(value);
    return isNaN(num) ? value : num;
  }
  if (targetType === "boolean" && actualType === "string") {
    return value === "true" || value === "1" || value === "yes";
  }
  if (targetType === "array" && actualType === "string") {
    return value.split(",").map((s) => s.trim());
  }
  if (targetType === "object" && actualType === "string") {
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  return value;
}
function formatValidationErrors(errors) {
  return errors.map((error) => {
    let message = `\u2022 ${error.message}`;
    if (error.expected && error.received) {
      message += ` (expected: ${JSON.stringify(error.expected)}, received: ${JSON.stringify(error.received)})`;
    }
    return message;
  }).join("\n");
}
var validators;
var init_validation = __esm({
  "src/registry/validation.ts"() {
    init_esm_shims();
    validators = {
      /**
       * String validators
       */
      minLength: (min) => (value) => value.length >= min || `Must be at least ${min} characters`,
      maxLength: (max) => (value) => value.length <= max || `Must be at most ${max} characters`,
      pattern: (regex) => (value) => regex.test(value) || `Does not match required pattern`,
      email: () => (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) || "Must be a valid email address",
      url: () => (value) => {
        try {
          new URL(value);
          return true;
        } catch {
          return "Must be a valid URL";
        }
      },
      /**
       * Number validators
       */
      min: (min) => (value) => value >= min || `Must be at least ${min}`,
      max: (max) => (value) => value <= max || `Must be at most ${max}`,
      integer: () => (value) => Number.isInteger(value) || "Must be an integer",
      positive: () => (value) => value > 0 || "Must be positive",
      /**
       * Array validators
       */
      minItems: (min) => (value) => value.length >= min || `Must have at least ${min} items`,
      maxItems: (max) => (value) => value.length <= max || `Must have at most ${max} items`,
      unique: () => (value) => new Set(value).size === value.length || "Items must be unique",
      /**
       * Combine multiple validators
       */
      combine: (...validators2) => (value) => {
        for (const validator of validators2) {
          const result = validator(value);
          if (result !== true) {
            return result;
          }
        }
        return true;
      }
    };
  }
});

// src/registry/composition.ts
function createComposedTool(pattern, tools, config) {
  const toolIds = tools.map((t) => t.id);
  const name = `${pattern}_${toolIds.join("_")}`;
  const description = `${pattern} composition of: ${toolIds.join(", ")}`;
  let executor;
  switch (pattern) {
    case "pipeline":
      executor = createPipelineExecutor(tools);
      break;
    case "parallel":
      executor = createParallelExecutor(tools);
      break;
    case "conditional":
      executor = createConditionalExecutor(tools, config);
      break;
    case "map":
      executor = createMapExecutor(tools[0], config);
      break;
    case "reduce":
      executor = createReduceExecutor(tools[0], config);
      break;
    default:
      throw new Error(`Unknown composition pattern: ${pattern}`);
  }
  const composedTool = {
    id: name,
    name,
    description,
    category: "composition" /* Composition */,
    composable: true,
    pattern,
    tools: toolIds,
    config,
    execute: executor,
    // Inherit capabilities from all tools
    capabilities: Array.from(new Set(
      tools.flatMap((t) => t.capabilities || [])
    ))
  };
  return composedTool;
}
function createPipelineExecutor(tools) {
  return async (args, context) => {
    let currentInput = args;
    let lastResult = null;
    for (const tool of tools) {
      const result = await context.registry.execute(tool.id, currentInput);
      if (!result.success) {
        return result;
      }
      currentInput = result.data || result.output || {};
      lastResult = result;
    }
    return lastResult || { success: true };
  };
}
function createParallelExecutor(tools) {
  return async (args, context) => {
    const promises = tools.map(
      (tool) => context.registry.execute(tool.id, args)
    );
    const results = await Promise.all(promises);
    const failures = results.filter((r) => !r.success);
    if (failures.length > 0) {
      return {
        success: false,
        error: `${failures.length} tools failed: ${failures.map((f) => f.error).join(", ")}`
      };
    }
    return {
      success: true,
      data: results.map((r) => r.data || r.output)
    };
  };
}
function createConditionalExecutor(tools, config) {
  const { condition, branches } = config;
  return async (args, context) => {
    let branchKey;
    if (typeof condition === "function") {
      branchKey = await condition(args, context);
    } else {
      branchKey = args[condition] ? "true" : "false";
    }
    const toolIndex = branches[branchKey];
    if (toolIndex === void 0 || toolIndex >= tools.length) {
      return {
        success: false,
        error: `No tool defined for branch: ${branchKey}`
      };
    }
    const tool = tools[toolIndex];
    return context.registry.execute(tool.id, args);
  };
}
function createMapExecutor(tool, config = {}) {
  const concurrency = config.concurrency || 1;
  const continueOnError = config.continueOnError || false;
  return async (args, context) => {
    const { items, ...otherArgs } = args;
    if (!Array.isArray(items)) {
      return {
        success: false,
        error: 'Map requires "items" array in arguments'
      };
    }
    const results = [];
    const errors = [];
    if (concurrency === 1) {
      for (const item of items) {
        const itemArgs = { ...otherArgs, item };
        const result = await context.registry.execute(tool.id, itemArgs);
        if (!result.success) {
          if (!continueOnError) {
            return result;
          }
          errors.push({ item, error: result.error });
        } else {
          results.push(result.data || result.output);
        }
      }
    } else {
      const chunks = [];
      for (let i = 0; i < items.length; i += concurrency) {
        chunks.push(items.slice(i, i + concurrency));
      }
      for (const chunk of chunks) {
        const promises = chunk.map((item) => {
          const itemArgs = { ...otherArgs, item };
          return context.registry.execute(tool.id, itemArgs);
        });
        const chunkResults = await Promise.all(promises);
        chunkResults.forEach((result, index) => {
          if (!result.success) {
            if (!continueOnError) {
              return result;
            }
            errors.push({ item: chunk[index], error: result.error });
          } else {
            results.push(result.data || result.output);
          }
        });
      }
    }
    return {
      success: errors.length === 0 || continueOnError,
      data: results,
      error: errors.length > 0 ? `${errors.length} items failed` : void 0
    };
  };
}
function createReduceExecutor(tool, config) {
  const { reducer, initialValue } = config;
  return async (args, context) => {
    const { items, ...otherArgs } = args;
    if (!Array.isArray(items)) {
      return {
        success: false,
        error: 'Reduce requires "items" array in arguments'
      };
    }
    let accumulator = initialValue;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemArgs = { ...otherArgs, item, accumulator, index: i };
      const result = await context.registry.execute(tool.id, itemArgs);
      if (!result.success) {
        return result;
      }
      if (typeof reducer === "function") {
        accumulator = await reducer(accumulator, result.data || result.output, i);
      } else {
        accumulator = result.data || result.output;
      }
    }
    return {
      success: true,
      data: accumulator
    };
  };
}
var CompositionBuilder;
var init_composition = __esm({
  "src/registry/composition.ts"() {
    init_esm_shims();
    init_types();
    CompositionBuilder = class {
      constructor(registry) {
        this.registry = registry;
      }
      /**
       * Create a pipeline composition
       */
      pipeline(...toolIds) {
        const tools = toolIds.map((id) => {
          const tool = this.registry.get(id);
          if (!tool) throw new Error(`Tool '${id}' not found`);
          return tool.definition;
        });
        return createComposedTool("pipeline", tools);
      }
      /**
       * Create a parallel composition
       */
      parallel(...toolIds) {
        const tools = toolIds.map((id) => {
          const tool = this.registry.get(id);
          if (!tool) throw new Error(`Tool '${id}' not found`);
          return tool.definition;
        });
        return createComposedTool("parallel", tools);
      }
      /**
       * Create a conditional composition
       */
      conditional(condition, branches) {
        const branchTools = [];
        const branchMap = {};
        Object.entries(branches).forEach(([key, toolId], index) => {
          const tool = this.registry.get(toolId);
          if (!tool) throw new Error(`Tool '${toolId}' not found`);
          branchTools.push(tool.definition);
          branchMap[key] = index;
        });
        return createComposedTool("conditional", branchTools, {
          condition,
          branches: branchMap
        });
      }
      /**
       * Create a map composition
       */
      map(toolId, options) {
        const tool = this.registry.get(toolId);
        if (!tool) throw new Error(`Tool '${toolId}' not found`);
        return createComposedTool("map", [tool.definition], options);
      }
      /**
       * Create a reduce composition
       */
      reduce(toolId, reducer, initialValue) {
        const tool = this.registry.get(toolId);
        if (!tool) throw new Error(`Tool '${toolId}' not found`);
        return createComposedTool("reduce", [tool.definition], {
          reducer,
          initialValue
        });
      }
    };
  }
});

// src/utils/debug-logger.ts
import * as fs from "fs";
import * as path2 from "path";
import * as os from "os";
function closeFileLogging() {
  if (logStream) {
    logToStream(`
=== Debug log ended at ${(/* @__PURE__ */ new Date()).toISOString()} ===
`);
    logStream.end();
    logStream = null;
  }
}
function logToStream(message) {
  if (logStream) {
    logStream.write(message);
  }
}
function formatArgs(args) {
  return args.map((arg) => {
    if (typeof arg === "object") {
      try {
        return JSON.stringify(arg, null, 2);
      } catch {
        return String(arg);
      }
    }
    return String(arg);
  }).join(" ");
}
var debugEnabled, logToFile, logStream, debug;
var init_debug_logger = __esm({
  "src/utils/debug-logger.ts"() {
    init_esm_shims();
    debugEnabled = false;
    logToFile = false;
    logStream = null;
    debug = {
      log: (...args) => {
        if (debugEnabled) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const message = formatArgs(args);
          console.log("[DEBUG]", ...args);
          if (logToFile && logStream) {
            logToStream(`[${timestamp}] [LOG] ${message}
`);
          }
        }
      },
      error: (...args) => {
        if (debugEnabled) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const message = formatArgs(args);
          console.error("[DEBUG ERROR]", ...args);
          if (logToFile && logStream) {
            logToStream(`[${timestamp}] [ERROR] ${message}
`);
          }
        }
      },
      warn: (...args) => {
        if (debugEnabled) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const message = formatArgs(args);
          console.warn("[DEBUG WARN]", ...args);
          if (logToFile && logStream) {
            logToStream(`[${timestamp}] [WARN] ${message}
`);
          }
        }
      },
      info: (...args) => {
        if (debugEnabled) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const message = formatArgs(args);
          console.info("[DEBUG INFO]", ...args);
          if (logToFile && logStream) {
            logToStream(`[${timestamp}] [INFO] ${message}
`);
          }
        }
      }
    };
    process.on("exit", closeFileLogging);
    process.on("SIGINT", () => {
      closeFileLogging();
      process.exit();
    });
    process.on("SIGTERM", () => {
      closeFileLogging();
      process.exit();
    });
  }
});

// src/ui/stage/types.ts
var init_types2 = __esm({
  "src/ui/stage/types.ts"() {
    init_esm_shims();
  }
});

// src/clanker/client.ts
import OpenAI from "openai";
var GrokClient;
var init_client = __esm({
  "src/clanker/client.ts"() {
    init_esm_shims();
    GrokClient = class {
      constructor(apiKey, model, baseURL) {
        this.currentModel = "grok-3-latest";
        this.client = new OpenAI({
          apiKey,
          baseURL: baseURL || process.env.GROK_BASE_URL || "https://api.x.ai/v1",
          timeout: 36e4
        });
        if (model) {
          this.currentModel = model;
        }
      }
      setModel(model) {
        this.currentModel = model;
      }
      getCurrentModel() {
        return this.currentModel;
      }
      async chat(messages, tools, model, searchOptions) {
        try {
          const requestPayload = {
            model: model || this.currentModel,
            messages,
            temperature: 0.7,
            max_tokens: 4e3
          };
          if (tools && tools.length > 0) {
            requestPayload.tools = tools;
            requestPayload.tool_choice = "auto";
          }
          if (searchOptions?.search_parameters) {
            requestPayload.search_parameters = searchOptions.search_parameters;
          }
          const response = await this.client.chat.completions.create(
            requestPayload
          );
          return response;
        } catch (error) {
          throw new Error(`Grok API error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      async *chatStream(messages, tools, model, searchOptions) {
        try {
          const requestPayload = {
            model: model || this.currentModel,
            messages,
            temperature: 0.7,
            max_tokens: 4e3,
            stream: true
          };
          if (tools && tools.length > 0) {
            requestPayload.tools = tools;
            requestPayload.tool_choice = "auto";
          }
          if (searchOptions?.search_parameters) {
            requestPayload.search_parameters = searchOptions.search_parameters;
          }
          const stream = await this.client.chat.completions.create(
            requestPayload
          );
          let firstChunk = true;
          for await (const chunk of stream) {
            if (firstChunk) {
              firstChunk = false;
            }
            yield chunk;
          }
        } catch (error) {
          throw new Error(`Grok API error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      async search(query, searchParameters) {
        const searchMessage = {
          role: "user",
          content: query
        };
        const searchOptions = {
          search_parameters: searchParameters || { mode: "on" }
        };
        return this.chat([searchMessage], [], void 0, searchOptions);
      }
    };
  }
});

// src/registry/retry-executor.ts
function analyzeErrorAndSuggestFix(error, args, toolName) {
  const errorLower = error.toLowerCase();
  if ((toolName === "bash" || toolName === "input") && (errorLower.includes("unexpected eof") || errorLower.includes("matching"))) {
    if (args.command && typeof args.command === "string") {
      const fixed = args.command.replace(/'/g, `'"'"'`);
      return { ...args, command: fixed };
    }
    if (args.prompt && typeof args.prompt === "string") {
      const fixed = args.prompt.replace(/"/g, '\\"').replace(/'/g, "\\'");
      return { ...args, prompt: fixed };
    }
  }
  if (errorLower.includes("no such file") || errorLower.includes("not found") || errorLower.includes("does not exist")) {
    if (args.path || args.file_path) {
      const originalPath = args.path || args.file_path;
      if (originalPath.startsWith("./")) {
        return { ...args, path: originalPath.substring(2), file_path: originalPath.substring(2) };
      }
      if (!originalPath.startsWith("/") && !originalPath.startsWith("./")) {
        return { ...args, path: "./" + originalPath, file_path: "./" + originalPath };
      }
      if (toolName === "search" && args.query) {
        const query = args.query;
        if (!query.includes("*")) {
          return { ...args, query: `*${query}*` };
        }
      }
    }
  }
  if (errorLower.includes("permission denied") || errorLower.includes("access denied")) {
    if (toolName === "bash" && args.command && typeof args.command === "string") {
      const cmd = args.command;
      if (!cmd.startsWith("sudo ")) {
        debug.warn("[RetryExecutor] Permission denied, but NOT auto-adding sudo for safety");
        return null;
      }
    }
  }
  if (errorLower.includes("invalid argument") || errorLower.includes("type error")) {
    const newArgs = { ...args };
    for (const [key, value] of Object.entries(newArgs)) {
      if (typeof value === "string" && value.match(/^\d+$/)) {
        newArgs[key] = parseInt(value, 10);
      }
    }
    return newArgs;
  }
  return null;
}
function generateFallbackSuggestions(context) {
  const { toolName, originalArgs, previousErrors } = context;
  const suggestions = [];
  const lastError = previousErrors[previousErrors.length - 1]?.error || "";
  const preamble = `After ${context.attempt} attempts, the last error was: "${lastError}, the original arguments were: ${JSON.stringify(originalArgs)}"`;
  if (toolName === "search") {
    suggestions.push(
      "Try using the list tool to explore the directory structure",
      `Use the bash tool with "find . -name '*pattern*'" for a broader search`,
      "Check if the file has a different extension (e.g., .txt instead of .md)"
    );
  } else if (toolName === "read_file" || toolName === "view_file") {
    suggestions.push(
      "Use the list tool to verify the file exists in the expected location",
      "Try the pwd tool to confirm the current working directory",
      'Use bash with "ls -la" to see all files including hidden ones'
    );
  } else if (toolName === "bash") {
    if (lastError.includes("command not found")) {
      suggestions.push(
        'Check if the command is installed with "which <command>"',
        "Try using the full path to the command",
        "Consider using an alternative command"
      );
    } else if (lastError.includes("permission")) {
      suggestions.push(
        "The command may require elevated permissions",
        "Try a different approach that doesn't require special permissions",
        'Check file ownership and permissions with "ls -la"'
      );
    }
  } else if (toolName === "input") {
    suggestions.push(
      "The input dialog may not be supported in this environment",
      "Consider asking the user to provide the information directly in their message",
      "Try a simpler prompt without special characters"
    );
  }
  suggestions.push(
    "Review the error messages for clues about what went wrong",
    "Consider breaking down the task into smaller steps",
    "Ask the user for clarification or additional information"
  );
  return `${preamble}. Consider these alternative approaches:
${suggestions.map((s) => `- ${s}`).join("\n")}`;
}
function createRetryToolExecutor(registry) {
  return async (toolName, args, maxRetries = 5) => {
    const context = {
      toolName,
      originalArgs: args,
      attempt: 0,
      previousErrors: []
    };
    let currentArgs = args;
    while (context.attempt < maxRetries) {
      context.attempt++;
      debug.log(`[RetryExecutor] Attempt ${context.attempt} for ${toolName}`);
      try {
        const result = await registry.execute(toolName, currentArgs);
        if (result.success) {
          if (context.attempt > 1) {
            debug.log(`[RetryExecutor] Succeeded on attempt ${context.attempt}`);
          }
          return result;
        }
        const error = result.error || "Unknown error";
        context.previousErrors.push({ error, args: currentArgs });
        debug.warn(`[RetryExecutor] Tool ${toolName} failed: ${error}`);
        const fixedArgs = analyzeErrorAndSuggestFix(error, currentArgs, toolName);
        if (fixedArgs && context.attempt < maxRetries) {
          debug.log(`[RetryExecutor] Attempting to fix error with modified arguments`);
          currentArgs = fixedArgs;
          continue;
        }
        if (context.attempt < maxRetries) {
          debug.log(`[RetryExecutor] No automatic fix available, retrying with original args`);
          currentArgs = args;
          continue;
        }
        const fallbackMsg = generateFallbackSuggestions(context);
        return {
          success: false,
          error: `${error}

${fallbackMsg}`,
          data: {
            attempts: context.attempt,
            errors: context.previousErrors
          }
        };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        context.previousErrors.push({ error: errorMsg, args: currentArgs });
        debug.error(`[RetryExecutor] Unexpected error: ${errorMsg}`);
        if (context.attempt >= maxRetries) {
          const fallbackMsg = generateFallbackSuggestions(context);
          return {
            success: false,
            error: `Execution failed: ${errorMsg}

${fallbackMsg}`,
            data: {
              attempts: context.attempt,
              errors: context.previousErrors
            }
          };
        }
      }
    }
    return {
      success: false,
      error: "Max retries exceeded",
      data: {
        attempts: context.attempt,
        errors: context.previousErrors
      }
    };
  };
}
function tryFixJson(jsonString) {
  let cleaned = jsonString.replace(/\}[^}]*$/, "}");
  const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return jsonMatch[0];
  }
  if (!cleaned.trim()) {
    return "{}";
  }
  return null;
}
function createToolExecutorWithRetry(registry) {
  const retryExecutor = createRetryToolExecutor(registry);
  return async (toolName, args) => {
    let parsedArgs = args;
    if (typeof args === "string") {
      try {
        parsedArgs = JSON.parse(args);
      } catch (error) {
        const fixed = tryFixJson(args);
        if (fixed) {
          try {
            parsedArgs = JSON.parse(fixed);
          } catch {
            const tool = registry.get(toolName);
            if (tool && (!tool.definition.arguments || tool.definition.arguments.length === 0)) {
              parsedArgs = {};
            } else {
              parsedArgs = { input: args };
            }
          }
        } else {
          parsedArgs = { input: args };
        }
      }
    }
    return retryExecutor(toolName, parsedArgs, 5);
  };
}
var init_retry_executor = __esm({
  "src/registry/retry-executor.ts"() {
    init_esm_shims();
    init_debug_logger();
  }
});

// src/utils/token-counter.ts
import { get_encoding, encoding_for_model } from "tiktoken";
function createTokenCounter(model) {
  return new TokenCounter(model);
}
var TokenCounter;
var init_token_counter = __esm({
  "src/utils/token-counter.ts"() {
    init_esm_shims();
    TokenCounter = class {
      constructor(model = "gpt-4") {
        try {
          this.encoder = encoding_for_model(model);
        } catch {
          this.encoder = get_encoding("cl100k_base");
        }
      }
      /**
       * Count tokens in a string
       */
      countTokens(text) {
        if (!text) return 0;
        return this.encoder.encode(text).length;
      }
      /**
       * Count tokens in messages array (for chat completions)
       */
      countMessageTokens(messages) {
        let totalTokens = 0;
        for (const message of messages) {
          totalTokens += 3;
          if (message.content && typeof message.content === "string") {
            totalTokens += this.countTokens(message.content);
          }
          if (message.role) {
            totalTokens += this.countTokens(message.role);
          }
          if (message.tool_calls) {
            totalTokens += this.countTokens(JSON.stringify(message.tool_calls));
          }
        }
        totalTokens += 3;
        return totalTokens;
      }
      /**
       * Estimate tokens for streaming content
       * This is an approximation since we don't have the full response yet
       */
      estimateStreamingTokens(accumulatedContent) {
        return this.countTokens(accumulatedContent);
      }
      /**
       * Clean up resources
       */
      dispose() {
        this.encoder.free();
      }
    };
  }
});

// src/clanker/agent.ts
var agent_exports = {};
__export(agent_exports, {
  GrokAgent: () => GrokAgent
});
import { EventEmitter } from "events";
import * as path3 from "path";
var GrokAgent;
var init_agent = __esm({
  "src/clanker/agent.ts"() {
    init_esm_shims();
    init_client();
    init_registry2();
    init_retry_executor();
    init_token_counter();
    init_debug_logger();
    GrokAgent = class extends EventEmitter {
      constructor(options) {
        super();
        this.client = new GrokClient(
          options.apiKey,
          options.model,
          options.baseURL
        );
        this.model = options.model || "grok-3-latest";
        this.maxToolRounds = options.maxToolRounds || 30;
        this.tokenCounter = createTokenCounter(this.model);
        this.registry = createToolRegistry();
        this.executeToolWithRegistry = createToolExecutorWithRetry(this.registry);
        const directories = [];
        const homeDir = process.env.HOME || process.env.USERPROFILE || "";
        if (homeDir) {
          directories.push(path3.join(homeDir, ".clanker"));
        }
        if (options.dynamicToolsPath) {
          directories.push(options.dynamicToolsPath);
        }
        if (options.loadDynamicTools) {
          directories.push(process.cwd());
        }
        this.toolLoader = createToolLoader(this.registry, {
          directories: directories.length > 0 ? directories : void 0,
          recursive: true,
          watch: options.watchTools ?? false,
          loadBuiltins: true
        });
      }
      async chat(messages, systemPrompt, stream = false) {
        const allMessages = [];
        if (systemPrompt) {
          allMessages.push({ role: "system", content: systemPrompt });
        }
        allMessages.push(...messages);
        const tools = generateGrokTools(this.registry);
        if (stream) {
          return this.streamChat(allMessages, tools);
        } else {
          return this.nonStreamChat(allMessages, tools);
        }
      }
      async *streamChat(messages, tools) {
        let rounds = 0;
        let currentMessages = [...messages];
        let totalTokens = this.tokenCounter.countMessageTokens(currentMessages);
        while (rounds < this.maxToolRounds) {
          const stream = this.client.chatStream(
            currentMessages,
            tools.length > 0 ? tools : void 0,
            this.model
          );
          let accumulatedContent = "";
          const accumulatedToolCalls = [];
          let currentToolCall = null;
          let lastFinishReason = null;
          for await (const chunk of stream) {
            if (!chunk.choices || chunk.choices.length === 0 || !chunk.choices[0].delta) {
              continue;
            }
            if (chunk.choices[0].delta.tool_calls) {
              for (const toolCallDelta of chunk.choices[0].delta.tool_calls) {
                if (toolCallDelta.index === 0 && !currentToolCall) {
                  currentToolCall = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function?.name || "",
                      arguments: toolCallDelta.function?.arguments || ""
                    }
                  };
                } else if (currentToolCall && toolCallDelta.function?.arguments) {
                  currentToolCall.function.arguments += toolCallDelta.function.arguments;
                }
              }
            }
            if (chunk.choices[0].delta.content !== void 0 && chunk.choices[0].delta.content !== null) {
              const content = chunk.choices[0].delta.content;
              accumulatedContent += content;
              yield {
                type: "content",
                content
              };
              const currentOutputTokens = this.tokenCounter.estimateStreamingTokens(accumulatedContent) + (accumulatedToolCalls.length > 0 ? this.tokenCounter.countTokens(JSON.stringify(accumulatedToolCalls)) : 0);
              yield {
                type: "token_count",
                tokenCount: totalTokens + currentOutputTokens
              };
            }
            if (chunk.choices[0].finish_reason) {
              lastFinishReason = chunk.choices[0].finish_reason;
              if (currentToolCall) {
                accumulatedToolCalls.push(currentToolCall);
              }
              break;
            }
          }
          if (accumulatedToolCalls.length > 0) {
            yield {
              type: "tool_calls",
              toolCalls: accumulatedToolCalls
            };
            const toolResults = await this.executeToolCalls(accumulatedToolCalls);
            const assistantMessage = {
              role: "assistant",
              content: accumulatedContent || "",
              tool_calls: accumulatedToolCalls
            };
            currentMessages.push(assistantMessage);
            totalTokens = this.tokenCounter.countMessageTokens(currentMessages);
            for (let i = 0; i < toolResults.length; i++) {
              const toolResult = toolResults[i];
              yield {
                type: "tool_result",
                toolCall: accumulatedToolCalls[i],
                toolResult
              };
              const toolMessage = {
                role: "tool",
                content: this.formatToolResult(toolResult),
                tool_call_id: accumulatedToolCalls[i].id
              };
              currentMessages.push(toolMessage);
              totalTokens = this.tokenCounter.countMessageTokens(currentMessages);
              yield {
                type: "token_count",
                tokenCount: totalTokens
              };
            }
            rounds++;
            currentToolCall = null;
            debug.log(`[Agent] Tool execution complete, continuing to round ${rounds}`);
          } else if (accumulatedContent) {
            yield {
              type: "done"
            };
            return;
          } else if (lastFinishReason === "tool_calls") {
            rounds++;
          } else {
            yield {
              type: "done"
            };
            return;
          }
        }
        throw new Error(`Maximum tool rounds (${this.maxToolRounds}) exceeded`);
      }
      async nonStreamChat(messages, tools) {
        let rounds = 0;
        let currentMessages = [...messages];
        while (rounds < this.maxToolRounds) {
          const response = await this.client.chat(
            currentMessages,
            tools.length > 0 ? tools : void 0,
            this.model
          );
          const message = response.choices[0]?.message;
          if (!message) {
            throw new Error("No response from API");
          }
          if (message.tool_calls && message.tool_calls.length > 0) {
            const toolResults = await this.executeToolCalls(message.tool_calls);
            currentMessages.push({
              role: "assistant",
              content: message.content,
              tool_calls: message.tool_calls
            });
            for (let i = 0; i < toolResults.length; i++) {
              currentMessages.push({
                role: "tool",
                content: this.formatToolResult(toolResults[i]),
                tool_call_id: message.tool_calls[i].id
              });
            }
            rounds++;
          } else {
            return message.content || "";
          }
        }
        throw new Error(`Maximum tool rounds (${this.maxToolRounds}) exceeded`);
      }
      async executeToolCalls(toolCalls) {
        const results = [];
        for (const toolCall of toolCalls) {
          try {
            const result = await this.executeTool(toolCall);
            results.push(result);
          } catch (error) {
            results.push({
              success: false,
              error: `Tool execution error: ${error instanceof Error ? error.message : String(error)}`
            });
          }
        }
        return results;
      }
      async executeTool(toolCall) {
        const toolName = toolCall.function.name;
        let args;
        try {
          args = JSON.parse(toolCall.function.arguments);
        } catch (error) {
          debug.error(`[Agent] Failed to parse arguments for ${toolName}:`);
          debug.error(`[Agent] Raw arguments: ${JSON.stringify(toolCall.function.arguments)}`);
          debug.error(`[Agent] Error: ${error}`);
          const tool = this.registry.get(toolName);
          let errorMessage = `Failed to parse JSON arguments: ${error instanceof Error ? error.message : String(error)}`;
          errorMessage += `

The raw arguments were: ${toolCall.function.arguments}`;
          if (tool) {
            errorMessage += `

Tool "${toolName}" expects:`;
            if (!tool.definition.arguments || tool.definition.arguments.length === 0) {
              errorMessage += "\n- No arguments required (use empty object: {})";
            } else {
              tool.definition.arguments.forEach((arg) => {
                errorMessage += `
- ${arg.name}: ${arg.type}${arg.required ? " (required)" : " (optional)"}`;
                if (arg.description) {
                  errorMessage += ` - ${arg.description}`;
                }
              });
            }
          }
          return {
            success: false,
            error: errorMessage
          };
        }
        return this.executeToolWithRegistry(toolName, args);
      }
      formatToolResult(result) {
        if (result.success) {
          return result.output || JSON.stringify(result.data) || "Success";
        } else {
          return `Error: ${result.error}`;
        }
      }
      // Public API for registry access
      getRegistry() {
        return this.registry;
      }
      async waitForToolsToLoad() {
        if (this.toolLoader) {
          await this.toolLoader.loadTools();
        }
      }
      // Get tool statistics
      getToolStats() {
        const registryImpl = this.registry;
        return registryImpl.getExecutionStats();
      }
      // Get the underlying Grok client
      getClient() {
        return this.client;
      }
      // Reload dynamic tools
      async reloadDynamicTools() {
        if (this.toolLoader) {
          await this.toolLoader.reloadAllTools();
        }
      }
      // Clean up resources
      dispose() {
        this.tokenCounter.dispose();
        if (this.toolLoader) {
          this.toolLoader.cleanup();
        }
      }
    };
  }
});

// src/utils/settings-manager.ts
var settings_manager_exports = {};
__export(settings_manager_exports, {
  ProviderModels: () => ProviderModels,
  SettingsManager: () => SettingsManager,
  SettingsSchema: () => SettingsSchema
});
import * as fs2 from "fs";
import * as path4 from "path";
import * as os2 from "os";
import { z } from "zod";
var ProviderModels, SettingsSchema, SettingsManager;
var init_settings_manager = __esm({
  "src/utils/settings-manager.ts"() {
    init_esm_shims();
    ProviderModels = {
      grok: {
        name: "Grok",
        baseURL: "https://api.x.ai/v1",
        models: [
          { value: "grok-4-0709", label: "Grok 4" },
          { value: "grok-3", label: "Grok 3" },
          { value: "grok-3-mini", label: "Grok 3 Mini" },
          { value: "grok-3-fast", label: "Grok 3 Fast" },
          { value: "grok-3-mini-fast", label: "Grok 3 Mini Fast" },
          { value: "grok-2-vision-1212", label: "Grok 2 Vision" },
          { value: "grok-2-image-1212", label: "Grok 2 Image" }
        ],
        defaultModel: "grok-3"
      },
      openai: {
        name: "OpenAI",
        baseURL: "https://api.openai.com/v1",
        models: [
          { value: "gpt-4", label: "GPT-4" },
          { value: "gpt-4-turbo", label: "GPT-4 Turbo" },
          { value: "gpt-3.5-turbo", label: "GPT-3.5 Turbo" }
        ],
        defaultModel: "gpt-4-turbo"
      },
      custom: {
        name: "Custom",
        baseURL: "",
        models: [],
        defaultModel: ""
      }
    };
    SettingsSchema = z.object({
      apiKey: z.string().min(1, "API key is required"),
      provider: z.enum(["grok", "openai", "custom"]).default("grok"),
      customBaseURL: z.string().url().optional(),
      model: z.string().default(ProviderModels.grok.defaultModel),
      theme: z.enum(["light", "dark", "auto"]).default("auto"),
      autoEditEnabled: z.boolean().default(false),
      vsCodeOpenEnabled: z.boolean().default(false),
      dangerousBypassPermission: z.boolean().default(false),
      virtualScrollingEnabled: z.boolean().default(true),
      confirmationSettings: z.object({
        alwaysEdit: z.boolean().default(false),
        alwaysBash: z.boolean().default(false),
        alwaysSearch: z.boolean().default(false)
      }).default({}),
      // Add version to track schema changes
      version: z.number().default(1)
    });
    SettingsManager = class _SettingsManager {
      constructor() {
        this.currentVersion = 2;
        this.settingsDir = path4.join(os2.homedir(), ".clanker");
        this.settingsPath = path4.join(this.settingsDir, "settings.json");
      }
      static getInstance() {
        if (!_SettingsManager.instance) {
          _SettingsManager.instance = new _SettingsManager();
        }
        return _SettingsManager.instance;
      }
      /**
       * Ensure the settings directory exists
       */
      ensureSettingsDir() {
        if (!fs2.existsSync(this.settingsDir)) {
          fs2.mkdirSync(this.settingsDir, { recursive: true });
        }
      }
      /**
       * Load settings from file
       */
      loadSettings() {
        try {
          this.ensureSettingsDir();
          if (!fs2.existsSync(this.settingsPath)) {
            return { settings: {}, isValid: false, errors: null };
          }
          const fileContent = fs2.readFileSync(this.settingsPath, "utf-8");
          const rawSettings = JSON.parse(fileContent);
          const result = SettingsSchema.safeParse(rawSettings);
          if (result.success) {
            return { settings: result.data, isValid: true, errors: null };
          } else {
            return { settings: rawSettings, isValid: false, errors: result.error };
          }
        } catch (error) {
          console.error("Failed to load settings:", error);
          return { settings: {}, isValid: false, errors: null };
        }
      }
      /**
       * Save settings to file
       */
      saveSettings(settings) {
        try {
          this.ensureSettingsDir();
          const settingsWithVersion = { ...settings, version: this.currentVersion };
          fs2.writeFileSync(
            this.settingsPath,
            JSON.stringify(settingsWithVersion, null, 2),
            "utf-8"
          );
        } catch (error) {
          console.error("Failed to save settings:", error);
          throw error;
        }
      }
      /**
       * Check if settings need to be configured
       * Returns true if settings are missing, invalid, or have new fields
       */
      needsConfiguration() {
        const { isValid, settings } = this.loadSettings();
        if (!isValid) return true;
        const requiredFields = ["apiKey"];
        for (const field of requiredFields) {
          if (!settings[field]) {
            return true;
          }
        }
        if (!settings.version || settings.version < this.currentVersion) {
          return true;
        }
        return false;
      }
      /**
       * Get fields that need configuration
       */
      getMissingFields() {
        const { settings } = this.loadSettings();
        const schema = SettingsSchema.shape;
        const missingFields = [];
        for (const [key, value] of Object.entries(schema)) {
          if (key === "version") continue;
          if (!value.isOptional() && !settings[key]) {
            missingFields.push(key);
          }
        }
        return missingFields;
      }
      /**
       * Validate a single field
       */
      validateField(field, value) {
        try {
          const fieldSchema = SettingsSchema.shape[field];
          fieldSchema.parse(value);
          return void 0;
        } catch (error) {
          if (error instanceof z.ZodError) {
            return error.errors[0]?.message || "Invalid value";
          }
          return "Invalid value";
        }
      }
    };
  }
});

// src/store/store.ts
import { proxy } from "valtio";
import * as crypto from "crypto";
var store, actions, fileTrackerActions;
var init_store = __esm({
  "src/store/store.ts"() {
    init_esm_shims();
    init_debug_logger();
    init_types2();
    store = proxy({
      // Agent slice
      agent: null,
      isInitializing: false,
      initError: null,
      // Messages slice
      messages: [],
      messageCount: 0,
      // Executions slice
      executions: /* @__PURE__ */ new Map(),
      activeExecutions: [],
      // File tracker slice
      trackedFiles: /* @__PURE__ */ new Map(),
      // UI slice
      isProcessing: false,
      isStreaming: false,
      tokenCount: 0,
      inputTokenCount: 0,
      outputTokenCount: 0,
      processingTime: 0,
      inputValue: "",
      cursorPosition: 0,
      inputHistory: [],
      historyIndex: -1,
      showHelp: false,
      showModelSelector: false,
      exitConfirmation: false,
      exitConfirmationTime: 0,
      showCommandSuggestions: false,
      selectedCommandIndex: 0,
      commandSuggestions: [],
      showModelSelection: false,
      selectedModelIndex: 0,
      availableModels: ["grok-4-latest", "grok-3-latest", "grok-4", "grok-3", "grok-beta"],
      showCommandForm: false,
      // Stage management
      stageStack: [{ id: "main", type: "chat" /* CHAT */ }],
      // Settings slice
      autoEditEnabled: false,
      vsCodeOpenEnabled: false,
      dangerousBypassPermission: false,
      virtualScrollingEnabled: true,
      confirmationSettings: {
        alwaysEdit: false,
        alwaysBash: false,
        alwaysSearch: false
      },
      theme: "auto",
      model: "grok-beta",
      // Confirmation slice
      confirmationOptions: null,
      confirmationResolver: null
    });
    actions = {
      // Agent actions
      setAgent(agent) {
        store.agent = agent;
        store.initError = null;
      },
      async initializeAgent(options) {
        store.isInitializing = true;
        store.initError = null;
        try {
          const { GrokAgent: GrokAgent2 } = await Promise.resolve().then(() => (init_agent(), agent_exports));
          const agent = new GrokAgent2(options);
          store.agent = agent;
          store.isInitializing = false;
        } catch (error) {
          store.isInitializing = false;
          store.initError = error instanceof Error ? error.message : "Unknown error";
          throw error;
        }
      },
      clearAgent() {
        store.agent = null;
        store.initError = null;
      },
      setInitializing(isInitializing) {
        store.isInitializing = isInitializing;
      },
      setInitError(error) {
        store.initError = error;
      },
      // Message actions
      addMessage(message) {
        const id = `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const newMessage = {
          ...message,
          id,
          timestamp: /* @__PURE__ */ new Date()
        };
        store.messages.push(newMessage);
        store.messageCount = store.messages.length;
      },
      updateMessage(id, updates) {
        const index = store.messages.findIndex((msg) => msg.id === id);
        if (index !== -1) {
          Object.assign(store.messages[index], updates);
        }
      },
      clearMessages() {
        store.messages = [];
        store.messageCount = 0;
      },
      setMessages(messages) {
        store.messages = messages;
        store.messageCount = messages.length;
      },
      startStreaming(messageId) {
        const message = store.messages.find((msg) => msg.id === messageId);
        if (message) {
          if (!message.metadata) message.metadata = {};
          message.metadata.isStreaming = true;
        }
      },
      appendToMessage(messageId, content) {
        const message = store.messages.find((msg) => msg.id === messageId);
        if (message) {
          message.content += content;
        }
      },
      finishStreaming(messageId, metadata) {
        const message = store.messages.find((msg) => msg.id === messageId);
        if (message) {
          if (!message.metadata) message.metadata = {};
          Object.assign(message.metadata, metadata);
          message.metadata.isStreaming = false;
        }
      },
      addToolCalls(messageId, toolCalls) {
        const message = store.messages.find((msg) => msg.id === messageId);
        if (message) {
          message.toolCalls = toolCalls;
        }
      },
      // Execution actions
      addExecution(execution) {
        const id = `exec-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const newExecution = {
          ...execution,
          id,
          status: "executing",
          startTime: /* @__PURE__ */ new Date()
        };
        store.executions.set(id, newExecution);
        store.activeExecutions.push(id);
        return id;
      },
      updateExecution(id, updates) {
        const execution = store.executions.get(id);
        if (execution) {
          Object.assign(execution, updates);
          store.executions.set(id, execution);
        }
      },
      completeExecution(id, result) {
        const execution = store.executions.get(id);
        if (execution) {
          execution.status = "completed";
          execution.result = result;
          execution.endTime = /* @__PURE__ */ new Date();
          store.executions.set(id, execution);
          store.activeExecutions = store.activeExecutions.filter((execId) => execId !== id);
        }
      },
      failExecution(id, error) {
        const execution = store.executions.get(id);
        if (execution) {
          execution.status = "failed";
          execution.result = {
            success: false,
            error
          };
          execution.endTime = /* @__PURE__ */ new Date();
          store.executions.set(id, execution);
          store.activeExecutions = store.activeExecutions.filter((execId) => execId !== id);
        }
      },
      getExecution(id) {
        return store.executions.get(id);
      },
      clearExecutions() {
        store.executions = /* @__PURE__ */ new Map();
        store.activeExecutions = [];
      },
      // UI actions
      setProcessing(isProcessing) {
        store.isProcessing = isProcessing;
      },
      setStreaming(isStreaming) {
        store.isStreaming = isStreaming;
      },
      updateTokenCount(count) {
        store.tokenCount = count;
        store.outputTokenCount = count;
      },
      updateInputTokenCount(count) {
        store.inputTokenCount = count;
      },
      updateOutputTokenCount(count) {
        store.outputTokenCount = count;
        store.tokenCount = count;
      },
      updateProcessingTime(time) {
        store.processingTime = time;
      },
      setInputValue(value) {
        store.inputValue = value;
      },
      getInputValue() {
        return store.inputValue;
      },
      setCursorPosition(position) {
        store.cursorPosition = position;
      },
      addToHistory(input) {
        if (!input.trim()) return;
        const filtered = store.inputHistory.filter((item) => item !== input);
        const newHistory = [...filtered, input];
        store.inputHistory = newHistory.length > 100 ? newHistory.slice(-100) : newHistory;
        store.historyIndex = -1;
      },
      navigateHistory(direction) {
        if (direction === "up") {
          const newIndex = store.historyIndex === -1 ? store.inputHistory.length - 1 : Math.max(0, store.historyIndex - 1);
          if (newIndex >= 0 && newIndex < store.inputHistory.length) {
            store.historyIndex = newIndex;
            store.inputValue = store.inputHistory[newIndex];
            store.cursorPosition = store.inputHistory[newIndex].length;
          }
        } else {
          if (store.historyIndex === -1) return;
          const newIndex = store.historyIndex + 1;
          if (newIndex >= store.inputHistory.length) {
            store.historyIndex = -1;
            store.inputValue = "";
            store.cursorPosition = 0;
          } else {
            store.historyIndex = newIndex;
            store.inputValue = store.inputHistory[newIndex];
            store.cursorPosition = store.inputHistory[newIndex].length;
          }
        }
      },
      toggleHelp() {
        store.showHelp = !store.showHelp;
      },
      toggleModelSelector() {
        store.showModelSelector = !store.showModelSelector;
      },
      setExitConfirmation(show) {
        store.exitConfirmation = show;
        if (show) {
          store.exitConfirmationTime = Date.now();
        }
      },
      // Settings actions
      setAutoEdit(enabled) {
        store.autoEditEnabled = enabled;
        actions.saveSettings();
      },
      setVSCodeOpen(enabled) {
        store.vsCodeOpenEnabled = enabled;
        actions.saveSettings();
      },
      setDangerousBypassPermission(enabled) {
        store.dangerousBypassPermission = enabled;
        actions.saveSettings();
      },
      setVirtualScrolling(enabled) {
        store.virtualScrollingEnabled = enabled;
        actions.saveSettings();
      },
      updateConfirmationSettings(settings) {
        Object.assign(store.confirmationSettings, settings);
        actions.saveSettings();
      },
      setTheme(theme) {
        store.theme = theme;
        actions.saveSettings();
      },
      setModel(model) {
        store.model = model;
        actions.saveSettings();
      },
      // Command form actions
      setShowCommandForm(show) {
        store.showCommandForm = show;
      },
      // UI actions
      setShowHelp(show) {
        store.showHelp = show;
      },
      async loadSettings() {
        try {
          const { SettingsManager: SettingsManager2 } = await Promise.resolve().then(() => (init_settings_manager(), settings_manager_exports));
          const settingsManager = SettingsManager2.getInstance();
          const { settings, isValid } = settingsManager.loadSettings();
          if (isValid && settings) {
            if (settings.model) store.model = settings.model;
            if (settings.theme) store.theme = settings.theme;
            if (settings.autoEditEnabled !== void 0) store.autoEditEnabled = settings.autoEditEnabled;
            if (settings.vsCodeOpenEnabled !== void 0) store.vsCodeOpenEnabled = settings.vsCodeOpenEnabled;
            if (settings.dangerousBypassPermission !== void 0) store.dangerousBypassPermission = settings.dangerousBypassPermission;
            if (settings.virtualScrollingEnabled !== void 0) store.virtualScrollingEnabled = settings.virtualScrollingEnabled;
            if (settings.confirmationSettings) {
              Object.assign(store.confirmationSettings, settings.confirmationSettings);
            }
          }
        } catch (error) {
          debug.error("Failed to load settings:", error);
        }
      },
      async saveSettings() {
        try {
          const settingsToSave = {
            autoEditEnabled: store.autoEditEnabled,
            vsCodeOpenEnabled: store.vsCodeOpenEnabled,
            dangerousBypassPermission: store.dangerousBypassPermission,
            virtualScrollingEnabled: store.virtualScrollingEnabled,
            confirmationSettings: store.confirmationSettings,
            theme: store.theme,
            model: store.model
          };
        } catch (error) {
          debug.error("Failed to save settings:", error);
        }
      },
      // Confirmation actions
      requestConfirmation(options) {
        return new Promise((resolve) => {
          store.confirmationOptions = options;
          store.confirmationResolver = resolve;
        });
      },
      respondToConfirmation(result) {
        if (store.confirmationResolver) {
          store.confirmationResolver(result);
          store.confirmationOptions = null;
          store.confirmationResolver = null;
        }
      },
      cancelConfirmation() {
        if (store.confirmationResolver) {
          store.confirmationResolver({ confirmed: false });
          store.confirmationOptions = null;
          store.confirmationResolver = null;
        }
      },
      // File tracker actions
      updateFile(filePath2, content) {
        const hash = crypto.createHash("sha256").update(content).digest("hex");
        const lineCount = content.split("\n").length;
        store.trackedFiles.set(filePath2, {
          hash,
          lastRead: /* @__PURE__ */ new Date(),
          lineCount
        });
      },
      hasFile(filePath2) {
        return store.trackedFiles.has(filePath2);
      },
      getFileInfo(filePath2) {
        return store.trackedFiles.get(filePath2);
      },
      verifyFileHash(filePath2, content) {
        const fileInfo = store.trackedFiles.get(filePath2);
        if (!fileInfo) return false;
        const currentHash = crypto.createHash("sha256").update(content).digest("hex");
        return fileInfo.hash === currentHash;
      },
      clearFile(filePath2) {
        store.trackedFiles.delete(filePath2);
      },
      clearAllFiles() {
        store.trackedFiles.clear();
      },
      // Stage management actions
      getCurrentStage() {
        return store.stageStack[store.stageStack.length - 1];
      },
      pushStage(stage) {
        store.stageStack.push(stage);
      },
      popStage() {
        if (store.stageStack.length > 1) {
          store.stageStack.pop();
        }
      },
      replaceStage(stage) {
        if (store.stageStack.length > 0) {
          store.stageStack[store.stageStack.length - 1] = stage;
        }
      },
      clearStages() {
        store.stageStack = [{ id: "main", type: "chat" /* CHAT */ }];
      },
      getStageStack() {
        return store.stageStack;
      }
    };
    fileTrackerActions = {
      updateFile: actions.updateFile,
      hasFile: actions.hasFile,
      getFileInfo: actions.getFileInfo,
      verifyFileHash: actions.verifyFileHash,
      clearFile: actions.clearFile,
      clearAllFiles: actions.clearAllFiles
    };
  }
});

// src/store/index.ts
var init_store2 = __esm({
  "src/store/index.ts"() {
    init_esm_shims();
    init_store();
  }
});

// src/utils/confirmation-service.ts
import { EventEmitter as EventEmitter2 } from "events";
var ConfirmationService;
var init_confirmation_service = __esm({
  "src/utils/confirmation-service.ts"() {
    init_esm_shims();
    init_store2();
    ConfirmationService = class _ConfirmationService extends EventEmitter2 {
      constructor() {
        super();
        this.skipConfirmationThisSession = false;
        this.pendingConfirmation = null;
        this.resolveConfirmation = null;
        // Session flags for different operation types
        this.sessionFlags = {
          fileOperations: false,
          bashCommands: false,
          allOperations: false,
          createFiles: false,
          editFiles: false
        };
      }
      static getInstance() {
        if (!_ConfirmationService.instance) {
          _ConfirmationService.instance = new _ConfirmationService();
        }
        return _ConfirmationService.instance;
      }
      async requestConfirmation(options, operationType = "file") {
        if (store.dangerousBypassPermission) {
          return { confirmed: true };
        }
        if (store.autoEditEnabled && (operationType === "file_edit" || operationType === "file_create")) {
          return { confirmed: true };
        }
        if (this.sessionFlags.allOperations || operationType === "file" && this.sessionFlags.fileOperations || operationType === "bash" && this.sessionFlags.bashCommands || operationType === "file_create" && this.sessionFlags.createFiles || operationType === "file_edit" && this.sessionFlags.editFiles) {
          return { confirmed: true };
        }
        this.pendingConfirmation = new Promise((resolve) => {
          this.resolveConfirmation = resolve;
        });
        setImmediate(() => {
          this.emit("confirmation-requested", options);
        });
        const result = await this.pendingConfirmation;
        if (result.dontAskAgain) {
          if (operationType === "file") {
            this.sessionFlags.fileOperations = true;
          } else if (operationType === "bash") {
            this.sessionFlags.bashCommands = true;
          } else if (operationType === "file_create") {
            this.sessionFlags.createFiles = true;
          } else if (operationType === "file_edit") {
            this.sessionFlags.editFiles = true;
          }
        }
        return result;
      }
      confirmOperation(confirmed, dontAskAgain) {
        if (this.resolveConfirmation) {
          this.resolveConfirmation({ confirmed, dontAskAgain });
          this.resolveConfirmation = null;
          this.pendingConfirmation = null;
        }
      }
      rejectOperation(feedback) {
        if (this.resolveConfirmation) {
          this.resolveConfirmation({ confirmed: false, feedback });
          this.resolveConfirmation = null;
          this.pendingConfirmation = null;
        }
      }
      isPending() {
        return this.pendingConfirmation !== null;
      }
      resetSession() {
        this.sessionFlags = {
          fileOperations: false,
          bashCommands: false,
          allOperations: false,
          createFiles: false,
          editFiles: false
        };
      }
      getSessionFlags() {
        return { ...this.sessionFlags };
      }
      setSessionFlag(flagType, value) {
        this.sessionFlags[flagType] = value;
      }
    };
  }
});

// src/registry/logger.ts
function createToolLogger(toolId, enabled = true) {
  const isInteractive = process.stdout.isTTY && !process.env.CI;
  return isInteractive ? new NullLogger() : new ConsoleLogger(`[${toolId}]`, enabled);
}
var ConsoleLogger, NullLogger;
var init_logger = __esm({
  "src/registry/logger.ts"() {
    init_esm_shims();
    ConsoleLogger = class {
      constructor(prefix = "[Tool]", enabled = true) {
        this.prefix = prefix;
        this.enabled = enabled;
      }
      debug(message, ...args) {
        if (this.enabled && process.env.DEBUG === "true") {
          console.log(`${this.prefix} DEBUG:`, message, ...args);
        }
      }
      info(message, ...args) {
        if (this.enabled) {
          console.log(`${this.prefix} INFO:`, message, ...args);
        }
      }
      warn(message, ...args) {
        if (this.enabled) {
          console.warn(`${this.prefix} WARN:`, message, ...args);
        }
      }
      error(message, ...args) {
        if (this.enabled) {
          console.error(`${this.prefix} ERROR:`, message, ...args);
        }
      }
    };
    NullLogger = class {
      debug() {
      }
      info() {
      }
      warn() {
      }
      error() {
      }
    };
  }
});

// src/registry/registry.ts
function createToolRegistry(workingDirectory) {
  return new ToolRegistryImpl(workingDirectory);
}
var ToolRegistryImpl;
var init_registry = __esm({
  "src/registry/registry.ts"() {
    init_esm_shims();
    init_validation();
    init_composition();
    init_confirmation_service();
    init_logger();
    ToolRegistryImpl = class {
      constructor(workingDirectory = process.cwd()) {
        this.tools = /* @__PURE__ */ new Map();
        this.context = {
          registry: this,
          workingDirectory,
          confirmationService: ConfirmationService.getInstance(),
          state: /* @__PURE__ */ new Map()
        };
      }
      /**
       * Register a new tool
       */
      register(tool) {
        if (this.tools.has(tool.id)) {
          throw new Error(`Tool with id '${tool.id}' already registered`);
        }
        this.tools.set(tool.id, {
          definition: tool,
          initialized: false,
          executionCount: 0,
          totalDuration: 0
        });
      }
      /**
       * Unregister a tool
       */
      async unregister(toolId) {
        const tool = this.tools.get(toolId);
        if (!tool) {
          throw new Error(`Tool '${toolId}' not found`);
        }
        if (tool.definition.cleanup && tool.initialized) {
          await tool.definition.cleanup(this.context);
        }
        this.tools.delete(toolId);
      }
      /**
       * Get a registered tool
       */
      get(toolId) {
        return this.tools.get(toolId);
      }
      /**
       * List tools with optional filter
       */
      list(filter) {
        let tools = Array.from(this.tools.values()).map((t) => t.definition);
        if (filter) {
          if (filter.category) {
            tools = tools.filter((t) => t.category === filter.category);
          }
          if (filter.capabilities && filter.capabilities.length > 0) {
            tools = tools.filter(
              (t) => t.capabilities && filter.capabilities.every((cap) => t.capabilities.includes(cap))
            );
          }
          if (filter.tags && filter.tags.length > 0) {
            tools = tools.filter(
              (t) => t.tags && filter.tags.some((tag) => t.tags.includes(tag))
            );
          }
          if (filter.composable !== void 0) {
            tools = tools.filter((t) => t.composable === filter.composable);
          }
        }
        return tools;
      }
      /**
       * Search tools by query
       */
      search(query) {
        const lowerQuery = query.toLowerCase();
        return Array.from(this.tools.values()).map((t) => t.definition).filter((tool) => {
          const searchText = [
            tool.id,
            tool.name,
            tool.description,
            ...tool.tags || []
          ].join(" ").toLowerCase();
          return searchText.includes(lowerQuery);
        });
      }
      /**
       * Execute a tool
       */
      async execute(toolId, args) {
        const registeredTool = this.tools.get(toolId);
        if (!registeredTool) {
          return {
            success: false,
            error: `Tool '${toolId}' not found`
          };
        }
        const tool = registeredTool.definition;
        const validation = this.validateArguments(toolId, args);
        if (!validation.valid) {
          return {
            success: false,
            error: `Validation failed: ${validation.errors.map((e) => e.message).join(", ")}`
          };
        }
        if (!registeredTool.initialized && tool.initialize) {
          try {
            const initContext = {
              ...this.context,
              logger: createToolLogger(toolId)
            };
            await tool.initialize(initContext);
            registeredTool.initialized = true;
          } catch (error) {
            return {
              success: false,
              error: `Failed to initialize tool: ${error instanceof Error ? error.message : String(error)}`
            };
          }
        }
        const startTime = Date.now();
        try {
          const executionContext = {
            ...this.context,
            logger: createToolLogger(toolId)
          };
          const result = await tool.execute(args, executionContext);
          const duration = Date.now() - startTime;
          registeredTool.executionCount++;
          registeredTool.lastExecuted = /* @__PURE__ */ new Date();
          registeredTool.totalDuration += duration;
          return result;
        } catch (error) {
          return {
            success: false,
            error: `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }
      /**
       * Create a composed tool
       */
      compose(pattern, toolIds, config) {
        const tools = toolIds.map((id) => {
          const tool = this.get(id);
          if (!tool) {
            throw new Error(`Tool '${id}' not found for composition`);
          }
          return tool.definition;
        });
        return createComposedTool(pattern, tools, config || {});
      }
      /**
       * Validate tool arguments
       */
      validateArguments(toolId, args) {
        const tool = this.get(toolId);
        if (!tool) {
          return {
            valid: false,
            errors: [{ field: "toolId", message: `Tool '${toolId}' not found` }]
          };
        }
        return validateArguments(tool.definition.arguments || [], args);
      }
      /**
       * Get the registry context
       */
      getContext() {
        return this.context;
      }
      /**
       * Update working directory
       */
      setWorkingDirectory(dir) {
        this.context.workingDirectory = dir;
      }
      /**
       * Get tool statistics
       */
      getStats() {
        const tools = Array.from(this.tools.entries());
        const byCategory = {};
        const byCapability = {};
        tools.forEach(([_, tool]) => {
          const def = tool.definition;
          if (def.category) {
            byCategory[def.category] = (byCategory[def.category] || 0) + 1;
          }
          if (def.capabilities) {
            def.capabilities.forEach((cap) => {
              byCapability[cap] = (byCapability[cap] || 0) + 1;
            });
          }
        });
        const mostUsed = tools.map(([id, tool]) => ({ toolId: id, count: tool.executionCount })).filter((t) => t.count > 0).sort((a, b) => b.count - a.count).slice(0, 10);
        return {
          totalTools: tools.length,
          byCategory,
          byCapability,
          mostUsed
        };
      }
      /**
       * Get execution stats in the format expected by tests
       */
      getExecutionStats() {
        const stats = {};
        this.tools.forEach((tool, id) => {
          stats[id] = {
            executionCount: tool.executionCount,
            totalDuration: tool.totalDuration
          };
        });
        return stats;
      }
    };
  }
});

// src/registry/builder.ts
function createTool() {
  return new ToolBuilder();
}
var ToolBuilder;
var init_builder = __esm({
  "src/registry/builder.ts"() {
    init_esm_shims();
    ToolBuilder = class {
      constructor() {
        this.metadata = {};
        this.args = [];
        this.schemas = {};
      }
      /**
       * Set tool ID (required)
       */
      id(id) {
        this.metadata.id = id;
        return this;
      }
      /**
       * Set tool name
       */
      name(name) {
        this.metadata.name = name;
        return this;
      }
      /**
       * Set tool description
       */
      description(description) {
        this.metadata.description = description;
        return this;
      }
      /**
       * Set tool version
       */
      version(version) {
        this.metadata.version = version;
        return this;
      }
      /**
       * Set tool author
       */
      author(author) {
        this.metadata.author = author;
        return this;
      }
      /**
       * Set tool category
       */
      category(category) {
        this.metadata.category = category;
        return this;
      }
      /**
       * Add tags
       */
      tags(...tags) {
        this.metadata.tags = [...this.metadata.tags || [], ...tags];
        return this;
      }
      /**
       * Add capabilities
       */
      capabilities(...capabilities) {
        this.metadata.capabilities = [...this.metadata.capabilities || [], ...capabilities];
        return this;
      }
      /**
       * Add an argument
       */
      argument(spec) {
        this.args.push(spec);
        return this;
      }
      /**
       * Add a string argument (convenience method)
       */
      stringArg(name, description, options) {
        return this.argument({
          name,
          type: "string",
          description,
          ...options
        });
      }
      /**
       * Add a number argument (convenience method)
       */
      numberArg(name, description, options) {
        return this.argument({
          name,
          type: "number",
          description,
          ...options
        });
      }
      /**
       * Add a boolean argument (convenience method)
       */
      booleanArg(name, description, options) {
        return this.argument({
          name,
          type: "boolean",
          description,
          ...options
        });
      }
      /**
       * Add an array argument (convenience method)
       */
      arrayArg(name, description, options) {
        return this.argument({
          name,
          type: "array",
          description,
          ...options
        });
      }
      /**
       * Set input schema for composition
       */
      inputSchema(schema) {
        this.schemas.input = schema;
        return this;
      }
      /**
       * Set output schema for composition
       */
      outputSchema(schema) {
        this.schemas.output = schema;
        return this;
      }
      /**
       * Make tool composable
       */
      composable(value = true) {
        this.isComposable = value;
        return this;
      }
      /**
       * Set execution function
       */
      execute(executor) {
        this.executor = executor;
        return this;
      }
      /**
       * Set initialization hook
       */
      onInitialize(hook) {
        this.initHook = hook;
        return this;
      }
      /**
       * Set cleanup hook
       */
      onCleanup(hook) {
        this.cleanupHook = hook;
        return this;
      }
      /**
       * Set custom result renderer
       */
      renderResult(renderer) {
        this.renderer = renderer;
        return this;
      }
      /**
       * Add examples for better AI understanding
       */
      examples(examples) {
        this.examplesList = examples;
        return this;
      }
      /**
       * Build the tool definition
       */
      build() {
        if (!this.metadata.id) {
          throw new Error("Tool ID is required");
        }
        if (!this.metadata.name) {
          this.metadata.name = this.metadata.id;
        }
        if (!this.metadata.description) {
          throw new Error("Tool description is required");
        }
        if (!this.executor) {
          throw new Error("Tool executor is required");
        }
        const tool = {
          id: this.metadata.id,
          name: this.metadata.name,
          description: this.metadata.description,
          version: this.metadata.version,
          author: this.metadata.author,
          tags: this.metadata.tags,
          category: this.metadata.category,
          capabilities: this.metadata.capabilities,
          arguments: this.args.length > 0 ? this.args : void 0,
          execute: this.executor,
          composable: this.isComposable,
          inputSchema: this.schemas.input,
          outputSchema: this.schemas.output,
          renderResult: this.renderer,
          examples: this.examplesList
        };
        if (this.initHook) {
          tool.initialize = this.initHook;
        }
        if (this.cleanupHook) {
          tool.cleanup = this.cleanupHook;
        }
        return tool;
      }
    };
  }
});

// src/registry/adapters.ts
function toolDefinitionToGrokTool(tool) {
  const properties = {};
  const required = [];
  if (tool.arguments) {
    for (const arg of tool.arguments) {
      properties[arg.name] = argumentSpecToProperty(arg);
      if (arg.required) {
        required.push(arg.name);
      }
    }
  }
  return {
    type: "function",
    function: {
      name: tool.id,
      description: generateToolDescription(tool),
      parameters: {
        type: "object",
        properties,
        required
      }
    }
  };
}
function argumentSpecToProperty(arg) {
  const property = {
    type: mapArgumentType(arg.type),
    description: arg.description
  };
  if (arg.enum) {
    property.enum = arg.enum;
  }
  if (arg.default !== void 0) {
    property.default = arg.default;
  }
  return property;
}
function mapArgumentType(type) {
  switch (type) {
    case "any":
      return "string";
    // OpenAI doesn't have 'any', use string as fallback
    default:
      return type;
  }
}
function generateToolDescription(tool) {
  const parts = [tool.description];
  if (tool.capabilities && tool.capabilities.length > 0) {
    const capabilities = tool.capabilities.map((cap) => describeCapability(cap)).filter((desc) => desc).join(", ");
    if (capabilities) {
      parts.push(`Capabilities: ${capabilities}`);
    }
  }
  if (tool.tags && tool.tags.length > 0) {
    parts.push(`Tags: ${tool.tags.join(", ")}`);
  }
  if (tool.examples && tool.examples.length > 0) {
    parts.push("\n\nExamples:");
    tool.examples.forEach((example, index) => {
      parts.push(`
Example ${index + 1}: ${example.description}`);
      parts.push(`Arguments: ${JSON.stringify(example.arguments, null, 2)}`);
      if (example.result) {
        parts.push(`Expected result: ${example.result}`);
      }
    });
  }
  return parts.join(". ");
}
function describeCapability(capability) {
  const descriptions = {
    ["file:read" /* FileRead */]: "read files",
    ["file:write" /* FileWrite */]: "write files",
    ["system:execute" /* SystemExecute */]: "execute system commands",
    ["network:access" /* NetworkAccess */]: "access network resources",
    ["user:confirmation" /* UserConfirmation */]: "request user confirmation"
  };
  return descriptions[capability] || "";
}
function generateGrokTools(registry) {
  const tools = registry.list();
  return tools.map((tool) => toolDefinitionToGrokTool(tool));
}
function createLegacyToolWrapper(tool, context) {
  return {
    name: tool.name,
    description: tool.description,
    execute: async (...args) => {
      let namedArgs = {};
      if (tool.arguments && args.length > 0) {
        if (typeof args[0] === "object" && !Array.isArray(args[0]) && tool.arguments.length > 1) {
          namedArgs = args[0];
        } else {
          tool.arguments.forEach((spec, index) => {
            if (index < args.length) {
              namedArgs[spec.name] = args[index];
            }
          });
        }
      }
      namedArgs = applyDefaults(tool.arguments || [], namedArgs);
      namedArgs = coerceArguments(tool.arguments || [], namedArgs);
      return tool.execute(namedArgs, context);
    }
  };
}
function createToolExecutor(registry) {
  return async (toolName, args) => {
    let parsedArgs = args;
    if (typeof args === "string") {
      try {
        parsedArgs = JSON.parse(args);
      } catch {
        parsedArgs = { input: args };
      }
    }
    return registry.execute(toolName, parsedArgs);
  };
}
function generateToolPromptSection(tools) {
  const sections = [
    `You have access to ${tools.length} tools:`
  ];
  const byCategory = /* @__PURE__ */ new Map();
  const uncategorized = [];
  for (const tool of tools) {
    if (tool.category) {
      const existing = byCategory.get(tool.category) || [];
      existing.push(tool);
      byCategory.set(tool.category, existing);
    } else {
      uncategorized.push(tool);
    }
  }
  for (const [category, categoryTools] of byCategory) {
    sections.push(`
## ${category.charAt(0).toUpperCase() + category.slice(1)} Tools
`);
    for (const tool of categoryTools) {
      sections.push(formatToolForPrompt(tool));
    }
  }
  if (uncategorized.length > 0) {
    sections.push("\n## Other Tools\n");
    for (const tool of uncategorized) {
      sections.push(formatToolForPrompt(tool));
    }
  }
  sections.push("\n## Tool Usage\n");
  sections.push("- Always check tool arguments before calling");
  sections.push("- Handle tool errors gracefully");
  sections.push("- Use appropriate tools for the task");
  sections.push("- Combine tools when needed for complex tasks");
  return sections.join("\n");
}
function formatToolForPrompt(tool) {
  const lines = [
    `### ${tool.name}`,
    tool.description
  ];
  if (tool.arguments && tool.arguments.length > 0) {
    lines.push("\nArguments:");
    for (const arg of tool.arguments) {
      const required = arg.required ? " (required)" : " (optional)";
      const defaultStr = arg.default !== void 0 ? `, default: ${JSON.stringify(arg.default)}` : "";
      lines.push(`- ${arg.name}: ${arg.type}${required} - ${arg.description}${defaultStr}`);
      if (arg.enum) {
        lines.push(`  Allowed values: ${arg.enum.join(", ")}`);
      }
    }
  }
  if (tool.capabilities && tool.capabilities.length > 0) {
    lines.push(`
Requires: ${tool.capabilities.map((c) => describeCapability(c)).join(", ")}`);
  }
  return lines.join("\n");
}
var init_adapters = __esm({
  "src/registry/adapters.ts"() {
    init_esm_shims();
    init_types();
    init_validation();
  }
});

// src/registry/builtin-tools.ts
var builtin_tools_exports = {};
__export(builtin_tools_exports, {
  builtInTools: () => builtInTools,
  builtInToolsMap: () => builtInToolsMap
});
var builtInTools, builtInToolsMap;
var init_builtin_tools = __esm({
  "src/registry/builtin-tools.ts"() {
    init_esm_shims();
    builtInTools = [];
    builtInToolsMap = /* @__PURE__ */ new Map();
  }
});

// src/registry/manifest-loader.ts
import * as fs3 from "fs";
import * as path5 from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
async function loadBuiltInToolsFromManifest() {
  const tools = [];
  try {
    let baseDir;
    if (typeof __dirname !== "undefined") {
      baseDir = __dirname;
    } else if (typeof import.meta.url !== "undefined") {
      const __filename2 = fileURLToPath2(import.meta.url);
      baseDir = path5.dirname(__filename2);
    } else {
      baseDir = process.cwd();
    }
    let manifestPath = path5.join(baseDir, "tool-manifest.json");
    if (!fs3.existsSync(manifestPath)) {
      manifestPath = path5.join(baseDir, "..", "..", "dist", "tool-manifest.json");
    }
    debug.log(`[ManifestLoader] Looking for manifest at: ${manifestPath}`);
    if (!fs3.existsSync(manifestPath)) {
      debug.warn("[ManifestLoader] No tool manifest found, falling back to static imports");
      const { builtInTools: builtInTools2 } = await Promise.resolve().then(() => (init_builtin_tools(), builtin_tools_exports));
      return builtInTools2;
    }
    const manifestContent = fs3.readFileSync(manifestPath, "utf-8");
    const manifest = JSON.parse(manifestContent);
    debug.log(`[ManifestLoader] Found manifest with ${manifest.tools.length} tools`);
    for (const toolInfo of manifest.tools) {
      try {
        const modulePath = path5.isAbsolute(toolInfo.module) ? toolInfo.module : path5.join(path5.dirname(manifestPath), toolInfo.module);
        debug.log(`[ManifestLoader] Loading tool ${toolInfo.id} from ${modulePath}`);
        const module2 = await import(modulePath);
        const tool = module2.default || module2;
        if (isValidTool(tool)) {
          tools.push(tool);
          debug.log(`[ManifestLoader] Successfully loaded tool: ${tool.id}`);
        } else {
          debug.warn(`[ManifestLoader] Invalid tool in ${modulePath}`);
        }
      } catch (error) {
        debug.error(`[ManifestLoader] Failed to load tool ${toolInfo.id}:`, error);
      }
    }
    debug.log(`[ManifestLoader] Loaded ${tools.length} tools from manifest`);
    return tools;
  } catch (error) {
    debug.error("[ManifestLoader] Error loading manifest:", error);
    const { builtInTools: builtInTools2 } = await Promise.resolve().then(() => (init_builtin_tools(), builtin_tools_exports));
    return builtInTools2;
  }
}
function isValidTool(obj) {
  return obj && typeof obj === "object" && typeof obj.id === "string" && typeof obj.description === "string" && typeof obj.execute === "function";
}
var init_manifest_loader = __esm({
  "src/registry/manifest-loader.ts"() {
    init_esm_shims();
    init_debug_logger();
  }
});

// src/registry/loader.ts
import * as fs4 from "fs/promises";
import * as path6 from "path";
import * as os3 from "os";
import * as crypto2 from "crypto";
import { pathToFileURL } from "url";
function shouldShareDependency(request) {
  if (request === "react" || request === "ink" || request.startsWith("ink/")) {
    return true;
  }
  if (request === "@ziggler/clanker" || request.startsWith("@ziggler/clanker/")) {
    return true;
  }
  if (request.startsWith("../../registry") || request.startsWith("../../utils/") || request.startsWith("../../ui/") || request.startsWith("../../store/")) {
    return true;
  }
  const sharedDeps = [
    "chalk",
    "fs-extra",
    "zod",
    "commander",
    "dotenv",
    "openai",
    "axios",
    "uuid",
    "prismjs",
    "immer"
  ];
  return sharedDeps.includes(request);
}
function createToolLoader(registry, options) {
  return new ToolLoader2(registry, options);
}
var ToolLoader2;
var init_loader = __esm({
  "src/registry/loader.ts"() {
    init_esm_shims();
    init_debug_logger();
    init_manifest_loader();
    ToolLoader2 = class {
      // filePath -> watcher
      constructor(registry, options = {}) {
        this.registry = registry;
        this.loadedTools = /* @__PURE__ */ new Map();
        // toolId -> {filePath, hash}
        this.watcherCleanup = [];
        this.fileWatchers = /* @__PURE__ */ new Map();
        const homeDir = os3.homedir();
        const clankDir = path6.join(homeDir, ".clanker");
        this.options = {
          directories: options.directories || [process.cwd(), clankDir],
          recursive: options.recursive ?? true,
          extensions: options.extensions || [".ts", ".tsx", ".js", ".jsx"],
          watch: options.watch ?? false,
          loadBuiltins: options.loadBuiltins ?? true
        };
        debug.log(`[ToolLoader] Configured directories:`, this.options.directories);
      }
      /**
       * Load all tools from configured directories
       */
      async loadTools() {
        if (this.options.loadBuiltins) {
          await this.loadBuiltinTools();
        }
        for (const dir of this.options.directories) {
          const toolsDir = path6.join(dir, dir.endsWith("tools") ? "" : "tools");
          debug.log(`[ToolLoader] Loading from directory: ${dir} -> ${toolsDir}`);
          await this.loadFromDirectory(toolsDir);
        }
        if (this.options.watch) {
          await this.setupWatchers();
        }
      }
      /**
       * Load built-in tools from the package
       */
      async loadBuiltinTools() {
        try {
          const tools = await loadBuiltInToolsFromManifest();
          debug.log(`[ToolLoader] Loading ${tools.length} built-in tools`);
          for (const tool of tools) {
            if (this.isValidTool(tool)) {
              this.registry.register(tool);
              const registeredTool = this.registry.get(tool.id);
              if (registeredTool) {
                registeredTool.hash = "builtin";
                registeredTool.filePath = `builtin:${tool.id}`;
              }
              this.loadedTools.set(tool.id, { path: `builtin:${tool.id}`, hash: "builtin" });
              debug.log(`[ToolLoader] Loaded built-in tool: ${tool.id}`);
            } else {
              debug.warn(`[ToolLoader] Invalid built-in tool`);
            }
          }
          debug.log(`[ToolLoader] Successfully loaded ${tools.length} built-in tools`);
        } catch (error) {
          debug.warn("[ToolLoader] Failed to load built-in tools:", error);
        }
      }
      /**
       * Load tools from a directory
       */
      async loadFromDirectory(directory) {
        if (!await this.exists(directory)) {
          debug.log(`[ToolLoader] Directory does not exist: ${directory}`);
          return;
        }
        debug.log(`[ToolLoader] Scanning directory: ${directory}`);
        try {
          await this.scanDirectory(directory, this.options.recursive);
        } catch (error) {
          debug.error(`[ToolLoader] Error scanning directory ${directory}:`, error);
        }
      }
      /**
       * Recursively scan a directory for tool files
       */
      async scanDirectory(directory, recursive) {
        let entries;
        try {
          entries = await fs4.readdir(directory, { withFileTypes: true });
        } catch (error) {
          return;
        }
        const currentLink = entries.find((entry) => entry.name === "current" && entry.isSymbolicLink());
        if (currentLink) {
          const currentPath = path6.join(directory, "current", "index.js");
          if (await this.exists(currentPath)) {
            debug.log(`[ToolLoader] Found package-managed tool at ${currentPath}`);
            await this.loadToolFile(currentPath);
            return;
          }
        }
        const files = entries.filter((entry) => entry.isFile() && this.isToolFile(entry.name)).map((entry) => path6.join(directory, entry.name));
        debug.log(`[ToolLoader] Found ${files.length} tool files in ${directory}`);
        for (const file of files) {
          await this.loadToolFile(file);
        }
        if (!recursive) return;
        const subdirs = entries.filter((entry) => entry.isDirectory()).map((entry) => path6.join(directory, entry.name));
        for (const subdir of subdirs) {
          await this.scanDirectory(subdir, true);
        }
      }
      /**
       * Load a single tool file
       */
      async loadToolFile(filePath2) {
        try {
          debug.log(`[ToolLoader] Attempting to load: ${filePath2}`);
          const fileHash = await this.computeFileHash(filePath2);
          debug.log(`[ToolLoader] File hash for ${filePath2}: ${fileHash.substring(0, 8)}...`);
          const existingEntry = Array.from(this.loadedTools.entries()).find(([_, info]) => info.path === filePath2);
          if (existingEntry && existingEntry[1].hash === fileHash) {
            debug.log(`[ToolLoader] Tool already loaded with same version: ${existingEntry[0]}`);
            return;
          }
          const moduleExports = await this.importModule(filePath2);
          debug.log(`[ToolLoader] Module exports for ${filePath2}:`, Object.keys(moduleExports));
          const tool = await this.extractTool(moduleExports);
          if (!tool) {
            debug.warn(`[ToolLoader] No valid tool found in ${filePath2}`);
            return;
          }
          debug.log(`[ToolLoader] Extracted tool:`, { id: tool.id, name: tool.name });
          if (!this.isValidTool(tool)) {
            debug.warn(`[ToolLoader] Invalid tool in ${filePath2}`);
            return;
          }
          if (this.loadedTools.has(tool.id)) {
            const oldInfo = this.loadedTools.get(tool.id);
            if (oldInfo.hash !== fileHash) {
              debug.log(`[ToolLoader] Tool ${tool.id} has changed, unloading old version`);
              await this.unloadTool(tool.id);
            } else {
              debug.log(`[ToolLoader] Tool ${tool.id} unchanged, skipping reload`);
              return;
            }
          }
          this.registry.register(tool);
          const registeredTool = this.registry.get(tool.id);
          if (registeredTool) {
            registeredTool.hash = fileHash;
            registeredTool.filePath = filePath2;
          }
          this.loadedTools.set(tool.id, { path: filePath2, hash: fileHash });
          debug.log(`[ToolLoader] Loaded tool: ${tool.id} from ${filePath2}`);
        } catch (error) {
          debug.error(`[ToolLoader] Failed to load ${filePath2}:`, error);
        }
      }
      /**
       * Import a module handling TypeScript if needed
       */
      async importModule(filePath) {
        try {
          if (filePath.endsWith(".js")) {
            try {
              const { createRequire } = await import("module");
              const baseUrl = typeof import.meta !== "undefined" && import.meta.url ? import.meta.url : pathToFileURL(process.cwd() + "/").href;
              const require2 = createRequire(baseUrl);
              const loadedModule2 = this.loadWithSharedDependencies(require2, filePath);
              debug.log(`[ToolLoader] Loaded ${filePath} using createRequire with shared deps`);
              return loadedModule2;
            } catch (error) {
              debug.log(`[ToolLoader] createRequire failed for ${filePath}:`, error);
            }
            try {
              const requireFunc = eval("require");
              const loadedModule = this.loadWithSharedDependencies(requireFunc, filePath);
              debug.log(`[ToolLoader] Loaded ${filePath} using direct require with shared deps`);
              return loadedModule;
            } catch (error) {
              debug.log(`[ToolLoader] Direct require failed for ${filePath}:`, error);
            }
            try {
              const fileUrl2 = pathToFileURL(filePath).href;
              const module2 = await import(fileUrl2);
              debug.log(`[ToolLoader] Loaded ${filePath} using dynamic import`);
              return module2;
            } catch (error) {
              debug.log(`[ToolLoader] Dynamic import failed for ${filePath}:`, error);
            }
          }
          const fileUrl = pathToFileURL(filePath).href;
          const module = await import(fileUrl);
          return module;
        } catch (error) {
          debug.error(`[ToolLoader] Import error for ${filePath}:`, error);
          throw error;
        }
      }
      /**
       * Extract tool from module exports
       */
      async extractTool(moduleExports) {
        if (moduleExports.default) {
          const defaultExport = moduleExports.default;
          if (typeof defaultExport === "function") {
            try {
              const result = await defaultExport();
              if (this.isValidTool(result)) return result;
            } catch {
              if (this.isValidTool(defaultExport)) {
                return defaultExport;
              }
            }
          }
          if (this.isValidTool(defaultExport)) {
            return defaultExport;
          }
          if (Array.isArray(defaultExport) && defaultExport.length > 0) {
            const firstTool = defaultExport[0];
            if (this.isValidTool(firstTool)) return firstTool;
          }
        }
        const namedExports = ["tool", "createTool"];
        for (const exportName of namedExports) {
          if (exportName in moduleExports) {
            const exported = moduleExports[exportName];
            if (typeof exported === "function") {
              try {
                const result = await exported();
                if (this.isValidTool(result)) return result;
              } catch {
              }
            }
            if (this.isValidTool(exported)) {
              return exported;
            }
          }
        }
        if (this.isValidTool(moduleExports)) {
          return moduleExports;
        }
        return null;
      }
      /**
       * Validate if an object is a valid tool
       */
      isValidTool(obj) {
        return obj && typeof obj === "object" && typeof obj.id === "string" && typeof obj.description === "string" && typeof obj.execute === "function";
      }
      /**
       * Check if a file should be loaded as a tool
       */
      isToolFile(filename) {
        return this.options.extensions.some((ext) => filename.endsWith(ext));
      }
      /**
       * Check if a path exists
       */
      async exists(path7) {
        try {
          await fs4.access(path7);
          return true;
        } catch {
          return false;
        }
      }
      /**
       * Compute hash of a file
       */
      async computeFileHash(filePath2) {
        try {
          const content = await fs4.readFile(filePath2);
          return crypto2.createHash("sha256").update(content).digest("hex");
        } catch (error) {
          debug.error(`[ToolLoader] Failed to compute hash for ${filePath2}:`, error);
          return "";
        }
      }
      /**
       * Unload a tool and run cleanup
       */
      async unloadTool(toolId) {
        debug.log(`[ToolLoader] Unloading tool: ${toolId}`);
        const tool = this.registry.get(toolId);
        if (tool && tool.definition.cleanup) {
          try {
            const context = {
              registry: this.registry,
              workingDirectory: process.cwd()
            };
            await tool.definition.cleanup(context);
            debug.log(`[ToolLoader] Cleanup completed for ${toolId}`);
          } catch (error) {
            debug.error(`[ToolLoader] Cleanup failed for ${toolId}:`, error);
          }
        }
        await this.registry.unregister(toolId);
        this.loadedTools.delete(toolId);
      }
      /**
       * Reload all tools (for --watch-tools command)
       */
      async reloadAllTools() {
        debug.log("[ToolLoader] Reloading all tools...");
        const toolIds = Array.from(this.loadedTools.keys());
        for (const toolId of toolIds) {
          if (this.loadedTools.get(toolId)?.path.startsWith("builtin:")) {
            continue;
          }
          await this.unloadTool(toolId);
        }
        if (typeof __require !== "undefined" && __require.cache) {
          for (const [toolId, info] of this.loadedTools) {
            if (info.path && !info.path.startsWith("builtin:")) {
              delete __require.cache[info.path];
            }
          }
        }
        await this.loadTools();
        debug.log("[ToolLoader] Tool reload complete");
      }
      /**
       * Set up file watchers for hot reloading
       */
      async setupWatchers() {
        const { watch } = await import("fs");
        for (const dir of this.options.directories) {
          const toolsDir = path6.join(dir, dir.endsWith("tools") ? "" : "tools");
          if (!await this.exists(toolsDir)) continue;
          const watcher = watch(toolsDir, { recursive: true }, async (eventType, filename) => {
            if (!filename || !this.isToolFile(filename)) return;
            const filePath2 = path6.join(toolsDir, filename);
            try {
              const stats = await fs4.stat(filePath2);
              if (stats.isFile()) {
                debug.log(`[ToolLoader] Reloading ${filename}...`);
                await this.loadToolFile(filePath2);
              }
            } catch {
              const toolId = this.findToolByPath(filePath2);
              if (toolId) {
                await this.registry.unregister(toolId);
                this.loadedTools.delete(toolId);
                debug.log(`[ToolLoader] Unregistered ${toolId}`);
              }
            }
          });
          this.watcherCleanup.push(() => watcher.close());
        }
      }
      /**
       * Find tool ID by file path
       */
      findToolByPath(filePath2) {
        for (const [toolId, info] of this.loadedTools.entries()) {
          if (info.path === filePath2) return toolId;
        }
        return void 0;
      }
      /**
       * Get loaded tools info
       */
      getLoadedTools() {
        return Array.from(this.loadedTools.entries()).map(([toolId, info]) => ({
          toolId,
          filePath: info.path,
          hash: info.hash
        }));
      }
      /**
       * Reload all tools
       */
      async reloadTools() {
        debug.log("[ToolLoader] Reloading all tools...");
        const currentTools = new Map(this.loadedTools);
        this.loadedTools.clear();
        for (const [_, info] of currentTools) {
          if (!info.path.startsWith("builtin:")) {
            await this.loadToolFile(info.path);
          }
        }
      }
      /**
       * Clean up resources
       */
      async cleanup() {
        for (const cleanup of this.watcherCleanup) {
          cleanup();
        }
        this.watcherCleanup = [];
        this.loadedTools.clear();
      }
      /**
       * Load a module with shared dependencies from the main clanker package
       */
      loadWithSharedDependencies(requireFunc2, filePath2) {
        const Module = requireFunc2("module");
        const originalResolveFilename = Module._resolveFilename;
        Module._resolveFilename = function(request, parent, isMain) {
          if (shouldShareDependency(request)) {
            try {
              const mainModule = __require.main || module;
              return originalResolveFilename.call(this, request, mainModule, false);
            } catch (e) {
              try {
                return originalResolveFilename.call(this, request, module, false);
              } catch (e2) {
                debug.log(`[ToolLoader] Failed to resolve shared dependency ${request}`);
              }
            }
          }
          return originalResolveFilename.call(this, request, parent, isMain);
        };
        try {
          delete requireFunc2.cache[filePath2];
          const loadedModule2 = requireFunc2(filePath2);
          return loadedModule2;
        } finally {
          Module._resolveFilename = originalResolveFilename;
        }
      }
      /**
       * Create a tool template file
       */
      static async createToolTemplate(toolName, baseDir = process.cwd()) {
        const toolsDir = path6.join(baseDir, ".clank", "tools");
        await fs4.mkdir(toolsDir, { recursive: true });
        const fileName = `${toolName}.ts`;
        const filePath2 = path6.join(toolsDir, fileName);
        try {
          await fs4.access(filePath2);
          throw new Error(`Tool file already exists: ${filePath2}`);
        } catch (error) {
          if (error.code !== "ENOENT") throw error;
        }
        const template = `/**
 * ${toolName} tool
 * 
 * This is a template for creating a custom tool.
 * Edit this file to implement your tool's functionality.
 */

import { createTool, ToolCategory, ToolCapability } from '@ziggle/clanker';

// Using the builder API
export default createTool()
  .id('${toolName}')
  .name('${toolName.charAt(0).toUpperCase() + toolName.slice(1)} Tool')
  .description('Description of what this tool does')
  .category(ToolCategory.Utility)
  .capabilities(ToolCapability.FileRead)
  .tags('custom', 'example')
  
  // Define arguments
  .stringArg('input', 'Input value', { required: true })
  .booleanArg('verbose', 'Enable verbose output', { default: false })
  
  // Define the execution logic
  .execute(async (args, context) => {
    const { input, verbose } = args;
    
    if (verbose) {
      context.logger?.debug('Processing input:', input);
    }
    
    // Your tool logic here
    const result = \`Processed: \${input}\`;
    
    return {
      success: true,
      output: result,
      data: { processed: result }
    };
  })
  .build();
`;
        await fs4.writeFile(filePath2, template, "utf-8");
        debug.log(`Created tool template: ${filePath2}`);
      }
    };
  }
});

// src/registry/index.ts
var init_registry2 = __esm({
  "src/registry/index.ts"() {
    init_esm_shims();
    init_types();
    init_registry();
    init_builder();
    init_composition();
    init_adapters();
    init_validation();
    init_loader();
    init_logger();
  }
});

// src/exports.ts
init_esm_shims();
init_registry2();
export {
  CompositionBuilder,
  ConsoleLogger,
  NullLogger,
  ToolBuilder,
  ToolCapability,
  ToolCategory,
  ToolLoader2 as ToolLoader,
  ToolRegistryImpl,
  applyDefaults,
  coerceArguments,
  createComposedTool,
  createLegacyToolWrapper,
  createTool,
  createToolExecutor,
  createToolLoader,
  createToolLogger,
  createToolRegistry,
  formatValidationErrors,
  generateGrokTools,
  generateToolPromptSection,
  toolDefinitionToGrokTool,
  validateArguments,
  validators
};
//# sourceMappingURL=exports.js.map