{"version":3,"sources":["../node_modules/tsup/assets/esm_shims.js","../src/registry/types.ts","../src/registry/validation.ts","../src/registry/composition.ts","../src/utils/debug-logger.ts","../src/ui/stage/types.ts","../src/clanker/client.ts","../src/registry/retry-executor.ts","../src/utils/token-counter.ts","../src/clanker/agent.ts","../src/utils/settings-manager.ts","../src/store/store.ts","../src/store/index.ts","../src/utils/confirmation-service.ts","../src/registry/logger.ts","../src/registry/registry.ts","../src/registry/builder.ts","../src/registry/adapters.ts","../src/registry/builtin-tools.ts","../src/registry/manifest-loader.ts","../src/registry/loader.ts","../src/registry/index.ts","../src/exports.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","/**\n * Core types for the dynamic tool registry system\n */\n\nimport {ToolResult} from '../types';\nimport React from 'react';\n\n// ============================================================================\n// Core Tool Types\n// ============================================================================\n\n/**\n * Tool metadata for registration and discovery\n */\nexport interface ToolMetadata {\n    id: string;\n    name: string;\n    description: string;\n    version?: string;\n    author?: string;\n    tags?: string[];\n    category?: ToolCategory;\n    capabilities?: ToolCapability[];\n}\n\n/**\n * Tool categories for organization\n */\nexport enum ToolCategory {\n    FileSystem = 'filesystem',\n    System = 'system',\n    Search = 'search',\n    Development = 'development',\n    Task = 'task',\n    Utility = 'utility',\n    Composition = 'composition'\n}\n\n/**\n * Tool capabilities for permission checking\n */\nexport enum ToolCapability {\n    FileRead = 'file:read',\n    FileWrite = 'file:write',\n    SystemExecute = 'system:execute',\n    NetworkAccess = 'network:access',\n    UserConfirmation = 'user:confirmation'\n}\n\n// ============================================================================\n// Argument Specification\n// ============================================================================\n\n/**\n * Argument type definitions\n */\nexport type ArgumentType = 'string' | 'number' | 'boolean' | 'array' | 'object' | 'any';\n\n/**\n * Argument specification for tools\n */\nexport interface ArgumentSpec {\n    name: string;\n    type: ArgumentType;\n    description: string;\n    required?: boolean;\n    default?: string | number | boolean | unknown[] | Record<string, unknown>;\n    enum?: Array<string | number | boolean>;\n    validate?: (value: unknown) => boolean | string;\n}\n\n/**\n * Tool arguments definition\n */\nexport type ToolArguments = Record<string, unknown>;\n\n// ============================================================================\n// Tool Definition\n// ============================================================================\n\n/**\n * Tool execution context\n */\nexport interface ToolContext {\n    registry: ToolRegistry;\n    workingDirectory: string;\n    confirmationService?: unknown;\n    logger?: ToolLogger;\n    state?: Map<string, unknown>;\n}\n\n/**\n * Tool execution function\n */\nexport type ToolExecutor = (\n    args: ToolArguments,\n    context: ToolContext\n) => Promise<ToolResult>;\n\n/**\n * Tool result render function for custom UI display\n */\nexport type ToolResultRenderer = (args: {\n    toolName: string;\n    arguments: ToolArguments;\n    result?: ToolResult;\n    isExecuting: boolean;\n}) => React.ReactElement | null;\n\n/**\n * Complete tool definition\n */\nexport interface ToolDefinition extends ToolMetadata {\n    arguments?: ArgumentSpec[];\n    execute: ToolExecutor;\n\n    // Optional lifecycle hooks\n    initialize?: (context: ToolContext) => Promise<void>;\n    cleanup?: (context: ToolContext) => Promise<void>;\n\n    // Composition support\n    inputSchema?: Schema;\n    outputSchema?: Schema;\n    composable?: boolean;\n\n    // Optional custom renderer for chat history\n    renderResult?: ToolResultRenderer;\n\n    // Optional examples for better AI understanding\n    examples?: {\n        description: string;\n        arguments: ToolArguments;\n        result?: string;\n    }[];\n}\n\n/**\n * Registered tool instance\n */\nexport interface RegisteredTool {\n    definition: ToolDefinition;\n    initialized: boolean;\n    lastExecuted?: Date;\n    executionCount: number;\n    totalDuration: number; // Total execution time in milliseconds\n    hash?: string; // Hash of the tool file for version tracking\n    filePath?: string; // Path to the tool file\n}\n\n// ============================================================================\n// Composition Types\n// ============================================================================\n\n/**\n * Schema for type validation in compositions\n */\nexport interface Schema {\n    type: ArgumentType;\n    properties?: Record<string, Schema>;\n    items?: Schema;\n    required?: string[];\n}\n\n/**\n * Composition patterns\n */\nexport type CompositionPattern =\n    | 'pipeline'    // Sequential execution\n    | 'parallel'    // Concurrent execution\n    | 'conditional' // Branching based on conditions\n    | 'map'        // Apply to collection\n    | 'reduce';    // Aggregate results\n\n/**\n * Composed tool that can be registered\n */\nexport interface ComposedTool extends ToolDefinition {\n    pattern: CompositionPattern;\n    tools: string[]; // Tool IDs\n    config?: Record<string, unknown>;    // Pattern-specific configuration\n}\n\n// ============================================================================\n// Registry Interface\n// ============================================================================\n\n/**\n * Tool registry for managing tools\n */\nexport interface ToolRegistry {\n    // Registration\n    register(tool: ToolDefinition): void;\n\n    unregister(toolId: string): void;\n\n    // Discovery\n    get(toolId: string): RegisteredTool | undefined;\n\n    list(filter?: ToolFilter): ToolDefinition[];\n\n    search(query: string): ToolDefinition[];\n\n    // Execution\n    execute(toolId: string, args: ToolArguments): Promise<ToolResult>;\n\n    // Composition\n    compose(pattern: CompositionPattern, tools: string[], config?: Record<string, unknown>): ComposedTool;\n\n    // Validation\n    validateArguments(toolId: string, args: ToolArguments): ValidationResult;\n}\n\n/**\n * Tool filter options\n */\nexport interface ToolFilter {\n    category?: ToolCategory;\n    capabilities?: ToolCapability[];\n    tags?: string[];\n    composable?: boolean;\n}\n\n/**\n * Validation result\n */\nexport interface ValidationResult {\n    valid: boolean;\n    errors?: ValidationError[];\n}\n\n/**\n * Validation error\n */\nexport interface ValidationError {\n    field: string;\n    message: string;\n    expected?: unknown;\n    received?: unknown;\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Tool logger interface\n */\nexport interface ToolLogger {\n    debug(message: string, ...args: unknown[]): void;\n\n    info(message: string, ...args: unknown[]): void;\n\n    warn(message: string, ...args: unknown[]): void;\n\n    error(message: string, ...args: unknown[]): void;\n}\n\n/**\n * Extract argument types from tool definition\n */\nexport type ExtractToolArgs<T extends ToolDefinition> = T extends {\n        arguments: infer Args;\n    }\n    ? Args extends readonly ArgumentSpec[]\n        ? { [K in Args[number] as K['name']]: unknown }\n        : Record<string, unknown>\n    : Record<string, unknown>;\n\n","/**\n * Argument validation utilities\n */\n\nimport {\n    ArgumentSpec,\n    ToolArguments,\n    ValidationResult,\n    ValidationError,\n    ArgumentType\n} from './types';\n\n/**\n * Validate arguments against specifications\n */\nexport function validateArguments(\n    specs: ArgumentSpec[],\n    args: ToolArguments\n): ValidationResult {\n    const errors: ValidationError[] = [];\n\n    // Check required arguments\n    for (const spec of specs) {\n        const value = args[spec.name];\n\n        // Check required\n        if (spec.required && (value === undefined || value === null)) {\n            errors.push({\n                field: spec.name,\n                message: `Required argument '${spec.name}' is missing`,\n                expected: spec.type\n            });\n            continue;\n        }\n\n        // Skip validation if not provided and not required\n        if (value === undefined || value === null) {\n            continue;\n        }\n\n        // Check type\n        const typeError = validateType(value, spec.type, spec.name);\n        if (typeError) {\n            errors.push(typeError);\n            continue;\n        }\n\n        // Check enum values\n        if (spec.enum && !spec.enum.includes(value as string | number | boolean)) {\n            errors.push({\n                field: spec.name,\n                message: `Value must be one of: ${spec.enum.join(', ')}`,\n                expected: spec.enum,\n                received: value\n            });\n        }\n\n        // Run custom validation\n        if (spec.validate) {\n            const result = spec.validate(value);\n            if (typeof result === 'string') {\n                errors.push({\n                    field: spec.name,\n                    message: result,\n                    received: value\n                });\n            } else if (result === false) {\n                errors.push({\n                    field: spec.name,\n                    message: `Validation failed for '${spec.name}'`,\n                    received: value\n                });\n            }\n        }\n    }\n\n    // Check for unknown arguments\n    const knownArgs = new Set(specs.map(s => s.name));\n    for (const key of Object.keys(args)) {\n        if (!knownArgs.has(key)) {\n            errors.push({\n                field: key,\n                message: `Unknown argument '${key}'`\n            });\n        }\n    }\n\n    return {\n        valid: errors.length === 0,\n        errors: errors.length > 0 ? errors : undefined\n    };\n}\n\n/**\n * Validate value type\n */\nfunction validateType(value: unknown, expectedType: ArgumentType, fieldName: string): ValidationError | null {\n    const actualType = getActualType(value);\n\n    if (expectedType === 'any') {\n        return null;\n    }\n\n    if (actualType !== expectedType) {\n        // Special case: number type can accept numeric strings\n        if (expectedType === 'number' && actualType === 'string' && !isNaN(Number(value))) {\n            return null;\n        }\n\n        return {\n            field: fieldName,\n            message: `Expected ${expectedType} but got ${actualType}`,\n            expected: expectedType,\n            received: actualType\n        };\n    }\n\n    return null;\n}\n\n/**\n * Get the actual type of a value\n */\nfunction getActualType(value: unknown): ArgumentType {\n    if (value === null || value === undefined) {\n        return 'any';\n    }\n\n    if (Array.isArray(value)) {\n        return 'array';\n    }\n\n    const type = typeof value;\n\n    switch (type) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return type;\n        case 'object':\n            return 'object';\n        default:\n            return 'any';\n    }\n}\n\n/**\n * Apply default values to arguments\n */\nexport function applyDefaults(\n    specs: ArgumentSpec[],\n    args: ToolArguments\n): ToolArguments {\n    const result = {...args};\n\n    for (const spec of specs) {\n        if (spec.default !== undefined && result[spec.name] === undefined) {\n            result[spec.name] = spec.default;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Coerce argument types\n */\nexport function coerceArguments(\n    specs: ArgumentSpec[],\n    args: ToolArguments\n): ToolArguments {\n    const result = {...args};\n\n    for (const spec of specs) {\n        const value = result[spec.name];\n        if (value === undefined || value === null) {\n            continue;\n        }\n\n        result[spec.name] = coerceValue(value, spec.type);\n    }\n\n    return result;\n}\n\n/**\n * Coerce a value to the expected type\n */\nfunction coerceValue(value: unknown, targetType: ArgumentType): unknown {\n    const actualType = getActualType(value);\n\n    if (actualType === targetType || targetType === 'any') {\n        return value;\n    }\n\n    // String to number\n    if (targetType === 'number' && actualType === 'string') {\n        const num = Number(value);\n        return isNaN(num) ? value : num;\n    }\n\n    // String to boolean\n    if (targetType === 'boolean' && actualType === 'string') {\n        return value === 'true' || value === '1' || value === 'yes';\n    }\n\n    // String to array (split by comma)\n    if (targetType === 'array' && actualType === 'string') {\n        return (value as string).split(',').map((s: string) => s.trim());\n    }\n\n    // String to object (parse JSON)\n    if (targetType === 'object' && actualType === 'string') {\n        try {\n            return JSON.parse(value as string);\n        } catch {\n            return value;\n        }\n    }\n\n    return value;\n}\n\n/**\n * Format validation errors for display\n */\nexport function formatValidationErrors(errors: ValidationError[]): string {\n    return errors.map(error => {\n        let message = `• ${error.message}`;\n        if (error.expected && error.received) {\n            message += ` (expected: ${JSON.stringify(error.expected)}, received: ${JSON.stringify(error.received)})`;\n        }\n        return message;\n    }).join('\\n');\n}\n\n/**\n * Create a validation function for common patterns\n */\nexport const validators = {\n    /**\n     * String validators\n     */\n    minLength: (min: number) => (value: string) =>\n        value.length >= min || `Must be at least ${min} characters`,\n\n    maxLength: (max: number) => (value: string) =>\n        value.length <= max || `Must be at most ${max} characters`,\n\n    pattern: (regex: RegExp) => (value: string) =>\n        regex.test(value) || `Does not match required pattern`,\n\n    email: () => (value: string) =>\n        /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) || 'Must be a valid email address',\n\n    url: () => (value: string) => {\n        try {\n            new URL(value);\n            return true;\n        } catch {\n            return 'Must be a valid URL';\n        }\n    },\n\n    /**\n     * Number validators\n     */\n    min: (min: number) => (value: number) =>\n        value >= min || `Must be at least ${min}`,\n\n    max: (max: number) => (value: number) =>\n        value <= max || `Must be at most ${max}`,\n\n    integer: () => (value: number) =>\n        Number.isInteger(value) || 'Must be an integer',\n\n    positive: () => (value: number) =>\n        value > 0 || 'Must be positive',\n\n    /**\n     * Array validators\n     */\n    minItems: (min: number) => (value: unknown[]) =>\n        value.length >= min || `Must have at least ${min} items`,\n\n    maxItems: (max: number) => (value: unknown[]) =>\n        value.length <= max || `Must have at most ${max} items`,\n\n    unique: () => (value: unknown[]) =>\n        new Set(value).size === value.length || 'Items must be unique',\n\n    /**\n     * Combine multiple validators\n     */\n    combine: (...validators: Array<(value: unknown) => boolean | string>) =>\n        (value: unknown) => {\n            for (const validator of validators) {\n                const result = validator(value);\n                if (result !== true) {\n                    return result;\n                }\n            }\n            return true;\n        }\n};","/**\n * Tool composition patterns\n */\n\nimport {\n    ToolDefinition,\n    ComposedTool,\n    CompositionPattern,\n    ToolArguments,\n    ToolContext,\n    ToolCategory\n} from './types';\nimport {ToolResult} from '../types';\n\n/**\n * Create a composed tool based on pattern\n */\nexport function createComposedTool(\n    pattern: CompositionPattern,\n    tools: ToolDefinition[],\n    config?: Record<string, unknown>\n): ComposedTool {\n    const toolIds = tools.map(t => t.id);\n    const name = `${pattern}_${toolIds.join('_')}`;\n    const description = `${pattern} composition of: ${toolIds.join(', ')}`;\n\n    let executor: (args: ToolArguments, context: ToolContext) => Promise<ToolResult>;\n\n    switch (pattern) {\n        case 'pipeline':\n            executor = createPipelineExecutor(tools);\n            break;\n        case 'parallel':\n            executor = createParallelExecutor(tools);\n            break;\n        case 'conditional':\n            executor = createConditionalExecutor(tools, config);\n            break;\n        case 'map':\n            executor = createMapExecutor(tools[0], config);\n            break;\n        case 'reduce':\n            executor = createReduceExecutor(tools[0], config);\n            break;\n        default:\n            throw new Error(`Unknown composition pattern: ${pattern}`);\n    }\n\n    const composedTool: ComposedTool = {\n        id: name,\n        name,\n        description,\n        category: ToolCategory.Composition,\n        composable: true,\n        pattern,\n        tools: toolIds,\n        config,\n        execute: executor,\n\n        // Inherit capabilities from all tools\n        capabilities: Array.from(new Set(\n            tools.flatMap(t => t.capabilities || [])\n        ))\n    };\n\n    return composedTool;\n}\n\n/**\n * Pipeline executor - sequential execution with output chaining\n */\nfunction createPipelineExecutor(tools: ToolDefinition[]) {\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        let currentInput = args;\n        let lastResult: ToolResult | null = null;\n\n        for (const tool of tools) {\n            const result = await context.registry.execute(tool.id, currentInput);\n\n            if (!result.success) {\n                return result;\n            }\n\n            // Chain output to next tool's input\n            currentInput = (result.data || result.output || {}) as ToolArguments;\n            lastResult = result;\n        }\n\n        return lastResult || {success: true};\n    };\n}\n\n/**\n * Parallel executor - concurrent execution\n */\nfunction createParallelExecutor(tools: ToolDefinition[]) {\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        const promises = tools.map(tool =>\n            context.registry.execute(tool.id, args)\n        );\n\n        const results = await Promise.all(promises);\n\n        // Check if all succeeded\n        const failures = results.filter(r => !r.success);\n        if (failures.length > 0) {\n            return {\n                success: false,\n                error: `${failures.length} tools failed: ${failures.map(f => f.error).join(', ')}`\n            };\n        }\n\n        // Return all results\n        return {\n            success: true,\n            data: results.map(r => r.data || r.output)\n        };\n    };\n}\n\n/**\n * Conditional executor - branching based on condition\n */\nfunction createConditionalExecutor(tools: ToolDefinition[], config: Record<string, unknown>) {\n    const {condition, branches} = config;\n\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        // Evaluate condition\n        let branchKey: string;\n\n        if (typeof condition === 'function') {\n            branchKey = await condition(args, context);\n        } else {\n            branchKey = args[condition as string] ? 'true' : 'false';\n        }\n\n        // Find tool for branch\n        const toolIndex = branches[branchKey];\n        if (toolIndex === undefined || toolIndex >= tools.length) {\n            return {\n                success: false,\n                error: `No tool defined for branch: ${branchKey}`\n            };\n        }\n\n        const tool = tools[toolIndex];\n        return context.registry.execute(tool.id, args);\n    };\n}\n\n/**\n * Map executor - apply tool to each item in collection\n */\nfunction createMapExecutor(tool: ToolDefinition, config: Record<string, unknown> = {}) {\n    const concurrency = (config.concurrency as number) || 1;\n    const continueOnError = (config.continueOnError as boolean) || false;\n\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        const {items, ...otherArgs} = args;\n\n        if (!Array.isArray(items)) {\n            return {\n                success: false,\n                error: 'Map requires \"items\" array in arguments'\n            };\n        }\n\n        const results: unknown[] = [];\n        const errors: Array<{ item: unknown; error: string | undefined }> = [];\n\n        if (concurrency === 1) {\n            // Sequential processing\n            for (const item of items) {\n                const itemArgs = {...otherArgs, item};\n                const result = await context.registry.execute(tool.id, itemArgs);\n\n                if (!result.success) {\n                    if (!continueOnError) {\n                        return result;\n                    }\n                    errors.push({item, error: result.error});\n                } else {\n                    results.push(result.data || result.output);\n                }\n            }\n        } else {\n            // Parallel processing with concurrency limit\n            const chunks: unknown[][] = [];\n            for (let i = 0; i < items.length; i += concurrency) {\n                chunks.push(items.slice(i, i + concurrency));\n            }\n\n            for (const chunk of chunks) {\n                const promises = chunk.map(item => {\n                    const itemArgs = {...otherArgs, item};\n                    return context.registry.execute(tool.id, itemArgs);\n                });\n\n                const chunkResults = await Promise.all(promises);\n\n                chunkResults.forEach((result, index) => {\n                    if (!result.success) {\n                        if (!continueOnError) {\n                            return result;\n                        }\n                        errors.push({item: chunk[index], error: result.error});\n                    } else {\n                        results.push(result.data || result.output);\n                    }\n                });\n            }\n        }\n\n        return {\n            success: errors.length === 0 || continueOnError,\n            data: results,\n            error: errors.length > 0 ? `${errors.length} items failed` : undefined\n        };\n    };\n}\n\n/**\n * Reduce executor - aggregate results\n */\nfunction createReduceExecutor(tool: ToolDefinition, config: Record<string, unknown>) {\n    const {reducer, initialValue} = config;\n\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        const {items, ...otherArgs} = args;\n\n        if (!Array.isArray(items)) {\n            return {\n                success: false,\n                error: 'Reduce requires \"items\" array in arguments'\n            };\n        }\n\n        let accumulator = initialValue;\n\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            const itemArgs = {...otherArgs, item, accumulator, index: i};\n\n            const result = await context.registry.execute(tool.id, itemArgs);\n\n            if (!result.success) {\n                return result;\n            }\n\n            // Apply reducer\n            if (typeof reducer === 'function') {\n                accumulator = await reducer(accumulator, result.data || result.output, i);\n            } else {\n                accumulator = result.data || result.output;\n            }\n        }\n\n        return {\n            success: true,\n            data: accumulator\n        };\n    };\n}\n\n/**\n * Composition builder with fluent API\n */\nexport class CompositionBuilder {\n    private registry: { get(id: string): { definition: ToolDefinition } | undefined };\n\n    constructor(registry: { get(id: string): { definition: ToolDefinition } | undefined }) {\n        this.registry = registry;\n    }\n\n    /**\n     * Create a pipeline composition\n     */\n    pipeline(...toolIds: string[]): ComposedTool {\n        const tools = toolIds.map(id => {\n            const tool = this.registry.get(id);\n            if (!tool) throw new Error(`Tool '${id}' not found`);\n            return tool.definition;\n        });\n\n        return createComposedTool('pipeline', tools);\n    }\n\n    /**\n     * Create a parallel composition\n     */\n    parallel(...toolIds: string[]): ComposedTool {\n        const tools = toolIds.map(id => {\n            const tool = this.registry.get(id);\n            if (!tool) throw new Error(`Tool '${id}' not found`);\n            return tool.definition;\n        });\n\n        return createComposedTool('parallel', tools);\n    }\n\n    /**\n     * Create a conditional composition\n     */\n    conditional(\n        condition: string | ((args: ToolArguments, context: ToolContext) => string | Promise<string>),\n        branches: Record<string, string>\n    ): ComposedTool {\n        const branchTools: ToolDefinition[] = [];\n        const branchMap: Record<string, number> = {};\n\n        Object.entries(branches).forEach(([key, toolId], index) => {\n            const tool = this.registry.get(toolId);\n            if (!tool) throw new Error(`Tool '${toolId}' not found`);\n            branchTools.push(tool.definition);\n            branchMap[key] = index;\n        });\n\n        return createComposedTool('conditional', branchTools, {\n            condition,\n            branches: branchMap\n        });\n    }\n\n    /**\n     * Create a map composition\n     */\n    map(toolId: string, options?: { concurrency?: number; continueOnError?: boolean }): ComposedTool {\n        const tool = this.registry.get(toolId);\n        if (!tool) throw new Error(`Tool '${toolId}' not found`);\n\n        return createComposedTool('map', [tool.definition], options);\n    }\n\n    /**\n     * Create a reduce composition\n     */\n    reduce(\n        toolId: string,\n        reducer: (acc: unknown, value: unknown, index: number) => unknown,\n        initialValue?: unknown\n    ): ComposedTool {\n        const tool = this.registry.get(toolId);\n        if (!tool) throw new Error(`Tool '${toolId}' not found`);\n\n        return createComposedTool('reduce', [tool.definition], {\n            reducer,\n            initialValue\n        });\n    }\n}","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\n\nlet debugEnabled = false;\nlet logToFile = false;\nlet logStream: fs.WriteStream | null = null;\nlet logFilePath: string | null = null;\n\nexport function setDebugMode(enabled: boolean, fileLogging = false): void {\n  debugEnabled = enabled;\n  logToFile = fileLogging && enabled;\n  \n  if (logToFile && !logStream) {\n    initializeFileLogging();\n  } else if (!logToFile && logStream) {\n    closeFileLogging();\n  }\n}\n\nfunction initializeFileLogging(): void {\n  try {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const logDir = path.join(os.homedir(), '.clanker', 'debug', 'logs');\n    \n    // Create directory if it doesn't exist\n    fs.mkdirSync(logDir, { recursive: true });\n    \n    logFilePath = path.join(logDir, `debug_${timestamp}.log`);\n    logStream = fs.createWriteStream(logFilePath, { flags: 'a' });\n    \n    logToStream(`=== Debug log started at ${new Date().toISOString()} ===\\n`);\n    logToStream(`Log file: ${logFilePath}\\n`);\n    logToStream(`Process: ${process.argv.join(' ')}\\n`);\n    logToStream(`Working directory: ${process.cwd()}\\n`);\n    logToStream(`===========================================\\n\\n`);\n    \n    console.log(`[DEBUG] Logging to file: ${logFilePath}`);\n  } catch (error) {\n    console.error('[DEBUG] Failed to initialize file logging:', error);\n    logToFile = false;\n  }\n}\n\nfunction closeFileLogging(): void {\n  if (logStream) {\n    logToStream(`\\n=== Debug log ended at ${new Date().toISOString()} ===\\n`);\n    logStream.end();\n    logStream = null;\n  }\n}\n\nfunction logToStream(message: string): void {\n  if (logStream) {\n    logStream.write(message);\n  }\n}\n\nfunction formatArgs(args: any[]): string {\n  return args.map(arg => {\n    if (typeof arg === 'object') {\n      try {\n        return JSON.stringify(arg, null, 2);\n      } catch {\n        return String(arg);\n      }\n    }\n    return String(arg);\n  }).join(' ');\n}\n\nexport function isDebugMode(): boolean {\n  return debugEnabled;\n}\n\nexport function getLogFilePath(): string | null {\n  return logFilePath;\n}\n\nexport const debug = {\n  log: (...args: any[]) => {\n    if (debugEnabled) {\n      const timestamp = new Date().toISOString();\n      const message = formatArgs(args);\n      \n      console.log('[DEBUG]', ...args);\n      \n      if (logToFile && logStream) {\n        logToStream(`[${timestamp}] [LOG] ${message}\\n`);\n      }\n    }\n  },\n  error: (...args: any[]) => {\n    if (debugEnabled) {\n      const timestamp = new Date().toISOString();\n      const message = formatArgs(args);\n      \n      console.error('[DEBUG ERROR]', ...args);\n      \n      if (logToFile && logStream) {\n        logToStream(`[${timestamp}] [ERROR] ${message}\\n`);\n      }\n    }\n  },\n  warn: (...args: any[]) => {\n    if (debugEnabled) {\n      const timestamp = new Date().toISOString();\n      const message = formatArgs(args);\n      \n      console.warn('[DEBUG WARN]', ...args);\n      \n      if (logToFile && logStream) {\n        logToStream(`[${timestamp}] [WARN] ${message}\\n`);\n      }\n    }\n  },\n  info: (...args: any[]) => {\n    if (debugEnabled) {\n      const timestamp = new Date().toISOString();\n      const message = formatArgs(args);\n      \n      console.info('[DEBUG INFO]', ...args);\n      \n      if (logToFile && logStream) {\n        logToStream(`[${timestamp}] [INFO] ${message}\\n`);\n      }\n    }\n  }\n};\n\n// Ensure log is closed on process exit\nprocess.on('exit', closeFileLogging);\nprocess.on('SIGINT', () => {\n  closeFileLogging();\n  process.exit();\n});\nprocess.on('SIGTERM', () => {\n  closeFileLogging();\n  process.exit();\n});","export interface Stage {\n    id: string;\n    type: StageType;\n    props?: any;\n}\n\nexport enum StageType {\n    CHAT = 'chat',\n    COMMAND_PALETTE = 'command_palette',\n    SETTINGS = 'settings',\n    HELP = 'help',\n    MODAL = 'modal',\n    EXIT_CONFIRMATION = 'exit_confirmation',\n    TOOL_CONFIRMATION = 'tool_confirmation'\n}\n\nexport interface StageManager {\n    getCurrentStage(): Stage;\n    pushStage(stage: Stage): void;\n    popStage(): void;\n    replaceStage(stage: Stage): void;\n    clearStages(): void;\n    getStageStack(): Stage[];\n}\n\nexport interface ModalOptions {\n    title: string;\n    message?: string;\n    options: ModalOption[];\n}\n\nexport interface ModalOption {\n    label: string;\n    value: string;\n    variant?: 'primary' | 'secondary' | 'danger';\n}\n\nexport interface ModalResult {\n    selected: string;\n    cancelled: boolean;\n}","import OpenAI from \"openai\";\nimport type {ChatCompletionMessageParam, ChatCompletionChunk} from \"openai/resources/chat\";\n\nexport type GrokMessage = ChatCompletionMessageParam;\n\nexport interface GrokTool {\n    type: \"function\";\n    function: {\n        name: string;\n        description: string;\n        parameters: {\n            type: \"object\";\n            properties: Record<string, unknown>;\n            required: string[];\n        };\n    };\n}\n\nexport interface GrokToolCall {\n    id: string;\n    type: \"function\";\n    function: {\n        name: string;\n        arguments: string;\n    };\n}\n\nexport interface SearchParameters {\n    mode?: \"auto\" | \"on\" | \"off\";\n    // sources removed - let API use default sources to avoid format issues\n}\n\nexport interface SearchOptions {\n    search_parameters?: SearchParameters;\n}\n\nexport interface GrokResponse {\n    choices: Array<{\n        message: {\n            role: string;\n            content: string | null;\n            tool_calls?: GrokToolCall[];\n        };\n        finish_reason: string;\n    }>;\n}\n\nexport class GrokClient {\n    private client: OpenAI;\n    private currentModel: string = \"grok-3-latest\";\n\n    constructor(apiKey: string, model?: string, baseURL?: string) {\n        this.client = new OpenAI({\n            apiKey,\n            baseURL: baseURL || process.env.GROK_BASE_URL || \"https://api.x.ai/v1\",\n            timeout: 360000,\n        });\n        if (model) {\n            this.currentModel = model;\n        }\n    }\n\n    setModel(model: string): void {\n        this.currentModel = model;\n    }\n\n    getCurrentModel(): string {\n        return this.currentModel;\n    }\n\n    async chat(\n        messages: GrokMessage[],\n        tools?: GrokTool[],\n        model?: string,\n        searchOptions?: SearchOptions\n    ): Promise<GrokResponse> {\n        try {\n            const requestPayload: Record<string, unknown> = {\n                model: model || this.currentModel,\n                messages: messages as unknown[],\n                temperature: 0.7,\n                max_tokens: 4000,\n            };\n\n            if (tools && tools.length > 0) {\n                requestPayload.tools = tools;\n                requestPayload.tool_choice = \"auto\" as const;\n            }\n\n            // Add search parameters if specified\n            if (searchOptions?.search_parameters) {\n                (requestPayload as { search_parameters?: unknown }).search_parameters = searchOptions.search_parameters;\n            }\n\n            const response = await this.client.chat.completions.create(\n                requestPayload as unknown as Parameters<typeof this.client.chat.completions.create>[0]\n            );\n\n            return response as GrokResponse;\n        } catch (error) {\n            throw new Error(`Grok API error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n\n    async* chatStream(\n        messages: GrokMessage[],\n        tools?: GrokTool[],\n        model?: string,\n        searchOptions?: SearchOptions\n    ): AsyncGenerator<ChatCompletionChunk, void, unknown> {\n        try {\n            const requestPayload: Record<string, unknown> = {\n                model: model || this.currentModel,\n                messages: messages as unknown[],\n                temperature: 0.7,\n                max_tokens: 4000,\n                stream: true as const,\n            };\n\n            if (tools && tools.length > 0) {\n                requestPayload.tools = tools;\n                requestPayload.tool_choice = \"auto\" as const;\n            }\n\n            // Add search parameters if specified\n            if (searchOptions?.search_parameters) {\n                (requestPayload as { search_parameters?: unknown }).search_parameters = searchOptions.search_parameters;\n            }\n\n            // Log timing for debugging\n            const stream = await this.client.chat.completions.create(\n                requestPayload as unknown as Parameters<typeof this.client.chat.completions.create>[0]\n            );\n\n            let firstChunk = true;\n\n            for await (const chunk of stream as AsyncIterable<ChatCompletionChunk>) {\n                if (firstChunk) {\n                    firstChunk = false;\n                }\n                yield chunk;\n            }\n        } catch (error) {\n            throw new Error(`Grok API error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n\n    async search(\n        query: string,\n        searchParameters?: SearchParameters\n    ): Promise<GrokResponse> {\n        const searchMessage: GrokMessage = {\n            role: \"user\",\n            content: query,\n        };\n\n        const searchOptions: SearchOptions = {\n            search_parameters: searchParameters || {mode: \"on\"},\n        };\n\n        return this.chat([searchMessage], [], undefined, searchOptions);\n    }\n}\n","/**\n * Enhanced tool executor with retry logic and intelligent error correction\n */\n\nimport {ToolRegistry, ToolArguments} from './types';\nimport {ToolResult} from '../types';\nimport {debug} from '../utils/debug-logger';\n\ninterface RetryContext {\n    toolName: string;\n    originalArgs: ToolArguments;\n    attempt: number;\n    previousErrors: Array<{\n        error: string;\n        args: ToolArguments;\n    }>;\n}\n\n/**\n * Analyze error and suggest argument corrections\n */\nfunction analyzeErrorAndSuggestFix(error: string, args: ToolArguments, toolName: string): ToolArguments | null {\n    const errorLower = error.toLowerCase();\n\n    // Handle quoting issues in bash/input commands\n    if ((toolName === 'bash' || toolName === 'input') &&\n        (errorLower.includes('unexpected eof') || errorLower.includes('matching'))) {\n        // Try to fix quoting issues\n        if (args.command && typeof args.command === 'string') {\n            // Escape single quotes properly\n            const fixed = args.command.replace(/'/g, \"'\\\"'\\\"'\");\n            return {...args, command: fixed};\n        }\n        if (args.prompt && typeof args.prompt === 'string') {\n            // For input tool, escape quotes\n            const fixed = args.prompt.replace(/\"/g, '\\\\\"').replace(/'/g, \"\\\\'\");\n            return {...args, prompt: fixed};\n        }\n    }\n\n    // Handle file not found errors\n    if (errorLower.includes('no such file') || errorLower.includes('not found') ||\n        errorLower.includes('does not exist')) {\n        // For file operations, try different path variations\n        if (args.path || args.file_path) {\n            const originalPath = (args.path || args.file_path) as string;\n\n            // Try without leading ./\n            if (originalPath.startsWith('./')) {\n                return {...args, path: originalPath.substring(2), file_path: originalPath.substring(2)};\n            }\n\n            // Try with ./ prefix\n            if (!originalPath.startsWith('/') && !originalPath.startsWith('./')) {\n                return {...args, path: './' + originalPath, file_path: './' + originalPath};\n            }\n\n            // Try with different extensions\n            if (toolName === 'search' && args.query) {\n                // If searching for a file, try different patterns\n                const query = args.query as string;\n                if (!query.includes('*')) {\n                    return {...args, query: `*${query}*`};\n                }\n            }\n        }\n    }\n\n    // Handle permission errors\n    if (errorLower.includes('permission denied') || errorLower.includes('access denied')) {\n        // For bash commands, try with sudo (but be careful)\n        if (toolName === 'bash' && args.command && typeof args.command === 'string') {\n            const cmd = args.command as string;\n            if (!cmd.startsWith('sudo ')) {\n                debug.warn('[RetryExecutor] Permission denied, but NOT auto-adding sudo for safety');\n                // Don't auto-add sudo, but suggest it in the error\n                return null;\n            }\n        }\n    }\n\n    // Handle argument type errors\n    if (errorLower.includes('invalid argument') || errorLower.includes('type error')) {\n        // Try to coerce types\n        const newArgs = {...args};\n        for (const [key, value] of Object.entries(newArgs)) {\n            if (typeof value === 'string' && value.match(/^\\d+$/)) {\n                // Try converting string numbers to actual numbers\n                newArgs[key] = parseInt(value, 10);\n            }\n        }\n        return newArgs;\n    }\n\n    return null;\n}\n\n/**\n * Generate fallback suggestions after max retries\n */\nfunction generateFallbackSuggestions(context: RetryContext): string {\n    const {toolName, originalArgs, previousErrors} = context;\n    const suggestions: string[] = [];\n\n    // Analyze the pattern of errors\n    const lastError = previousErrors[previousErrors.length - 1]?.error || '';\n\n    const preamble = `After ${context.attempt} attempts, the last error was: \"${lastError}, the original arguments were: ${JSON.stringify(originalArgs)}\"`\n\n    if (toolName === 'search') {\n        suggestions.push(\n            'Try using the list tool to explore the directory structure',\n            'Use the bash tool with \"find . -name \\'*pattern*\\'\" for a broader search',\n            'Check if the file has a different extension (e.g., .txt instead of .md)'\n        );\n    } else if (toolName === 'read_file' || toolName === 'view_file') {\n        suggestions.push(\n            'Use the list tool to verify the file exists in the expected location',\n            'Try the pwd tool to confirm the current working directory',\n            'Use bash with \"ls -la\" to see all files including hidden ones'\n        );\n    } else if (toolName === 'bash') {\n        if (lastError.includes('command not found')) {\n            suggestions.push(\n                'Check if the command is installed with \"which <command>\"',\n                'Try using the full path to the command',\n                'Consider using an alternative command'\n            );\n        } else if (lastError.includes('permission')) {\n            suggestions.push(\n                'The command may require elevated permissions',\n                'Try a different approach that doesn\\'t require special permissions',\n                'Check file ownership and permissions with \"ls -la\"'\n            );\n        }\n    } else if (toolName === 'input') {\n        suggestions.push(\n            'The input dialog may not be supported in this environment',\n            'Consider asking the user to provide the information directly in their message',\n            'Try a simpler prompt without special characters'\n        );\n    }\n\n    // General suggestions\n    suggestions.push(\n        'Review the error messages for clues about what went wrong',\n        'Consider breaking down the task into smaller steps',\n        'Ask the user for clarification or additional information'\n    );\n\n    return `${preamble}. Consider these alternative approaches:\\n${suggestions.map(s => `- ${s}`).join('\\n')}`;\n}\n\n/**\n * Create an enhanced tool executor with retry logic\n */\nexport function createRetryToolExecutor(registry: ToolRegistry) {\n    return async (toolName: string, args: ToolArguments, maxRetries: number = 5): Promise<ToolResult> => {\n        const context: RetryContext = {\n            toolName,\n            originalArgs: args,\n            attempt: 0,\n            previousErrors: []\n        };\n\n        let currentArgs = args;\n\n        while (context.attempt < maxRetries) {\n            context.attempt++;\n            debug.log(`[RetryExecutor] Attempt ${context.attempt} for ${toolName}`);\n\n            try {\n                const result = await registry.execute(toolName, currentArgs);\n\n                if (result.success) {\n                    if (context.attempt > 1) {\n                        debug.log(`[RetryExecutor] Succeeded on attempt ${context.attempt}`);\n                    }\n                    return result;\n                }\n\n                // Tool executed but returned an error\n                const error = result.error || 'Unknown error';\n                context.previousErrors.push({error, args: currentArgs});\n\n                debug.warn(`[RetryExecutor] Tool ${toolName} failed: ${error}`);\n\n                // Try to fix the error\n                const fixedArgs = analyzeErrorAndSuggestFix(error, currentArgs, toolName);\n\n                if (fixedArgs && context.attempt < maxRetries) {\n                    debug.log(`[RetryExecutor] Attempting to fix error with modified arguments`);\n                    currentArgs = fixedArgs;\n                    continue;\n                }\n\n                // Can't fix automatically, but still have retries\n                if (context.attempt < maxRetries) {\n                    debug.log(`[RetryExecutor] No automatic fix available, retrying with original args`);\n                    currentArgs = args;\n                    continue;\n                }\n\n                // Max retries reached\n                const fallbackMsg = generateFallbackSuggestions(context);\n                return {\n                    success: false,\n                    error: `${error}\\n\\n${fallbackMsg}`,\n                    data: {\n                        attempts: context.attempt,\n                        errors: context.previousErrors\n                    }\n                };\n\n            } catch (error) {\n                // Unexpected error during execution\n                const errorMsg = error instanceof Error ? error.message : String(error);\n                context.previousErrors.push({error: errorMsg, args: currentArgs});\n\n                debug.error(`[RetryExecutor] Unexpected error: ${errorMsg}`);\n\n                if (context.attempt >= maxRetries) {\n                    const fallbackMsg = generateFallbackSuggestions(context);\n                    return {\n                        success: false,\n                        error: `Execution failed: ${errorMsg}\\n\\n${fallbackMsg}`,\n                        data: {\n                            attempts: context.attempt,\n                            errors: context.previousErrors\n                        }\n                    };\n                }\n            }\n        }\n\n        // Should not reach here, but just in case\n        return {\n            success: false,\n            error: 'Max retries exceeded',\n            data: {\n                attempts: context.attempt,\n                errors: context.previousErrors\n            }\n        };\n    };\n}\n\n/**\n * Try to fix malformed JSON\n */\nfunction tryFixJson(jsonString: string): string | null {\n    // Remove trailing non-JSON characters after the last }\n    let cleaned = jsonString.replace(/\\}[^}]*$/, '}');\n    \n    // Try to extract JSON object from string\n    const jsonMatch = cleaned.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n        return jsonMatch[0];\n    }\n    \n    // If it's just whitespace, return empty object\n    if (!cleaned.trim()) {\n        return '{}';\n    }\n    \n    return null;\n}\n\n/**\n * Wrapper for the standard createToolExecutor that adds retry logic\n */\nexport function createToolExecutorWithRetry(registry: ToolRegistry) {\n    const retryExecutor = createRetryToolExecutor(registry);\n\n    return async (toolName: string, args: unknown): Promise<ToolResult> => {\n        // Parse arguments if they come as a string\n        let parsedArgs = args;\n        if (typeof args === 'string') {\n            try {\n                parsedArgs = JSON.parse(args);\n            } catch (error) {\n                // Try to fix common JSON errors\n                const fixed = tryFixJson(args as string);\n                if (fixed) {\n                    try {\n                        parsedArgs = JSON.parse(fixed);\n                    } catch {\n                        // If still fails, check if tool accepts no arguments\n                        const tool = registry.get(toolName);\n                        if (tool && (!tool.definition.arguments || tool.definition.arguments.length === 0)) {\n                            parsedArgs = {};\n                        } else {\n                            parsedArgs = {input: args};\n                        }\n                    }\n                } else {\n                    parsedArgs = {input: args};\n                }\n            }\n        }\n\n        // Use retry executor with default 5 retries\n        return retryExecutor(toolName, parsedArgs as ToolArguments, 5);\n    };\n}","import { get_encoding, encoding_for_model, Tiktoken, TiktokenModel } from 'tiktoken';\n\nexport class TokenCounter {\n  private encoder: Tiktoken;\n\n  constructor(model: string = 'gpt-4') {\n    try {\n      // Try to get encoding for specific model\n      this.encoder = encoding_for_model(model as TiktokenModel);\n    } catch {\n      // Fallback to cl100k_base (used by GPT-4 and most modern models)\n      this.encoder = get_encoding('cl100k_base');\n    }\n  }\n\n  /**\n   * Count tokens in a string\n   */\n  countTokens(text: string): number {\n    if (!text) return 0;\n    return this.encoder.encode(text).length;\n  }\n\n  /**\n   * Count tokens in messages array (for chat completions)\n   */\n  countMessageTokens(messages: Array<{ role: string; content: string | null; tool_calls?: unknown; [key: string]: unknown }>): number {\n    let totalTokens = 0;\n    \n    for (const message of messages) {\n      // Every message follows <|start|>{role/name}\\n{content}<|end|\\>\\n\n      totalTokens += 3; // Base tokens per message\n      \n      if (message.content && typeof message.content === 'string') {\n        totalTokens += this.countTokens(message.content);\n      }\n      \n      if (message.role) {\n        totalTokens += this.countTokens(message.role);\n      }\n      \n      // Add extra tokens for tool calls if present\n      if (message.tool_calls) {\n        totalTokens += this.countTokens(JSON.stringify(message.tool_calls));\n      }\n    }\n    \n    totalTokens += 3; // Every reply is primed with <|start|>assistant<|message|>\n    \n    return totalTokens;\n  }\n\n  /**\n   * Estimate tokens for streaming content\n   * This is an approximation since we don't have the full response yet\n   */\n  estimateStreamingTokens(accumulatedContent: string): number {\n    return this.countTokens(accumulatedContent);\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose(): void {\n    this.encoder.free();\n  }\n}\n\n/**\n * Format token count for display (e.g., 1.2k for 1200)\n */\nexport function formatTokenCount(count: number): string {\n  if (count <= 999) {\n    return count.toString();\n  }\n  \n  if (count < 1_000_000) {\n    const k = count / 1000;\n    return k % 1 === 0 ? `${k}k` : `${k.toFixed(1)}k`;\n  }\n  \n  const m = count / 1_000_000;\n  return m % 1 === 0 ? `${m}m` : `${m.toFixed(1)}m`;\n}\n\n/**\n * Create a token counter instance\n */\nexport function createTokenCounter(model?: string): TokenCounter {\n  return new TokenCounter(model);\n}","/**\n * GrokAgent implementation with dynamic tool registry\n */\n\nimport {GrokClient, GrokTool, GrokMessage, GrokToolCall} from './client';\nimport {ToolResult} from '../types';\nimport {\n    ToolRegistry,\n    createToolRegistry,\n    ToolLoader,\n    createToolLoader,\n    generateGrokTools\n} from '../registry';\nimport { createToolExecutorWithRetry } from '../registry/retry-executor';\nimport {EventEmitter} from 'events';\nimport {TokenCounter, createTokenCounter} from '../utils/token-counter';\nimport {debug} from '../utils/debug-logger';\nimport * as path from 'path';\n\n\ninterface GrokAgentOptions {\n    apiKey: string;\n    baseURL?: string;\n    model?: string;\n    maxToolRounds?: number;\n    systemPrompt?: string;\n    loadDynamicTools?: boolean;\n    dynamicToolsPath?: string;\n    watchTools?: boolean;\n}\n\nexport interface StreamingChunk {\n    type: 'content' | 'tool_calls' | 'tool_result' | 'done' | 'token_count';\n    content?: string;\n    toolCalls?: GrokToolCall[];\n    toolCall?: GrokToolCall;\n    toolResult?: ToolResult;\n    tokenCount?: number;\n}\n\nexport class GrokAgent extends EventEmitter {\n    private client: GrokClient;\n    private model: string;\n    private maxToolRounds: number;\n    private registry: ToolRegistry;\n    private toolLoader?: ToolLoader;\n    private executeToolWithRegistry: (name: string, args: Record<string, unknown>) => Promise<ToolResult>;\n    private tokenCounter: TokenCounter;\n\n    constructor(options: GrokAgentOptions) {\n        super();\n        this.client = new GrokClient(\n            options.apiKey,\n            options.model,\n            options.baseURL\n        );\n        this.model = options.model || 'grok-3-latest';\n        this.maxToolRounds = options.maxToolRounds || 30;\n        this.tokenCounter = createTokenCounter(this.model);\n\n        // Create registry\n        this.registry = createToolRegistry();\n\n        // Create tool executor with retry logic\n        this.executeToolWithRegistry = createToolExecutorWithRetry(this.registry);\n\n        // Create tool loader with appropriate directories\n        const directories: string[] = [];\n\n        // Always include ~/.clanker\n        const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n        if (homeDir) {\n            directories.push(path.join(homeDir, '.clanker'));\n        }\n\n        // Add custom path if specified\n        if (options.dynamicToolsPath) {\n            directories.push(options.dynamicToolsPath);\n        }\n\n        // Add current directory if dynamic tools enabled\n        if (options.loadDynamicTools) {\n            directories.push(process.cwd());\n        }\n\n        // Create loader\n        this.toolLoader = createToolLoader(this.registry, {\n            directories: directories.length > 0 ? directories : undefined,\n            recursive: true,\n            watch: options.watchTools ?? false,\n            loadBuiltins: true\n        });\n\n        // Tools will be loaded when needed via waitForToolsToLoad()\n    }\n\n\n    async chat(\n        messages: GrokMessage[],\n        systemPrompt?: string,\n        stream: boolean = false\n    ): Promise<string | AsyncGenerator<StreamingChunk, void, unknown>> {\n        const allMessages: GrokMessage[] = [];\n\n        // Add system prompt if provided\n        if (systemPrompt) {\n            allMessages.push({role: 'system', content: systemPrompt});\n        }\n\n        // Add user messages\n        allMessages.push(...messages);\n\n        // Get tool definitions from registry\n        const tools = generateGrokTools(this.registry);\n\n        if (stream) {\n            return this.streamChat(allMessages, tools);\n        } else {\n            return this.nonStreamChat(allMessages, tools);\n        }\n    }\n\n    private async* streamChat(\n        messages: GrokMessage[],\n        tools: GrokTool[]\n    ): AsyncGenerator<StreamingChunk, void, unknown> {\n        let rounds = 0;\n        let currentMessages = [...messages];\n        let totalTokens = this.tokenCounter.countMessageTokens(currentMessages as never); // Start with initial message tokens\n\n        while (rounds < this.maxToolRounds) {\n            // Use real streaming from Grok API\n            const stream = this.client.chatStream(\n                currentMessages,\n                tools.length > 0 ? tools : undefined,\n                this.model\n            );\n\n            let accumulatedContent = '';\n            const accumulatedToolCalls: GrokToolCall[] = [];\n            let currentToolCall: Partial<GrokToolCall> | null = null;\n            let lastFinishReason: string | null = null;\n\n            // Process the stream\n            for await (const chunk of stream) {\n                // Skip chunks without choices or delta\n                if (!chunk.choices || chunk.choices.length === 0 || !chunk.choices[0].delta) {\n                    continue;\n                }\n\n                // Handle tool calls\n                if (chunk.choices[0].delta.tool_calls) {\n                    for (const toolCallDelta of chunk.choices[0].delta.tool_calls) {\n                        if (toolCallDelta.index === 0 && !currentToolCall) {\n                            currentToolCall = {\n                                id: toolCallDelta.id,\n                                type: 'function' as const,\n                                function: {\n                                    name: toolCallDelta.function?.name || '',\n                                    arguments: toolCallDelta.function?.arguments || ''\n                                }\n                            };\n                        } else if (currentToolCall && toolCallDelta.function?.arguments) {\n                            currentToolCall.function!.arguments += toolCallDelta.function.arguments;\n                        }\n                    }\n                }\n\n                // Handle content streaming\n                if (chunk.choices[0].delta.content !== undefined && chunk.choices[0].delta.content !== null) {\n                    const content = chunk.choices[0].delta.content;\n                    accumulatedContent += content;\n\n                    yield {\n                        type: 'content',\n                        content\n                    };\n\n                    // Update token count in real-time\n                    const currentOutputTokens = this.tokenCounter.estimateStreamingTokens(accumulatedContent) +\n                        (accumulatedToolCalls.length > 0 ? this.tokenCounter.countTokens(JSON.stringify(accumulatedToolCalls)) : 0);\n\n                    yield {\n                        type: 'token_count',\n                        tokenCount: totalTokens + currentOutputTokens\n                    };\n                }\n\n                // Check for finish reason\n                if (chunk.choices[0].finish_reason) {\n                    lastFinishReason = chunk.choices[0].finish_reason;\n                    if (currentToolCall) {\n                        accumulatedToolCalls.push(currentToolCall as GrokToolCall);\n                    }\n                    break;\n                }\n            }\n\n            // Process accumulated results\n            if (accumulatedToolCalls.length > 0) {\n                // Emit tool calls\n                yield {\n                    type: 'tool_calls',\n                    toolCalls: accumulatedToolCalls\n                };\n\n                // Execute tool calls\n                const toolResults = await this.executeToolCalls(accumulatedToolCalls);\n\n                // Add assistant message\n                const assistantMessage = {\n                    role: 'assistant',\n                    content: accumulatedContent || '',\n                    tool_calls: accumulatedToolCalls\n                } as GrokMessage;\n                currentMessages.push(assistantMessage);\n\n                // Update total tokens to include the assistant message\n                totalTokens = this.tokenCounter.countMessageTokens(currentMessages as never);\n\n                // Add tool results and emit them\n                for (let i = 0; i < toolResults.length; i++) {\n                    const toolResult = toolResults[i];\n\n                    yield {\n                        type: 'tool_result',\n                        toolCall: accumulatedToolCalls[i],\n                        toolResult\n                    };\n\n                    const toolMessage = {\n                        role: 'tool',\n                        content: this.formatToolResult(toolResult),\n                        tool_call_id: accumulatedToolCalls[i].id\n                    } as GrokMessage;\n                    currentMessages.push(toolMessage);\n\n                    // Update total tokens after each tool result\n                    totalTokens = this.tokenCounter.countMessageTokens(currentMessages as never);\n\n                    // Emit updated token count\n                    yield {\n                        type: 'token_count',\n                        tokenCount: totalTokens\n                    };\n                }\n\n                rounds++;\n                currentToolCall = null;\n                debug.log(`[Agent] Tool execution complete, continuing to round ${rounds}`);\n                // Continue the loop to get assistant's response about the tool results\n            } else if (accumulatedContent) {\n                // No tool calls but we have content, we're done\n                yield {\n                    type: 'done'\n                };\n                return;\n            } else if (lastFinishReason === 'tool_calls') {\n                // Grok API quirk: finish_reason is tool_calls but no actual tool calls\n                // This seems to happen on the first round, continue to get actual response\n                rounds++;\n            } else {\n                // No tool calls and no content, we're done\n                yield {\n                    type: 'done'\n                };\n                return;\n            }\n        }\n\n        throw new Error(`Maximum tool rounds (${this.maxToolRounds}) exceeded`);\n    }\n\n    private async nonStreamChat(\n        messages: GrokMessage[],\n        tools: GrokTool[]\n    ): Promise<string> {\n        let rounds = 0;\n        let currentMessages = [...messages];\n\n        while (rounds < this.maxToolRounds) {\n            const response = await this.client.chat(\n                currentMessages,\n                tools.length > 0 ? tools : undefined,\n                this.model\n            );\n\n            const message = response.choices[0]?.message;\n            if (!message) {\n                throw new Error('No response from API');\n            }\n\n            if (message.tool_calls && message.tool_calls.length > 0) {\n                // Execute tool calls\n                const toolResults = await this.executeToolCalls(message.tool_calls);\n\n                // Add assistant message\n                currentMessages.push({\n                    role: 'assistant',\n                    content: message.content,\n                    tool_calls: message.tool_calls\n                } as GrokMessage);\n\n                // Add tool results\n                for (let i = 0; i < toolResults.length; i++) {\n                    currentMessages.push({\n                        role: 'tool',\n                        content: this.formatToolResult(toolResults[i]),\n                        tool_call_id: message.tool_calls[i].id\n                    } as GrokMessage);\n                }\n\n                rounds++;\n            } else {\n                // No tool calls, return the content\n                return message.content || '';\n            }\n        }\n\n        throw new Error(`Maximum tool rounds (${this.maxToolRounds}) exceeded`);\n    }\n\n    private async executeToolCalls(toolCalls: GrokToolCall[]): Promise<ToolResult[]> {\n        const results: ToolResult[] = [];\n\n        for (const toolCall of toolCalls) {\n            try {\n                const result = await this.executeTool(toolCall);\n                results.push(result);\n            } catch (error) {\n                results.push({\n                    success: false,\n                    error: `Tool execution error: ${error instanceof Error ? error.message : String(error)}`\n                });\n            }\n        }\n\n        return results;\n    }\n\n    async executeTool(toolCall: GrokToolCall): Promise<ToolResult> {\n        const toolName = toolCall.function.name;\n\n        // Safely parse arguments\n        let args: Record<string, unknown>;\n        try {\n            args = JSON.parse(toolCall.function.arguments);\n        } catch (error) {\n            debug.error(`[Agent] Failed to parse arguments for ${toolName}:`);\n            debug.error(`[Agent] Raw arguments: ${JSON.stringify(toolCall.function.arguments)}`);\n            debug.error(`[Agent] Error: ${error}`);\n            \n            // Get tool info to provide better error message\n            const tool = this.registry.get(toolName);\n            // const hasRequiredArgs = tool?.definition.arguments?.some(arg => arg.required) ?? false;\n            \n            // Build helpful error message\n            let errorMessage = `Failed to parse JSON arguments: ${error instanceof Error ? error.message : String(error)}`;\n            errorMessage += `\\n\\nThe raw arguments were: ${toolCall.function.arguments}`;\n            \n            if (tool) {\n                errorMessage += `\\n\\nTool \"${toolName}\" expects:`;\n                if (!tool.definition.arguments || tool.definition.arguments.length === 0) {\n                    errorMessage += '\\n- No arguments required (use empty object: {})';\n                } else {\n                    tool.definition.arguments.forEach(arg => {\n                        errorMessage += `\\n- ${arg.name}: ${arg.type}${arg.required ? ' (required)' : ' (optional)'}`;\n                        if (arg.description) {\n                            errorMessage += ` - ${arg.description}`;\n                        }\n                    });\n                }\n            }\n            \n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n\n        return this.executeToolWithRegistry(toolName, args);\n    }\n\n    private formatToolResult(result: ToolResult): string {\n        if (result.success) {\n            return result.output || JSON.stringify(result.data) || 'Success';\n        } else {\n            return `Error: ${result.error}`;\n        }\n    }\n\n    // Public API for registry access\n    getRegistry(): ToolRegistry {\n        return this.registry;\n    }\n    \n    async waitForToolsToLoad(): Promise<void> {\n        if (this.toolLoader) {\n            await this.toolLoader.loadTools();\n        }\n    }\n\n    // Get tool statistics\n    getToolStats(): Record<string, { executionCount: number; totalDuration: number }> {\n        // Type assertion to access the implementation's getExecutionStats method\n        const registryImpl = this.registry as ToolRegistry & {\n            getExecutionStats(): Record<string, { executionCount: number; totalDuration: number }>\n        };\n        return registryImpl.getExecutionStats();\n    }\n\n    // Get the underlying Grok client\n    getClient(): GrokClient {\n        return this.client;\n    }\n\n    // Reload dynamic tools\n    async reloadDynamicTools(): Promise<void> {\n        if (this.toolLoader) {\n            await this.toolLoader.reloadAllTools();\n        }\n    }\n\n    // Clean up resources\n    dispose(): void {\n        this.tokenCounter.dispose();\n        if (this.toolLoader) {\n            this.toolLoader.cleanup();\n        }\n    }\n}","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { z } from 'zod';\n\n// Provider configuration\nexport const ProviderModels = {\n    grok: {\n        name: 'Grok',\n        baseURL: 'https://api.x.ai/v1',\n        models: [\n            { value: 'grok-4-0709', label: 'Grok 4' },\n            { value: 'grok-3', label: 'Grok 3' },\n            { value: 'grok-3-mini', label: 'Grok 3 Mini' },\n            { value: 'grok-3-fast', label: 'Grok 3 Fast' },\n            { value: 'grok-3-mini-fast', label: 'Grok 3 Mini Fast' },\n            { value: 'grok-2-vision-1212', label: 'Grok 2 Vision' },\n            { value: 'grok-2-image-1212', label: 'Grok 2 Image' }\n        ],\n        defaultModel: 'grok-3'\n    },\n    openai: {\n        name: 'OpenAI',\n        baseURL: 'https://api.openai.com/v1',\n        models: [\n            { value: 'gpt-4', label: 'GPT-4' },\n            { value: 'gpt-4-turbo', label: 'GPT-4 Turbo' },\n            { value: 'gpt-3.5-turbo', label: 'GPT-3.5 Turbo' }\n        ],\n        defaultModel: 'gpt-4-turbo'\n    },\n    custom: {\n        name: 'Custom',\n        baseURL: '',\n        models: [],\n        defaultModel: ''\n    }\n} as const;\n\nexport type Provider = keyof typeof ProviderModels;\n\n// Define the settings schema\nexport const SettingsSchema = z.object({\n    apiKey: z.string().min(1, 'API key is required'),\n    provider: z.enum(['grok', 'openai', 'custom'] as const).default('grok'),\n    customBaseURL: z.string().url().optional(),\n    model: z.string().default(ProviderModels.grok.defaultModel),\n    theme: z.enum(['light', 'dark', 'auto']).default('auto'),\n    autoEditEnabled: z.boolean().default(false),\n    vsCodeOpenEnabled: z.boolean().default(false),\n    dangerousBypassPermission: z.boolean().default(false),\n    virtualScrollingEnabled: z.boolean().default(true),\n    confirmationSettings: z.object({\n        alwaysEdit: z.boolean().default(false),\n        alwaysBash: z.boolean().default(false),\n        alwaysSearch: z.boolean().default(false),\n    }).default({}),\n    // Add version to track schema changes\n    version: z.number().default(1)\n});\n\nexport type Settings = z.infer<typeof SettingsSchema>;\n\nexport class SettingsManager {\n    private static instance: SettingsManager;\n    private settingsPath: string;\n    private settingsDir: string;\n    private currentVersion = 2;\n\n    private constructor() {\n        this.settingsDir = path.join(os.homedir(), '.clanker');\n        this.settingsPath = path.join(this.settingsDir, 'settings.json');\n    }\n\n    static getInstance(): SettingsManager {\n        if (!SettingsManager.instance) {\n            SettingsManager.instance = new SettingsManager();\n        }\n        return SettingsManager.instance;\n    }\n\n    /**\n     * Ensure the settings directory exists\n     */\n    private ensureSettingsDir(): void {\n        if (!fs.existsSync(this.settingsDir)) {\n            fs.mkdirSync(this.settingsDir, { recursive: true });\n        }\n    }\n\n    /**\n     * Load settings from file\n     */\n    loadSettings(): { settings: Partial<Settings>, isValid: boolean, errors: z.ZodError | null } {\n        try {\n            this.ensureSettingsDir();\n            \n            if (!fs.existsSync(this.settingsPath)) {\n                return { settings: {}, isValid: false, errors: null };\n            }\n\n            const fileContent = fs.readFileSync(this.settingsPath, 'utf-8');\n            const rawSettings = JSON.parse(fileContent);\n            \n            // Try to parse with schema\n            const result = SettingsSchema.safeParse(rawSettings);\n            \n            if (result.success) {\n                return { settings: result.data, isValid: true, errors: null };\n            } else {\n                // Return partial settings and validation errors\n                return { settings: rawSettings, isValid: false, errors: result.error };\n            }\n        } catch (error) {\n            console.error('Failed to load settings:', error);\n            return { settings: {}, isValid: false, errors: null };\n        }\n    }\n\n    /**\n     * Save settings to file\n     */\n    saveSettings(settings: Settings): void {\n        try {\n            this.ensureSettingsDir();\n            \n            // Add version\n            const settingsWithVersion = { ...settings, version: this.currentVersion };\n            \n            fs.writeFileSync(\n                this.settingsPath,\n                JSON.stringify(settingsWithVersion, null, 2),\n                'utf-8'\n            );\n        } catch (error) {\n            console.error('Failed to save settings:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Check if settings need to be configured\n     * Returns true if settings are missing, invalid, or have new fields\n     */\n    needsConfiguration(): boolean {\n        const { isValid, settings } = this.loadSettings();\n        \n        if (!isValid) return true;\n        \n        // Check if we have all required fields\n        const requiredFields = ['apiKey'];\n        for (const field of requiredFields) {\n            if (!settings[field as keyof Settings]) {\n                return true;\n            }\n        }\n        \n        // Check version for schema changes\n        if (!settings.version || settings.version < this.currentVersion) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    /**\n     * Get fields that need configuration\n     */\n    getMissingFields(): string[] {\n        const { settings } = this.loadSettings();\n        const schema = SettingsSchema.shape;\n        const missingFields: string[] = [];\n        \n        // Check each field in the schema\n        for (const [key, value] of Object.entries(schema)) {\n            if (key === 'version') continue;\n            \n            // Check if field is required and missing\n            if (!value.isOptional() && !settings[key as keyof Settings]) {\n                missingFields.push(key);\n            }\n        }\n        \n        return missingFields;\n    }\n\n    /**\n     * Validate a single field\n     */\n    validateField(field: keyof Settings, value: any): string | undefined {\n        try {\n            const fieldSchema = SettingsSchema.shape[field];\n            fieldSchema.parse(value);\n            return undefined;\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return error.errors[0]?.message || 'Invalid value';\n            }\n            return 'Invalid value';\n        }\n    }\n}","import { proxy } from 'valtio';\nimport * as crypto from 'crypto';\nimport { GrokAgent } from '../clanker/agent';\nimport { MessageRegistryMessage } from '../registry/messages';\nimport { ToolExecution } from '../registry/execution';\nimport { ConfirmationOptions } from '../utils/confirmation-service';\nimport { GrokToolCall } from '../clanker/client';\nimport { debug } from '../utils/debug-logger';\nimport { Stage, StageType } from '../ui/stage/types';\n\n// File tracker types\ninterface FileInfo {\n    hash: string;\n    lastRead: Date;\n    lineCount: number;\n}\n\n// Define the complete store state\nexport interface AppState {\n    // Agent slice\n    agent: GrokAgent | null;\n    isInitializing: boolean;\n    initError: string | null;\n    \n    // Messages slice\n    messages: MessageRegistryMessage[];\n    messageCount: number;\n    \n    // Executions slice\n    executions: Map<string, ToolExecution>;\n    activeExecutions: string[];\n    \n    // File tracker slice\n    trackedFiles: Map<string, FileInfo>;\n    \n    // UI slice\n    isProcessing: boolean;\n    isStreaming: boolean;\n    tokenCount: number;\n    inputTokenCount: number;\n    outputTokenCount: number;\n    processingTime: number;\n    inputValue: string;\n    cursorPosition: number;\n    inputHistory: string[];\n    historyIndex: number;\n    showHelp: boolean;\n    showModelSelector: boolean;\n    exitConfirmation: boolean;\n    exitConfirmationTime: number;\n    showCommandSuggestions: boolean;\n    selectedCommandIndex: number;\n    commandSuggestions: string[];\n    showModelSelection: boolean;\n    selectedModelIndex: number;\n    availableModels: string[];\n    showCommandForm: boolean;\n    \n    // Stage management\n    stageStack: Stage[];\n    \n    // Settings slice\n    autoEditEnabled: boolean;\n    vsCodeOpenEnabled: boolean;\n    dangerousBypassPermission: boolean;\n    virtualScrollingEnabled: boolean;\n    confirmationSettings: {\n        alwaysEdit: boolean;\n        alwaysBash: boolean;\n        alwaysSearch: boolean;\n    };\n    theme: 'light' | 'dark' | 'auto';\n    model: string;\n    \n    // Confirmation slice\n    confirmationOptions: ConfirmationOptions | null;\n    confirmationResolver: ((result: ConfirmationResult) => void) | null;\n}\n\nexport interface ConfirmationResult {\n    confirmed: boolean;\n    dontAskAgain?: boolean;\n    feedback?: string;\n}\n\n// Create the proxy store with initial state\nexport const store = proxy<AppState>({\n    // Agent slice\n    agent: null,\n    isInitializing: false,\n    initError: null,\n    \n    // Messages slice\n    messages: [],\n    messageCount: 0,\n    \n    // Executions slice\n    executions: new Map(),\n    activeExecutions: [],\n    \n    // File tracker slice\n    trackedFiles: new Map(),\n    \n    // UI slice\n    isProcessing: false,\n    isStreaming: false,\n    tokenCount: 0,\n    inputTokenCount: 0,\n    outputTokenCount: 0,\n    processingTime: 0,\n    inputValue: '',\n    cursorPosition: 0,\n    inputHistory: [],\n    historyIndex: -1,\n    showHelp: false,\n    showModelSelector: false,\n    exitConfirmation: false,\n    exitConfirmationTime: 0,\n    showCommandSuggestions: false,\n    selectedCommandIndex: 0,\n    commandSuggestions: [],\n    showModelSelection: false,\n    selectedModelIndex: 0,\n    availableModels: ['grok-4-latest', 'grok-3-latest', 'grok-4', 'grok-3', 'grok-beta'],\n    showCommandForm: false,\n    \n    // Stage management\n    stageStack: [{ id: 'main', type: StageType.CHAT }],\n    \n    // Settings slice\n    autoEditEnabled: false,\n    vsCodeOpenEnabled: false,\n    dangerousBypassPermission: false,\n    virtualScrollingEnabled: true,\n    confirmationSettings: {\n        alwaysEdit: false,\n        alwaysBash: false,\n        alwaysSearch: false,\n    },\n    theme: 'auto',\n    model: 'grok-beta',\n    \n    // Confirmation slice\n    confirmationOptions: null,\n    confirmationResolver: null,\n});\n\n// Store actions as separate functions\nexport const actions = {\n    // Agent actions\n    setAgent(agent: GrokAgent) {\n        store.agent = agent;\n        store.initError = null;\n    },\n    \n    async initializeAgent(options: {\n        apiKey: string;\n        baseURL?: string;\n        model?: string;\n        maxToolRounds?: number;\n        systemPrompt?: string;\n        loadDynamicTools?: boolean;\n        dynamicToolsPath?: string;\n    }) {\n        store.isInitializing = true;\n        store.initError = null;\n        \n        try {\n            const { GrokAgent } = await import('../clanker/agent');\n            const agent = new GrokAgent(options);\n            store.agent = agent;\n            store.isInitializing = false;\n        } catch (error) {\n            store.isInitializing = false;\n            store.initError = error instanceof Error ? error.message : 'Unknown error';\n            throw error;\n        }\n    },\n    \n    clearAgent() {\n        store.agent = null;\n        store.initError = null;\n    },\n    \n    setInitializing(isInitializing: boolean) {\n        store.isInitializing = isInitializing;\n    },\n    \n    setInitError(error: string | null) {\n        store.initError = error;\n    },\n    \n    // Message actions\n    addMessage(message: Omit<MessageRegistryMessage, 'id' | 'timestamp'>) {\n        const id = `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        const newMessage: MessageRegistryMessage = {\n            ...message,\n            id,\n            timestamp: new Date(),\n        };\n        \n        store.messages.push(newMessage);\n        store.messageCount = store.messages.length;\n    },\n    \n    updateMessage(id: string, updates: Partial<MessageRegistryMessage>) {\n        const index = store.messages.findIndex(msg => msg.id === id);\n        if (index !== -1) {\n            Object.assign(store.messages[index], updates);\n        }\n    },\n    \n    clearMessages() {\n        store.messages = [];\n        store.messageCount = 0;\n    },\n    \n    setMessages(messages: MessageRegistryMessage[]) {\n        store.messages = messages;\n        store.messageCount = messages.length;\n    },\n    \n    startStreaming(messageId: string) {\n        const message = store.messages.find(msg => msg.id === messageId);\n        if (message) {\n            if (!message.metadata) message.metadata = {};\n            message.metadata.isStreaming = true;\n        }\n    },\n    \n    appendToMessage(messageId: string, content: string) {\n        const message = store.messages.find(msg => msg.id === messageId);\n        if (message) {\n            message.content += content;\n        }\n    },\n    \n    finishStreaming(messageId: string, metadata?: MessageRegistryMessage['metadata']) {\n        const message = store.messages.find(msg => msg.id === messageId);\n        if (message) {\n            if (!message.metadata) message.metadata = {};\n            Object.assign(message.metadata, metadata);\n            message.metadata.isStreaming = false;\n        }\n    },\n    \n    addToolCalls(messageId: string, toolCalls: GrokToolCall[]) {\n        const message = store.messages.find(msg => msg.id === messageId);\n        if (message) {\n            message.toolCalls = toolCalls;\n        }\n    },\n    \n    // Execution actions\n    addExecution(execution: Omit<ToolExecution, 'id' | 'startTime' | 'status'>): string {\n        const id = `exec-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        const newExecution: ToolExecution = {\n            ...execution,\n            id,\n            status: 'executing',\n            startTime: new Date(),\n        };\n        \n        store.executions.set(id, newExecution);\n        store.activeExecutions.push(id);\n        \n        return id;\n    },\n    \n    updateExecution(id: string, updates: Partial<ToolExecution>) {\n        const execution = store.executions.get(id);\n        if (execution) {\n            Object.assign(execution, updates);\n            store.executions.set(id, execution);\n        }\n    },\n    \n    completeExecution(id: string, result: ToolExecution['result']) {\n        const execution = store.executions.get(id);\n        if (execution) {\n            execution.status = 'completed';\n            execution.result = result;\n            execution.endTime = new Date();\n            store.executions.set(id, execution);\n            store.activeExecutions = store.activeExecutions.filter(execId => execId !== id);\n        }\n    },\n    \n    failExecution(id: string, error: string) {\n        const execution = store.executions.get(id);\n        if (execution) {\n            execution.status = 'failed';\n            execution.result = {\n                success: false,\n                error\n            };\n            execution.endTime = new Date();\n            store.executions.set(id, execution);\n            store.activeExecutions = store.activeExecutions.filter(execId => execId !== id);\n        }\n    },\n    \n    getExecution(id: string): ToolExecution | undefined {\n        return store.executions.get(id);\n    },\n    \n    clearExecutions() {\n        store.executions = new Map();\n        store.activeExecutions = [];\n    },\n    \n    // UI actions\n    setProcessing(isProcessing: boolean) {\n        store.isProcessing = isProcessing;\n    },\n    \n    setStreaming(isStreaming: boolean) {\n        store.isStreaming = isStreaming;\n    },\n    \n    updateTokenCount(count: number) {\n        store.tokenCount = count;\n        store.outputTokenCount = count;\n    },\n    \n    updateInputTokenCount(count: number) {\n        store.inputTokenCount = count;\n    },\n    \n    updateOutputTokenCount(count: number) {\n        store.outputTokenCount = count;\n        store.tokenCount = count;\n    },\n    \n    updateProcessingTime(time: number) {\n        store.processingTime = time;\n    },\n    \n    setInputValue(value: string) {\n        store.inputValue = value;\n    },\n    \n    getInputValue(): string {\n        return store.inputValue;\n    },\n    \n    setCursorPosition(position: number) {\n        store.cursorPosition = position;\n    },\n    \n    addToHistory(input: string) {\n        if (!input.trim()) return;\n        \n        // Remove duplicate if it exists\n        const filtered = store.inputHistory.filter(item => item !== input);\n        // Add to the end\n        const newHistory = [...filtered, input];\n        // Limit history size\n        store.inputHistory = newHistory.length > 100 \n            ? newHistory.slice(-100) \n            : newHistory;\n        store.historyIndex = -1;\n    },\n    \n    navigateHistory(direction: 'up' | 'down') {\n        if (direction === 'up') {\n            const newIndex = store.historyIndex === -1\n                ? store.inputHistory.length - 1\n                : Math.max(0, store.historyIndex - 1);\n            \n            if (newIndex >= 0 && newIndex < store.inputHistory.length) {\n                store.historyIndex = newIndex;\n                store.inputValue = store.inputHistory[newIndex];\n                store.cursorPosition = store.inputHistory[newIndex].length;\n            }\n        } else { // down\n            if (store.historyIndex === -1) return;\n            \n            const newIndex = store.historyIndex + 1;\n            \n            if (newIndex >= store.inputHistory.length) {\n                store.historyIndex = -1;\n                store.inputValue = '';\n                store.cursorPosition = 0;\n            } else {\n                store.historyIndex = newIndex;\n                store.inputValue = store.inputHistory[newIndex];\n                store.cursorPosition = store.inputHistory[newIndex].length;\n            }\n        }\n    },\n    \n    toggleHelp() {\n        store.showHelp = !store.showHelp;\n    },\n    \n    toggleModelSelector() {\n        store.showModelSelector = !store.showModelSelector;\n    },\n    \n    setExitConfirmation(show: boolean) {\n        store.exitConfirmation = show;\n        if (show) {\n            store.exitConfirmationTime = Date.now();\n        }\n    },\n    \n    // Settings actions\n    setAutoEdit(enabled: boolean) {\n        store.autoEditEnabled = enabled;\n        actions.saveSettings();\n    },\n    \n    setVSCodeOpen(enabled: boolean) {\n        store.vsCodeOpenEnabled = enabled;\n        actions.saveSettings();\n    },\n    \n    setDangerousBypassPermission(enabled: boolean) {\n        store.dangerousBypassPermission = enabled;\n        actions.saveSettings();\n    },\n    \n    setVirtualScrolling(enabled: boolean) {\n        store.virtualScrollingEnabled = enabled;\n        actions.saveSettings();\n    },\n    \n    updateConfirmationSettings(settings: Partial<AppState['confirmationSettings']>) {\n        Object.assign(store.confirmationSettings, settings);\n        actions.saveSettings();\n    },\n    \n    setTheme(theme: AppState['theme']) {\n        store.theme = theme;\n        actions.saveSettings();\n    },\n    \n    setModel(model: string) {\n        store.model = model;\n        actions.saveSettings();\n    },\n    \n    // Command form actions\n    setShowCommandForm(show: boolean) {\n        store.showCommandForm = show;\n    },\n    \n    // UI actions\n    setShowHelp(show: boolean) {\n        store.showHelp = show;\n    },\n    \n    async loadSettings() {\n        try {\n            const { SettingsManager } = await import('../utils/settings-manager');\n            const settingsManager = SettingsManager.getInstance();\n            const { settings, isValid } = settingsManager.loadSettings();\n            \n            if (isValid && settings) {\n                // Update store with loaded settings\n                if (settings.model) store.model = settings.model;\n                if (settings.theme) store.theme = settings.theme;\n                if (settings.autoEditEnabled !== undefined) store.autoEditEnabled = settings.autoEditEnabled;\n                if (settings.vsCodeOpenEnabled !== undefined) store.vsCodeOpenEnabled = settings.vsCodeOpenEnabled;\n                if (settings.dangerousBypassPermission !== undefined) store.dangerousBypassPermission = settings.dangerousBypassPermission;\n                if (settings.virtualScrollingEnabled !== undefined) store.virtualScrollingEnabled = settings.virtualScrollingEnabled;\n                if (settings.confirmationSettings) {\n                    Object.assign(store.confirmationSettings, settings.confirmationSettings);\n                }\n            }\n        } catch (error) {\n            debug.error('Failed to load settings:', error);\n        }\n    },\n    \n    async saveSettings() {\n        try {\n            const settingsToSave = {\n                autoEditEnabled: store.autoEditEnabled,\n                vsCodeOpenEnabled: store.vsCodeOpenEnabled,\n                dangerousBypassPermission: store.dangerousBypassPermission,\n                virtualScrollingEnabled: store.virtualScrollingEnabled,\n                confirmationSettings: store.confirmationSettings,\n                theme: store.theme,\n                model: store.model,\n            };\n            \n            // debug.log('Saving settings:', settingsToSave);\n        } catch (error) {\n            debug.error('Failed to save settings:', error);\n        }\n    },\n    \n    // Confirmation actions\n    requestConfirmation(options: ConfirmationOptions): Promise<ConfirmationResult> {\n        return new Promise<ConfirmationResult>((resolve) => {\n            store.confirmationOptions = options;\n            store.confirmationResolver = resolve;\n        });\n    },\n    \n    respondToConfirmation(result: ConfirmationResult) {\n        if (store.confirmationResolver) {\n            store.confirmationResolver(result);\n            store.confirmationOptions = null;\n            store.confirmationResolver = null;\n        }\n    },\n    \n    cancelConfirmation() {\n        if (store.confirmationResolver) {\n            store.confirmationResolver({ confirmed: false });\n            store.confirmationOptions = null;\n            store.confirmationResolver = null;\n        }\n    },\n    \n    // File tracker actions\n    updateFile(filePath: string, content: string) {\n        const hash = crypto.createHash('sha256').update(content).digest('hex');\n        const lineCount = content.split('\\n').length;\n        \n        store.trackedFiles.set(filePath, {\n            hash,\n            lastRead: new Date(),\n            lineCount\n        });\n    },\n    \n    hasFile(filePath: string): boolean {\n        return store.trackedFiles.has(filePath);\n    },\n    \n    getFileInfo(filePath: string): FileInfo | undefined {\n        return store.trackedFiles.get(filePath);\n    },\n    \n    verifyFileHash(filePath: string, content: string): boolean {\n        const fileInfo = store.trackedFiles.get(filePath);\n        if (!fileInfo) return false;\n        \n        const currentHash = crypto.createHash('sha256').update(content).digest('hex');\n        return fileInfo.hash === currentHash;\n    },\n    \n    clearFile(filePath: string) {\n        store.trackedFiles.delete(filePath);\n    },\n    \n    clearAllFiles() {\n        store.trackedFiles.clear();\n    },\n    \n    // Stage management actions\n    getCurrentStage(): Stage {\n        return store.stageStack[store.stageStack.length - 1];\n    },\n    \n    pushStage(stage: Stage) {\n        store.stageStack.push(stage);\n    },\n    \n    popStage() {\n        if (store.stageStack.length > 1) {\n            store.stageStack.pop();\n        }\n    },\n    \n    replaceStage(stage: Stage) {\n        if (store.stageStack.length > 0) {\n            store.stageStack[store.stageStack.length - 1] = stage;\n        }\n    },\n    \n    clearStages() {\n        store.stageStack = [{ id: 'main', type: StageType.CHAT }];\n    },\n    \n    getStageStack(): Stage[] {\n        return store.stageStack;\n    },\n};\n\n// Export file tracker actions separately for convenience\nexport const fileTrackerActions = {\n    updateFile: actions.updateFile,\n    hasFile: actions.hasFile,\n    getFileInfo: actions.getFileInfo,\n    verifyFileHash: actions.verifyFileHash,\n    clearFile: actions.clearFile,\n    clearAllFiles: actions.clearAllFiles,\n};","// Re-export everything from the valtio store\nexport { store, actions } from './store';\nexport type { AppState, ConfirmationResult } from './store';\n\n// Re-export types for convenience\nexport type { MessageRegistryMessage } from '../registry/messages';\nexport type { ToolExecution } from '../registry/execution';\nexport type { ConfirmationOptions } from '../utils/confirmation-service';\nexport type { GrokAgent } from '../clanker/agent';","import {EventEmitter} from \"events\";\nimport {store} from \"../store\";\n\nexport interface ConfirmationOptions {\n    operation: string;\n    filename: string;\n    content?: string; // Content to show in confirmation dialog\n}\n\nexport interface ConfirmationResult {\n    confirmed: boolean;\n    dontAskAgain?: boolean;\n    feedback?: string;\n}\n\nexport class ConfirmationService extends EventEmitter {\n    private static instance: ConfirmationService;\n    private skipConfirmationThisSession = false;\n    private pendingConfirmation: Promise<ConfirmationResult> | null = null;\n    private resolveConfirmation: ((result: ConfirmationResult) => void) | null =\n        null;\n\n    // Session flags for different operation types\n    private sessionFlags = {\n        fileOperations: false,\n        bashCommands: false,\n        allOperations: false,\n        createFiles: false,\n        editFiles: false,\n    };\n\n    static getInstance(): ConfirmationService {\n        if (!ConfirmationService.instance) {\n            ConfirmationService.instance = new ConfirmationService();\n        }\n        return ConfirmationService.instance;\n    }\n\n    constructor() {\n        super();\n    }\n\n    async requestConfirmation(\n        options: ConfirmationOptions,\n        operationType: \"file\" | \"bash\" | \"file_create\" | \"file_edit\" = \"file\"\n    ): Promise<ConfirmationResult> {\n        // Check if dangerously bypass permission is enabled\n        if (store.dangerousBypassPermission) {\n            return {confirmed: true};\n        }\n\n        // Check if auto-edit is enabled for file operations only\n        if (store.autoEditEnabled && (operationType === \"file_edit\" || operationType === \"file_create\")) {\n            return {confirmed: true};\n        }\n\n        // Check session flags\n        if (\n            this.sessionFlags.allOperations ||\n            (operationType === \"file\" && this.sessionFlags.fileOperations) ||\n            (operationType === \"bash\" && this.sessionFlags.bashCommands) ||\n            (operationType === \"file_create\" && this.sessionFlags.createFiles) ||\n            (operationType === \"file_edit\" && this.sessionFlags.editFiles)\n        ) {\n            return {confirmed: true};\n        }\n\n\n        // Create a promise that will be resolved by the UI component\n        this.pendingConfirmation = new Promise<ConfirmationResult>((resolve) => {\n            this.resolveConfirmation = resolve;\n        });\n\n        // Emit custom event that the UI can listen to (using setImmediate to ensure the UI updates)\n        setImmediate(() => {\n            this.emit(\"confirmation-requested\", options);\n        });\n\n        const result = await this.pendingConfirmation;\n\n        if (result.dontAskAgain) {\n            // Set the appropriate session flag based on operation type\n            if (operationType === \"file\") {\n                this.sessionFlags.fileOperations = true;\n            } else if (operationType === \"bash\") {\n                this.sessionFlags.bashCommands = true;\n            } else if (operationType === \"file_create\") {\n                this.sessionFlags.createFiles = true;\n            } else if (operationType === \"file_edit\") {\n                this.sessionFlags.editFiles = true;\n            }\n            // Could also set allOperations for global skip\n        }\n\n        return result;\n    }\n\n    confirmOperation(confirmed: boolean, dontAskAgain?: boolean): void {\n        if (this.resolveConfirmation) {\n            this.resolveConfirmation({confirmed, dontAskAgain});\n            this.resolveConfirmation = null;\n            this.pendingConfirmation = null;\n        }\n    }\n\n    rejectOperation(feedback?: string): void {\n        if (this.resolveConfirmation) {\n            this.resolveConfirmation({confirmed: false, feedback});\n            this.resolveConfirmation = null;\n            this.pendingConfirmation = null;\n        }\n    }\n\n\n    isPending(): boolean {\n        return this.pendingConfirmation !== null;\n    }\n\n    resetSession(): void {\n        this.sessionFlags = {\n            fileOperations: false,\n            bashCommands: false,\n            allOperations: false,\n            createFiles: false,\n            editFiles: false,\n        };\n    }\n\n    getSessionFlags() {\n        return {...this.sessionFlags};\n    }\n\n    setSessionFlag(\n        flagType: \"fileOperations\" | \"bashCommands\" | \"allOperations\",\n        value: boolean\n    ) {\n        this.sessionFlags[flagType] = value;\n    }\n}\n","/**\n * Logger implementation for tool execution\n */\n\nimport { ToolLogger } from './types';\n\n/**\n * Console logger implementation\n */\nexport class ConsoleLogger implements ToolLogger {\n  private prefix: string;\n  private enabled: boolean;\n\n  constructor(prefix: string = '[Tool]', enabled: boolean = true) {\n    this.prefix = prefix;\n    this.enabled = enabled;\n  }\n\n  debug(message: string, ...args: unknown[]): void {\n    if (this.enabled && process.env.DEBUG === 'true') {\n      console.log(`${this.prefix} DEBUG:`, message, ...args);\n    }\n  }\n\n  info(message: string, ...args: unknown[]): void {\n    if (this.enabled) {\n      console.log(`${this.prefix} INFO:`, message, ...args);\n    }\n  }\n\n  warn(message: string, ...args: unknown[]): void {\n    if (this.enabled) {\n      console.warn(`${this.prefix} WARN:`, message, ...args);\n    }\n  }\n\n  error(message: string, ...args: unknown[]): void {\n    if (this.enabled) {\n      console.error(`${this.prefix} ERROR:`, message, ...args);\n    }\n  }\n}\n\n/**\n * Create a logger instance for a specific tool\n */\nexport function createToolLogger(toolId: string, enabled: boolean = true): ToolLogger {\n  // Disable logging in interactive mode to avoid interfering with TUI\n  const isInteractive = process.stdout.isTTY && !process.env.CI;\n  return isInteractive ? new NullLogger() : new ConsoleLogger(`[${toolId}]`, enabled);\n}\n\n/**\n * Null logger that discards all messages\n */\nexport class NullLogger implements ToolLogger {\n  debug(): void {\n    // No-op\n  }\n\n  info(): void {\n    // No-op\n  }\n\n  warn(): void {\n    // No-op\n  }\n\n  error(): void {\n    // No-op\n  }\n}","/**\n * Core tool registry implementation\n */\n\nimport {\n  ToolDefinition,\n  RegisteredTool,\n  ToolRegistry,\n  ToolArguments,\n  ToolFilter,\n  ValidationResult,\n  ToolContext,\n  CompositionPattern,\n  ComposedTool\n} from './types';\nimport { ToolResult } from '../types';\nimport { validateArguments } from './validation';\nimport { createComposedTool } from './composition';\nimport { ConfirmationService } from '../utils/confirmation-service';\nimport { createToolLogger } from './logger';\n\n/**\n * Main tool registry implementation\n */\nexport class ToolRegistryImpl implements ToolRegistry {\n  private tools = new Map<string, RegisteredTool>();\n  private context: ToolContext;\n  \n  constructor(workingDirectory: string = process.cwd()) {\n    this.context = {\n      registry: this,\n      workingDirectory,\n      confirmationService: ConfirmationService.getInstance(),\n      state: new Map()\n    };\n  }\n  \n  /**\n   * Register a new tool\n   */\n  register(tool: ToolDefinition): void {\n    if (this.tools.has(tool.id)) {\n      throw new Error(`Tool with id '${tool.id}' already registered`);\n    }\n    \n    this.tools.set(tool.id, {\n      definition: tool,\n      initialized: false,\n      executionCount: 0,\n      totalDuration: 0\n    });\n  }\n  \n  /**\n   * Unregister a tool\n   */\n  async unregister(toolId: string): Promise<void> {\n    const tool = this.tools.get(toolId);\n    if (!tool) {\n      throw new Error(`Tool '${toolId}' not found`);\n    }\n    \n    // Cleanup if needed\n    if (tool.definition.cleanup && tool.initialized) {\n      await tool.definition.cleanup(this.context);\n    }\n    \n    this.tools.delete(toolId);\n  }\n  \n  /**\n   * Get a registered tool\n   */\n  get(toolId: string): RegisteredTool | undefined {\n    return this.tools.get(toolId);\n  }\n  \n  /**\n   * List tools with optional filter\n   */\n  list(filter?: ToolFilter): ToolDefinition[] {\n    let tools = Array.from(this.tools.values()).map(t => t.definition);\n    \n    if (filter) {\n      if (filter.category) {\n        tools = tools.filter(t => t.category === filter.category);\n      }\n      \n      if (filter.capabilities && filter.capabilities.length > 0) {\n        tools = tools.filter(t => \n          t.capabilities && \n          filter.capabilities!.every(cap => t.capabilities!.includes(cap))\n        );\n      }\n      \n      if (filter.tags && filter.tags.length > 0) {\n        tools = tools.filter(t =>\n          t.tags &&\n          filter.tags!.some(tag => t.tags!.includes(tag))\n        );\n      }\n      \n      if (filter.composable !== undefined) {\n        tools = tools.filter(t => t.composable === filter.composable);\n      }\n    }\n    \n    return tools;\n  }\n  \n  /**\n   * Search tools by query\n   */\n  search(query: string): ToolDefinition[] {\n    const lowerQuery = query.toLowerCase();\n    return Array.from(this.tools.values())\n      .map(t => t.definition)\n      .filter(tool => {\n        const searchText = [\n          tool.id,\n          tool.name,\n          tool.description,\n          ...(tool.tags || [])\n        ].join(' ').toLowerCase();\n        \n        return searchText.includes(lowerQuery);\n      });\n  }\n  \n  /**\n   * Execute a tool\n   */\n  async execute(toolId: string, args: ToolArguments): Promise<ToolResult> {\n    const registeredTool = this.tools.get(toolId);\n    if (!registeredTool) {\n      return {\n        success: false,\n        error: `Tool '${toolId}' not found`\n      };\n    }\n    \n    const tool = registeredTool.definition;\n    \n    // Validate arguments\n    const validation = this.validateArguments(toolId, args);\n    if (!validation.valid) {\n      return {\n        success: false,\n        error: `Validation failed: ${validation.errors!.map(e => e.message).join(', ')}`\n      };\n    }\n    \n    // Initialize tool if needed\n    if (!registeredTool.initialized && tool.initialize) {\n      try {\n        const initContext: ToolContext = {\n          ...this.context,\n          logger: createToolLogger(toolId)\n        };\n        await tool.initialize(initContext);\n        registeredTool.initialized = true;\n      } catch (error) {\n        return {\n          success: false,\n          error: `Failed to initialize tool: ${error instanceof Error ? error.message : String(error)}`\n        };\n      }\n    }\n    \n    // Execute tool\n    const startTime = Date.now();\n    \n    try {\n      // Create a context with logger for this specific execution\n      const executionContext: ToolContext = {\n        ...this.context,\n        logger: createToolLogger(toolId)\n      };\n      \n      const result = await tool.execute(args, executionContext);\n      \n      // Update metrics\n      const duration = Date.now() - startTime;\n      registeredTool.executionCount++;\n      registeredTool.lastExecuted = new Date();\n      registeredTool.totalDuration += duration;\n      \n      return result;\n    } catch (error) {\n      return {\n        success: false,\n        error: `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n      };\n    }\n  }\n  \n  /**\n   * Create a composed tool\n   */\n  compose(pattern: CompositionPattern, toolIds: string[], config?: Record<string, unknown>): ComposedTool {\n    // Verify all tools exist\n    const tools = toolIds.map(id => {\n      const tool = this.get(id);\n      if (!tool) {\n        throw new Error(`Tool '${id}' not found for composition`);\n      }\n      return tool.definition;\n    });\n    \n    return createComposedTool(pattern, tools, config || {});\n  }\n  \n  /**\n   * Validate tool arguments\n   */\n  validateArguments(toolId: string, args: ToolArguments): ValidationResult {\n    const tool = this.get(toolId);\n    if (!tool) {\n      return {\n        valid: false,\n        errors: [{ field: 'toolId', message: `Tool '${toolId}' not found` }]\n      };\n    }\n    \n    return validateArguments(tool.definition.arguments || [], args);\n  }\n  \n  /**\n   * Get the registry context\n   */\n  getContext(): ToolContext {\n    return this.context;\n  }\n  \n  /**\n   * Update working directory\n   */\n  setWorkingDirectory(dir: string): void {\n    this.context.workingDirectory = dir;\n  }\n  \n  /**\n   * Get tool statistics\n   */\n  getStats(): {\n    totalTools: number;\n    byCategory: Record<string, number>;\n    byCapability: Record<string, number>;\n    mostUsed: Array<{ toolId: string; count: number }>;\n  } {\n    const tools = Array.from(this.tools.entries());\n    \n    const byCategory: Record<string, number> = {};\n    const byCapability: Record<string, number> = {};\n    \n    tools.forEach(([_, tool]) => {\n      const def = tool.definition;\n      \n      // Count by category\n      if (def.category) {\n        byCategory[def.category] = (byCategory[def.category] || 0) + 1;\n      }\n      \n      // Count by capability\n      if (def.capabilities) {\n        def.capabilities.forEach(cap => {\n          byCapability[cap] = (byCapability[cap] || 0) + 1;\n        });\n      }\n    });\n    \n    // Get most used tools\n    const mostUsed = tools\n      .map(([id, tool]) => ({ toolId: id, count: tool.executionCount }))\n      .filter(t => t.count > 0)\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n    \n    return {\n      totalTools: tools.length,\n      byCategory,\n      byCapability,\n      mostUsed\n    };\n  }\n\n  /**\n   * Get execution stats in the format expected by tests\n   */\n  getExecutionStats(): Record<string, { executionCount: number; totalDuration: number }> {\n    const stats: Record<string, { executionCount: number; totalDuration: number }> = {};\n    \n    this.tools.forEach((tool, id) => {\n      stats[id] = {\n        executionCount: tool.executionCount,\n        totalDuration: tool.totalDuration\n      };\n    });\n    \n    return stats;\n  }\n}\n\n/**\n * Create a new tool registry instance\n */\nexport function createToolRegistry(workingDirectory?: string): ToolRegistry {\n  return new ToolRegistryImpl(workingDirectory);\n}","/**\n * Tool builder for creating tools with a fluent API\n */\n\nimport {\n    ToolDefinition,\n    ToolMetadata,\n    ArgumentSpec,\n    ToolExecutor,\n    ToolContext,\n    ToolCategory,\n    ToolCapability,\n    Schema,\n    ToolResultRenderer,\n    ToolArguments\n} from './types';\n\n/**\n * Builder for creating tool definitions\n */\nexport class ToolBuilder {\n    private metadata: Partial<ToolMetadata> = {};\n    private args: ArgumentSpec[] = [];\n    private executor?: ToolExecutor;\n    private initHook?: (context: ToolContext) => Promise<void>;\n    private cleanupHook?: (context: ToolContext) => Promise<void>;\n    private schemas: { input?: Schema; output?: Schema } = {};\n    private isComposable?: boolean;\n    private renderer?: ToolResultRenderer;\n    private examplesList?: { description: string; arguments: ToolArguments; result?: string }[];\n\n    /**\n     * Set tool ID (required)\n     */\n    id(id: string): ToolBuilder {\n        this.metadata.id = id;\n        return this;\n    }\n\n    /**\n     * Set tool name\n     */\n    name(name: string): ToolBuilder {\n        this.metadata.name = name;\n        return this;\n    }\n\n    /**\n     * Set tool description\n     */\n    description(description: string): ToolBuilder {\n        this.metadata.description = description;\n        return this;\n    }\n\n    /**\n     * Set tool version\n     */\n    version(version: string): ToolBuilder {\n        this.metadata.version = version;\n        return this;\n    }\n\n    /**\n     * Set tool author\n     */\n    author(author: string): ToolBuilder {\n        this.metadata.author = author;\n        return this;\n    }\n\n    /**\n     * Set tool category\n     */\n    category(category: ToolCategory): ToolBuilder {\n        this.metadata.category = category;\n        return this;\n    }\n\n    /**\n     * Add tags\n     */\n    tags(...tags: string[]): ToolBuilder {\n        this.metadata.tags = [...(this.metadata.tags || []), ...tags];\n        return this;\n    }\n\n    /**\n     * Add capabilities\n     */\n    capabilities(...capabilities: ToolCapability[]): ToolBuilder {\n        this.metadata.capabilities = [...(this.metadata.capabilities || []), ...capabilities];\n        return this;\n    }\n\n    /**\n     * Add an argument\n     */\n    argument(spec: ArgumentSpec): ToolBuilder {\n        this.args.push(spec);\n        return this;\n    }\n\n    /**\n     * Add a string argument (convenience method)\n     */\n    stringArg(name: string, description: string, options?: {\n        required?: boolean;\n        default?: string;\n        enum?: string[];\n        validate?: (value: string) => true | string;\n    }): ToolBuilder {\n        return this.argument({\n            name,\n            type: 'string',\n            description,\n            ...options\n        });\n    }\n\n    /**\n     * Add a number argument (convenience method)\n     */\n    numberArg(name: string, description: string, options?: {\n        required?: boolean;\n        default?: number;\n        validate?: (value: number) => true | string;\n    }): ToolBuilder {\n        return this.argument({\n            name,\n            type: 'number',\n            description,\n            ...options\n        });\n    }\n\n    /**\n     * Add a boolean argument (convenience method)\n     */\n    booleanArg(name: string, description: string, options?: {\n        required?: boolean;\n        default?: boolean;\n    }): ToolBuilder {\n        return this.argument({\n            name,\n            type: 'boolean',\n            description,\n            ...options\n        });\n    }\n\n    /**\n     * Add an array argument (convenience method)\n     */\n    arrayArg(name: string, description: string, options?: {\n        required?: boolean;\n        default?: unknown[];\n        validate?: (value: unknown[]) => boolean | string;\n    }): ToolBuilder {\n        return this.argument({\n            name,\n            type: 'array',\n            description,\n            ...options\n        });\n    }\n\n    /**\n     * Set input schema for composition\n     */\n    inputSchema(schema: Schema): ToolBuilder {\n        this.schemas.input = schema;\n        return this;\n    }\n\n    /**\n     * Set output schema for composition\n     */\n    outputSchema(schema: Schema): ToolBuilder {\n        this.schemas.output = schema;\n        return this;\n    }\n\n    /**\n     * Make tool composable\n     */\n    composable(value: boolean = true): ToolBuilder {\n        this.isComposable = value;\n        return this;\n    }\n\n    /**\n     * Set execution function\n     */\n    execute(executor: ToolExecutor): ToolBuilder {\n        this.executor = executor;\n        return this;\n    }\n\n    /**\n     * Set initialization hook\n     */\n    onInitialize(hook: (context: ToolContext) => Promise<void>): ToolBuilder {\n        this.initHook = hook;\n        return this;\n    }\n\n    /**\n     * Set cleanup hook\n     */\n    onCleanup(hook: (context: ToolContext) => Promise<void>): ToolBuilder {\n        this.cleanupHook = hook;\n        return this;\n    }\n\n    /**\n     * Set custom result renderer\n     */\n    renderResult(renderer: ToolResultRenderer): ToolBuilder {\n        this.renderer = renderer;\n        return this;\n    }\n\n    /**\n     * Add examples for better AI understanding\n     */\n    examples(examples: { description: string; arguments: ToolArguments; result?: string }[]): ToolBuilder {\n        this.examplesList = examples;\n        return this;\n    }\n\n    /**\n     * Build the tool definition\n     */\n    build(): ToolDefinition {\n        if (!this.metadata.id) {\n            throw new Error('Tool ID is required');\n        }\n\n        if (!this.metadata.name) {\n            this.metadata.name = this.metadata.id;\n        }\n\n        if (!this.metadata.description) {\n            throw new Error('Tool description is required');\n        }\n\n        if (!this.executor) {\n            throw new Error('Tool executor is required');\n        }\n\n        const tool: ToolDefinition = {\n            id: this.metadata.id,\n            name: this.metadata.name,\n            description: this.metadata.description,\n            version: this.metadata.version,\n            author: this.metadata.author,\n            tags: this.metadata.tags,\n            category: this.metadata.category,\n            capabilities: this.metadata.capabilities,\n            arguments: this.args.length > 0 ? this.args : undefined,\n            execute: this.executor,\n            composable: this.isComposable,\n            inputSchema: this.schemas.input,\n            outputSchema: this.schemas.output,\n            renderResult: this.renderer,\n            examples: this.examplesList\n        };\n\n        if (this.initHook) {\n            tool.initialize = this.initHook;\n        }\n\n        if (this.cleanupHook) {\n            tool.cleanup = this.cleanupHook;\n        }\n\n        return tool;\n    }\n}\n\n/**\n * Create a new tool builder\n */\nexport function createTool(): ToolBuilder {\n    return new ToolBuilder();\n}\n","/**\n * Adapters for converting between tool formats\n */\n\nimport { GrokTool } from '../clanker/client';\nimport {\n  ToolDefinition,\n  ArgumentSpec,\n  ToolCapability,\n  ToolRegistry,\n  ToolArguments,\n  ToolContext\n} from './types';\nimport { ToolResult } from '../types';\nimport { applyDefaults, coerceArguments } from './validation';\n\n/**\n * Convert a ToolDefinition to GrokTool format\n */\nexport function toolDefinitionToGrokTool(tool: ToolDefinition): GrokTool {\n  const properties: Record<string, unknown> = {};\n  const required: string[] = [];\n  \n  // Convert arguments to OpenAI function parameter format\n  if (tool.arguments) {\n    for (const arg of tool.arguments) {\n      properties[arg.name] = argumentSpecToProperty(arg);\n      \n      if (arg.required) {\n        required.push(arg.name);\n      }\n    }\n  }\n  \n  return {\n    type: \"function\",\n    function: {\n      name: tool.id,\n      description: generateToolDescription(tool),\n      parameters: {\n        type: \"object\",\n        properties,\n        required\n      }\n    }\n  };\n}\n\n/**\n * Convert ArgumentSpec to OpenAI property format\n */\nfunction argumentSpecToProperty(arg: ArgumentSpec): Record<string, unknown> {\n  const property: Record<string, unknown> = {\n    type: mapArgumentType(arg.type),\n    description: arg.description\n  };\n  \n  // Add enum values\n  if (arg.enum) {\n    property.enum = arg.enum;\n  }\n  \n  // Add default value\n  if (arg.default !== undefined) {\n    property.default = arg.default;\n  }\n  \n  return property;\n}\n\n/**\n * Map argument types to OpenAI types\n */\nfunction mapArgumentType(type: string): string {\n  switch (type) {\n    case 'any':\n      return 'string'; // OpenAI doesn't have 'any', use string as fallback\n    default:\n      return type;\n  }\n}\n\n/**\n * Generate a comprehensive description from ToolDefinition\n */\nfunction generateToolDescription(tool: ToolDefinition): string {\n  const parts: string[] = [tool.description];\n  \n  // Add capability information\n  if (tool.capabilities && tool.capabilities.length > 0) {\n    const capabilities = tool.capabilities\n      .map(cap => describeCapability(cap))\n      .filter(desc => desc)\n      .join(', ');\n    \n    if (capabilities) {\n      parts.push(`Capabilities: ${capabilities}`);\n    }\n  }\n  \n  // Add tags\n  if (tool.tags && tool.tags.length > 0) {\n    parts.push(`Tags: ${tool.tags.join(', ')}`);\n  }\n  \n  // Add examples\n  if (tool.examples && tool.examples.length > 0) {\n    parts.push('\\n\\nExamples:');\n    tool.examples.forEach((example, index) => {\n      parts.push(`\\nExample ${index + 1}: ${example.description}`);\n      parts.push(`Arguments: ${JSON.stringify(example.arguments, null, 2)}`);\n      if (example.result) {\n        parts.push(`Expected result: ${example.result}`);\n      }\n    });\n  }\n  \n  return parts.join('. ');\n}\n\n/**\n * Describe a capability in natural language\n */\nfunction describeCapability(capability: ToolCapability): string {\n  const descriptions: Record<ToolCapability, string> = {\n    [ToolCapability.FileRead]: 'read files',\n    [ToolCapability.FileWrite]: 'write files',\n    [ToolCapability.SystemExecute]: 'execute system commands',\n    [ToolCapability.NetworkAccess]: 'access network resources',\n    [ToolCapability.UserConfirmation]: 'request user confirmation'\n  };\n  \n  return descriptions[capability] || '';\n}\n\n/**\n * Generate all Grok tools from registry\n */\nexport function generateGrokTools(registry: ToolRegistry): GrokTool[] {\n  const tools = registry.list();\n  return tools.map(tool => toolDefinitionToGrokTool(tool));\n}\n\n/**\n * Create a legacy tool wrapper for backward compatibility\n */\nexport function createLegacyToolWrapper(\n  tool: ToolDefinition,\n  context: ToolContext\n): { name: string; description: string; execute: (...args: unknown[]) => Promise<ToolResult> } {\n  return {\n    name: tool.name,\n    description: tool.description,\n    \n    execute: async (...args: unknown[]): Promise<ToolResult> => {\n      // Convert positional arguments to named arguments\n      let namedArgs: ToolArguments = {};\n      \n      if (tool.arguments && args.length > 0) {\n        // If first arg is an object and we have multiple args defined,\n        // assume it contains all named arguments\n        if (typeof args[0] === 'object' && !Array.isArray(args[0]) && \n            tool.arguments.length > 1) {\n          namedArgs = args[0] as ToolArguments;\n        } else {\n          // Map positional args to named args\n          tool.arguments.forEach((spec, index) => {\n            if (index < args.length) {\n              namedArgs[spec.name] = args[index];\n            }\n          });\n        }\n      }\n      \n      // Apply defaults and coercion\n      namedArgs = applyDefaults(tool.arguments || [], namedArgs);\n      namedArgs = coerceArguments(tool.arguments || [], namedArgs);\n      \n      // Execute with context\n      return tool.execute(namedArgs, context);\n    }\n  };\n}\n\n/**\n * Create a tool execution wrapper for Grok agent\n */\nexport function createToolExecutor(registry: ToolRegistry) {\n  return async (toolName: string, args: unknown): Promise<ToolResult> => {\n    // Parse arguments if they come as a string\n    let parsedArgs = args;\n    if (typeof args === 'string') {\n      try {\n        parsedArgs = JSON.parse(args);\n      } catch {\n        parsedArgs = { input: args };\n      }\n    }\n    \n    return registry.execute(toolName, parsedArgs as ToolArguments);\n  };\n}\n\n/**\n * Create dynamic tool descriptions for prompts\n */\nexport function generateToolPromptSection(tools: ToolDefinition[]): string {\n  const sections: string[] = [\n    `You have access to ${tools.length} tools:`\n  ];\n  \n  // Group tools by category\n  const byCategory = new Map<string, ToolDefinition[]>();\n  const uncategorized: ToolDefinition[] = [];\n  \n  for (const tool of tools) {\n    if (tool.category) {\n      const existing = byCategory.get(tool.category) || [];\n      existing.push(tool);\n      byCategory.set(tool.category, existing);\n    } else {\n      uncategorized.push(tool);\n    }\n  }\n  \n  // Add categorized tools\n  for (const [category, categoryTools] of byCategory) {\n    sections.push(`\\n## ${category.charAt(0).toUpperCase() + category.slice(1)} Tools\\n`);\n    \n    for (const tool of categoryTools) {\n      sections.push(formatToolForPrompt(tool));\n    }\n  }\n  \n  // Add uncategorized tools\n  if (uncategorized.length > 0) {\n    sections.push('\\n## Other Tools\\n');\n    \n    for (const tool of uncategorized) {\n      sections.push(formatToolForPrompt(tool));\n    }\n  }\n  \n  // Add usage instructions\n  sections.push('\\n## Tool Usage\\n');\n  sections.push('- Always check tool arguments before calling');\n  sections.push('- Handle tool errors gracefully');\n  sections.push('- Use appropriate tools for the task');\n  sections.push('- Combine tools when needed for complex tasks');\n  \n  return sections.join('\\n');\n}\n\n/**\n * Format a single tool for prompt\n */\nfunction formatToolForPrompt(tool: ToolDefinition): string {\n  const lines: string[] = [\n    `### ${tool.name}`,\n    tool.description\n  ];\n  \n  if (tool.arguments && tool.arguments.length > 0) {\n    lines.push('\\nArguments:');\n    \n    for (const arg of tool.arguments) {\n      const required = arg.required ? ' (required)' : ' (optional)';\n      const defaultStr = arg.default !== undefined ? `, default: ${JSON.stringify(arg.default)}` : '';\n      \n      lines.push(`- ${arg.name}: ${arg.type}${required} - ${arg.description}${defaultStr}`);\n      \n      if (arg.enum) {\n        lines.push(`  Allowed values: ${arg.enum.join(', ')}`);\n      }\n    }\n  }\n  \n  if (tool.capabilities && tool.capabilities.length > 0) {\n    lines.push(`\\nRequires: ${tool.capabilities.map(c => describeCapability(c)).join(', ')}`);\n  }\n  \n  return lines.join('\\n');\n}\n","/**\n * Built-in tools registry\n * \n * As of v1.1.31, all core tools are now installed via the package manager\n * rather than being built into the CLI. This provides better modularity\n * and allows tools to be updated independently.\n * \n * This file remains for backward compatibility but exports empty arrays.\n */\n\nimport { ToolDefinition } from './types';\n\n// Array of all built-in tools - now empty as tools are loaded dynamically\nexport const builtInTools: ToolDefinition[] = [];\n\n// Map for quick lookup - now empty\nexport const builtInToolsMap = new Map<string, ToolDefinition>();","/**\n * Manifest-based tool loader for built-in tools\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { fileURLToPath } from 'url';\nimport { ToolDefinition } from './types';\nimport { debug } from '../utils/debug-logger';\n\ninterface ToolManifest {\n  version: string;\n  generated: string;\n  tools: Array<{\n    id: string;\n    module: string;\n  }>;\n}\n\nexport async function loadBuiltInToolsFromManifest(): Promise<ToolDefinition[]> {\n  const tools: ToolDefinition[] = [];\n  \n  try {\n    // Determine the base directory\n    let baseDir: string;\n    \n    // Check if we're in a bundled environment\n    if (typeof __dirname !== 'undefined') {\n      // CommonJS environment\n      baseDir = __dirname;\n    } else if (typeof import.meta.url !== 'undefined') {\n      // ES module environment\n      const __filename = fileURLToPath(import.meta.url);\n      baseDir = path.dirname(__filename);\n    } else {\n      // Fallback\n      baseDir = process.cwd();\n    }\n    \n    // Look for manifest in dist directory\n    // In bundled environment, we're in dist/index.js, so manifest is in same directory\n    // In dev environment, we're in src/registry/, so go up to find dist/\n    let manifestPath = path.join(baseDir, 'tool-manifest.json');\n    \n    if (!fs.existsSync(manifestPath)) {\n      // Try going up from registry folder (dev environment)\n      manifestPath = path.join(baseDir, '..', '..', 'dist', 'tool-manifest.json');\n    }\n    \n    debug.log(`[ManifestLoader] Looking for manifest at: ${manifestPath}`);\n    \n    if (!fs.existsSync(manifestPath)) {\n      debug.warn('[ManifestLoader] No tool manifest found, falling back to static imports');\n      // Fall back to using the static builtin-tools.ts\n      const { builtInTools } = await import('./builtin-tools');\n      return builtInTools;\n    }\n    \n    // Read and parse manifest\n    const manifestContent = fs.readFileSync(manifestPath, 'utf-8');\n    const manifest: ToolManifest = JSON.parse(manifestContent);\n    \n    debug.log(`[ManifestLoader] Found manifest with ${manifest.tools.length} tools`);\n    \n    // Load each tool from the manifest\n    for (const toolInfo of manifest.tools) {\n      try {\n        // In bundled environment, modules are relative to dist/\n        // In dev environment, they're relative to dist/ as well\n        const modulePath = path.isAbsolute(toolInfo.module) \n          ? toolInfo.module \n          : path.join(path.dirname(manifestPath), toolInfo.module);\n        debug.log(`[ManifestLoader] Loading tool ${toolInfo.id} from ${modulePath}`);\n        \n        // Dynamic import\n        const module = await import(modulePath);\n        const tool = module.default || module;\n        \n        if (isValidTool(tool)) {\n          tools.push(tool);\n          debug.log(`[ManifestLoader] Successfully loaded tool: ${tool.id}`);\n        } else {\n          debug.warn(`[ManifestLoader] Invalid tool in ${modulePath}`);\n        }\n      } catch (error) {\n        debug.error(`[ManifestLoader] Failed to load tool ${toolInfo.id}:`, error);\n      }\n    }\n    \n    debug.log(`[ManifestLoader] Loaded ${tools.length} tools from manifest`);\n    return tools;\n    \n  } catch (error) {\n    debug.error('[ManifestLoader] Error loading manifest:', error);\n    // Fall back to static imports\n    const { builtInTools } = await import('./builtin-tools');\n    return builtInTools;\n  }\n}\n\nfunction isValidTool(obj: any): obj is ToolDefinition {\n  return obj && \n         typeof obj === 'object' &&\n         typeof obj.id === 'string' &&\n         typeof obj.description === 'string' &&\n         typeof obj.execute === 'function';\n}","/**\n * Dynamic tool loader with clean, reusable directory scanning\n */\n\nimport * as fs from 'fs/promises';\nimport * as fsSync from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport * as crypto from 'crypto';\nimport {pathToFileURL} from 'url';\nimport {ToolDefinition, ToolRegistry} from './types';\nimport {debug} from '../utils/debug-logger';\nimport {loadBuiltInToolsFromManifest} from './manifest-loader';\n\n/**\n * Check if a module should be shared from the main clanker package\n */\nfunction shouldShareDependency(request: string): boolean {\n    // Share React and Ink\n    if (request === 'react' || request === 'ink' || request.startsWith('ink/')) {\n        return true;\n    }\n\n    // Share @ziggler/clanker and its exports\n    if (request === '@ziggler/clanker' || request.startsWith('@ziggler/clanker/')) {\n        return true;\n    }\n\n    // Share relative imports that are part of clanker's internal structure\n    if (request.startsWith('../../registry') || request.startsWith('../../utils/') ||\n        request.startsWith('../../ui/') || request.startsWith('../../store/')) {\n        return true;\n    }\n\n    // Share other common dependencies that tools might need\n    const sharedDeps = [\n        'chalk', 'fs-extra', 'zod', 'commander', 'dotenv',\n        'openai', 'axios', 'uuid', 'prismjs', 'immer'\n    ];\n\n    return sharedDeps.includes(request);\n}\n\n/**\n * Options for loading tools\n */\nexport interface LoaderOptions {\n    /**\n     * Base directories to search for tools\n     * Defaults to ['.', '~/.clank']\n     */\n    directories?: string[];\n\n    /**\n     * Whether to search recursively\n     * Defaults to true\n     */\n    recursive?: boolean;\n\n    /**\n     * File extensions to load\n     * Defaults to ['.ts', '.tsx', '.js', '.jsx']\n     */\n    extensions?: string[];\n\n    /**\n     * Whether to watch for changes\n     */\n    watch?: boolean;\n\n    /**\n     * Whether to load built-in tools\n     * Defaults to true\n     */\n    loadBuiltins?: boolean;\n}\n\n/**\n * Tool loader for dynamic tool discovery\n */\nexport class ToolLoader {\n    private options: Required<LoaderOptions>;\n    private loadedTools = new Map<string, { path: string; hash: string }>(); // toolId -> {filePath, hash}\n    private watcherCleanup: (() => void)[] = [];\n    private fileWatchers = new Map<string, fsSync.FSWatcher>(); // filePath -> watcher\n\n    constructor(private registry: ToolRegistry, options: LoaderOptions = {}) {\n        // Get user home directory in a cross-platform way\n        const homeDir = os.homedir();\n        const clankDir = path.join(homeDir, '.clanker');\n\n        this.options = {\n            directories: options.directories || [process.cwd(), clankDir],\n            recursive: options.recursive ?? true,\n            extensions: options.extensions || ['.ts', '.tsx', '.js', '.jsx'],\n            watch: options.watch ?? false,\n            loadBuiltins: options.loadBuiltins ?? true\n        };\n\n        debug.log(`[ToolLoader] Configured directories:`, this.options.directories);\n    }\n\n    /**\n     * Load all tools from configured directories\n     */\n    async loadTools(): Promise<void> {\n        // Load built-in tools first if enabled\n        if (this.options.loadBuiltins) {\n            await this.loadBuiltinTools();\n        }\n\n        // Load from each configured directory\n        for (const dir of this.options.directories) {\n            const toolsDir = path.join(dir, dir.endsWith('tools') ? '' : 'tools');\n            debug.log(`[ToolLoader] Loading from directory: ${dir} -> ${toolsDir}`);\n            await this.loadFromDirectory(toolsDir);\n        }\n\n        // Set up watchers if enabled\n        if (this.options.watch) {\n            await this.setupWatchers();\n        }\n    }\n\n    /**\n     * Load built-in tools from the package\n     */\n    private async loadBuiltinTools(): Promise<void> {\n        try {\n            // Try to load from manifest first, fall back to static imports\n            const tools = await loadBuiltInToolsFromManifest();\n\n            debug.log(`[ToolLoader] Loading ${tools.length} built-in tools`);\n\n            // Register all built-in tools directly\n            for (const tool of tools) {\n                if (this.isValidTool(tool)) {\n                    this.registry.register(tool);\n                    const registeredTool = this.registry.get(tool.id);\n                    if (registeredTool) {\n                        registeredTool.hash = 'builtin';\n                        registeredTool.filePath = `builtin:${tool.id}`;\n                    }\n                    this.loadedTools.set(tool.id, {path: `builtin:${tool.id}`, hash: 'builtin'});\n                    debug.log(`[ToolLoader] Loaded built-in tool: ${tool.id}`);\n                } else {\n                    debug.warn(`[ToolLoader] Invalid built-in tool`);\n                }\n            }\n\n            debug.log(`[ToolLoader] Successfully loaded ${tools.length} built-in tools`);\n        } catch (error) {\n            debug.warn('[ToolLoader] Failed to load built-in tools:', error);\n        }\n    }\n\n    /**\n     * Load tools from a directory\n     */\n    private async loadFromDirectory(directory: string): Promise<void> {\n        // Early return if directory doesn't exist\n        if (!await this.exists(directory)) {\n            debug.log(`[ToolLoader] Directory does not exist: ${directory}`);\n            return;\n        }\n\n        debug.log(`[ToolLoader] Scanning directory: ${directory}`);\n        try {\n            await this.scanDirectory(directory, this.options.recursive);\n        } catch (error) {\n            debug.error(`[ToolLoader] Error scanning directory ${directory}:`, error);\n        }\n    }\n\n    /**\n     * Recursively scan a directory for tool files\n     */\n    private async scanDirectory(directory: string, recursive: boolean): Promise<void> {\n        let entries: fsSync.Dirent[];\n\n        try {\n            entries = await fs.readdir(directory, {withFileTypes: true});\n        } catch (error) {\n            // Directory not accessible, skip silently\n            return;\n        }\n\n        // Check if this is a package-managed tool directory with 'current' symlink\n        const currentLink = entries.find(entry => entry.name === 'current' && entry.isSymbolicLink());\n        if (currentLink) {\n            // This is a versioned tool directory, load from current version\n            const currentPath = path.join(directory, 'current', 'index.js');\n            if (await this.exists(currentPath)) {\n                debug.log(`[ToolLoader] Found package-managed tool at ${currentPath}`);\n                await this.loadToolFile(currentPath);\n                return; // Don't scan subdirectories for versioned tools\n            }\n        }\n\n        // Process files first\n        const files = entries\n            .filter(entry => entry.isFile() && this.isToolFile(entry.name))\n            .map(entry => path.join(directory, entry.name));\n\n        debug.log(`[ToolLoader] Found ${files.length} tool files in ${directory}`);\n        for (const file of files) {\n            await this.loadToolFile(file);\n        }\n\n        // Process subdirectories if recursive\n        if (!recursive) return;\n\n        const subdirs = entries\n            .filter(entry => entry.isDirectory())\n            .map(entry => path.join(directory, entry.name));\n\n        for (const subdir of subdirs) {\n            await this.scanDirectory(subdir, true);\n        }\n    }\n\n    /**\n     * Load a single tool file\n     */\n    private async loadToolFile(filePath: string): Promise<void> {\n        try {\n            debug.log(`[ToolLoader] Attempting to load: ${filePath}`);\n\n            // Compute file hash\n            const fileHash = await this.computeFileHash(filePath);\n            debug.log(`[ToolLoader] File hash for ${filePath}: ${fileHash.substring(0, 8)}...`);\n\n            // Check if tool is already loaded with same hash\n            const existingEntry = Array.from(this.loadedTools.entries())\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                .find(([_, info]) => info.path === filePath);\n\n            if (existingEntry && existingEntry[1].hash === fileHash) {\n                debug.log(`[ToolLoader] Tool already loaded with same version: ${existingEntry[0]}`);\n                return;\n            }\n\n            // Dynamic import\n            const moduleExports = await this.importModule(filePath);\n            debug.log(`[ToolLoader] Module exports for ${filePath}:`, Object.keys(moduleExports));\n\n            const tool = await this.extractTool(moduleExports);\n\n            if (!tool) {\n                debug.warn(`[ToolLoader] No valid tool found in ${filePath}`);\n                return;\n            }\n\n            debug.log(`[ToolLoader] Extracted tool:`, {id: tool.id, name: tool.name});\n\n            // Validate tool\n            if (!this.isValidTool(tool)) {\n                debug.warn(`[ToolLoader] Invalid tool in ${filePath}`);\n                return;\n            }\n\n            // Unload old version if exists\n            if (this.loadedTools.has(tool.id)) {\n                const oldInfo = this.loadedTools.get(tool.id)!;\n                if (oldInfo.hash !== fileHash) {\n                    debug.log(`[ToolLoader] Tool ${tool.id} has changed, unloading old version`);\n                    await this.unloadTool(tool.id);\n                } else {\n                    debug.log(`[ToolLoader] Tool ${tool.id} unchanged, skipping reload`);\n                    return;\n                }\n            }\n\n            // Register the tool with hash info\n            this.registry.register(tool);\n            const registeredTool = this.registry.get(tool.id);\n            if (registeredTool) {\n                registeredTool.hash = fileHash;\n                registeredTool.filePath = filePath;\n            }\n\n            this.loadedTools.set(tool.id, {path: filePath, hash: fileHash});\n\n            debug.log(`[ToolLoader] Loaded tool: ${tool.id} from ${filePath}`);\n        } catch (error) {\n            debug.error(`[ToolLoader] Failed to load ${filePath}:`, error);\n        }\n    }\n\n    /**\n     * Import a module handling TypeScript if needed\n     */\n    private async importModule(filePath: string): Promise<any> {\n        try {\n            // For .js files in production, try different approaches\n            if (filePath.endsWith('.js')) {\n                // First try createRequire which works in ESM context\n                try {\n                    const {createRequire} = await import('module');\n                    // Use process.cwd() as fallback if import.meta.url is not available\n                    const baseUrl = typeof import.meta !== 'undefined' && import.meta.url\n                        ? import.meta.url\n                        : pathToFileURL(process.cwd() + '/').href;\n                    const require = createRequire(baseUrl);\n\n                    // Set up custom module resolution for shared dependencies\n                    const loadedModule = this.loadWithSharedDependencies(require, filePath);\n\n                    debug.log(`[ToolLoader] Loaded ${filePath} using createRequire with shared deps`);\n                    return loadedModule;\n                } catch (error) {\n                    debug.log(`[ToolLoader] createRequire failed for ${filePath}:`, error);\n                }\n\n                // Try Node.js require directly (for CommonJS modules)\n                try {\n                    // Use eval to avoid bundler trying to resolve require\n                    const requireFunc = eval('require');\n                    const loadedModule = this.loadWithSharedDependencies(requireFunc, filePath);\n                    debug.log(`[ToolLoader] Loaded ${filePath} using direct require with shared deps`);\n                    return loadedModule;\n                } catch (error) {\n                    debug.log(`[ToolLoader] Direct require failed for ${filePath}:`, error);\n                }\n\n                // Try dynamic import with file URL\n                try {\n                    const fileUrl = pathToFileURL(filePath).href;\n                    const module = await import(fileUrl);\n                    debug.log(`[ToolLoader] Loaded ${filePath} using dynamic import`);\n                    return module;\n                } catch (error) {\n                    debug.log(`[ToolLoader] Dynamic import failed for ${filePath}:`, error);\n                }\n            }\n\n            // For TypeScript files (.ts, .tsx), use dynamic import\n            const fileUrl = pathToFileURL(filePath).href;\n            const module = await import(fileUrl);\n            return module;\n        } catch (error) {\n            debug.error(`[ToolLoader] Import error for ${filePath}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Extract tool from module exports\n     */\n    private async extractTool(moduleExports: any): Promise<ToolDefinition | null> {\n        // Handle default export\n        if (moduleExports.default) {\n            const defaultExport = moduleExports.default;\n\n            // If it's a function, call it\n            if (typeof defaultExport === 'function') {\n                try {\n                    const result = await defaultExport();\n                    if (this.isValidTool(result)) return result;\n                } catch {\n                    // Function might not be callable, try as tool\n                    if (this.isValidTool(defaultExport)) {\n                        return defaultExport;\n                    }\n                }\n            }\n\n            // If it's already a tool\n            if (this.isValidTool(defaultExport)) {\n                return defaultExport;\n            }\n\n            // If it's an array of tools, take the first one\n            if (Array.isArray(defaultExport) && defaultExport.length > 0) {\n                const firstTool = defaultExport[0];\n                if (this.isValidTool(firstTool)) return firstTool;\n            }\n        }\n\n        // Handle named exports\n        const namedExports = ['tool', 'createTool'];\n        for (const exportName of namedExports) {\n            if (exportName in moduleExports) {\n                const exported = moduleExports[exportName];\n\n                if (typeof exported === 'function') {\n                    try {\n                        const result = await exported();\n                        if (this.isValidTool(result)) return result;\n                    } catch {\n                        // Not callable\n                    }\n                }\n\n                if (this.isValidTool(exported)) {\n                    return exported;\n                }\n            }\n        }\n\n        // Check if the module itself is a tool\n        if (this.isValidTool(moduleExports)) {\n            return moduleExports;\n        }\n\n        return null;\n    }\n\n    /**\n     * Validate if an object is a valid tool\n     */\n    private isValidTool(obj: any): obj is ToolDefinition {\n        return obj &&\n            typeof obj === 'object' &&\n            typeof obj.id === 'string' &&\n            typeof obj.description === 'string' &&\n            typeof obj.execute === 'function';\n    }\n\n    /**\n     * Check if a file should be loaded as a tool\n     */\n    private isToolFile(filename: string): boolean {\n        return this.options.extensions.some(ext => filename.endsWith(ext));\n    }\n\n    /**\n     * Check if a path exists\n     */\n    private async exists(path: string): Promise<boolean> {\n        try {\n            await fs.access(path);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Compute hash of a file\n     */\n    private async computeFileHash(filePath: string): Promise<string> {\n        try {\n            const content = await fs.readFile(filePath);\n            return crypto.createHash('sha256').update(content).digest('hex');\n        } catch (error) {\n            debug.error(`[ToolLoader] Failed to compute hash for ${filePath}:`, error);\n            return '';\n        }\n    }\n\n    /**\n     * Unload a tool and run cleanup\n     */\n    private async unloadTool(toolId: string): Promise<void> {\n        debug.log(`[ToolLoader] Unloading tool: ${toolId}`);\n\n        const tool = this.registry.get(toolId);\n        if (tool && tool.definition.cleanup) {\n            try {\n                const context = {\n                    registry: this.registry,\n                    workingDirectory: process.cwd()\n                };\n                await tool.definition.cleanup(context);\n                debug.log(`[ToolLoader] Cleanup completed for ${toolId}`);\n            } catch (error) {\n                debug.error(`[ToolLoader] Cleanup failed for ${toolId}:`, error);\n            }\n        }\n\n        // Unregister from registry\n        await this.registry.unregister(toolId);\n\n        // Remove from loaded tools\n        this.loadedTools.delete(toolId);\n    }\n\n    /**\n     * Reload all tools (for --watch-tools command)\n     */\n    async reloadAllTools(): Promise<void> {\n        debug.log('[ToolLoader] Reloading all tools...');\n\n        // Unload all currently loaded tools\n        const toolIds = Array.from(this.loadedTools.keys());\n        for (const toolId of toolIds) {\n            // Skip built-in tools\n            if (this.loadedTools.get(toolId)?.path.startsWith('builtin:')) {\n                continue;\n            }\n            await this.unloadTool(toolId);\n        }\n\n        // Clear module cache for dynamic imports\n        if (typeof require !== 'undefined' && require.cache) {\n            for (const [toolId, info] of this.loadedTools) {\n                if (info.path && !info.path.startsWith('builtin:')) {\n                    delete require.cache[info.path];\n                }\n            }\n        }\n\n        // Reload all tools\n        await this.loadTools();\n\n        debug.log('[ToolLoader] Tool reload complete');\n    }\n\n    /**\n     * Set up file watchers for hot reloading\n     */\n    private async setupWatchers(): Promise<void> {\n        const {watch} = await import('fs');\n\n        for (const dir of this.options.directories) {\n            const toolsDir = path.join(dir, dir.endsWith('tools') ? '' : 'tools');\n\n            if (!await this.exists(toolsDir)) continue;\n\n            const watcher = watch(toolsDir, {recursive: true}, async (eventType, filename) => {\n                if (!filename || !this.isToolFile(filename)) return;\n\n                const filePath = path.join(toolsDir, filename);\n\n                try {\n                    const stats = await fs.stat(filePath);\n                    if (stats.isFile()) {\n                        debug.log(`[ToolLoader] Reloading ${filename}...`);\n                        await this.loadToolFile(filePath);\n                    }\n                } catch {\n                    // File was deleted, unregister if loaded\n                    const toolId = this.findToolByPath(filePath);\n                    if (toolId) {\n                        await this.registry.unregister(toolId);\n                        this.loadedTools.delete(toolId);\n                        debug.log(`[ToolLoader] Unregistered ${toolId}`);\n                    }\n                }\n            });\n\n            // Store cleanup function\n            this.watcherCleanup.push(() => watcher.close());\n        }\n    }\n\n    /**\n     * Find tool ID by file path\n     */\n    private findToolByPath(filePath: string): string | undefined {\n        for (const [toolId, info] of this.loadedTools.entries()) {\n            if (info.path === filePath) return toolId;\n        }\n        return undefined;\n    }\n\n    /**\n     * Get loaded tools info\n     */\n    getLoadedTools(): Array<{ toolId: string; filePath: string; hash: string }> {\n        return Array.from(this.loadedTools.entries()).map(([toolId, info]) => ({\n            toolId,\n            filePath: info.path,\n            hash: info.hash\n        }));\n    }\n\n    /**\n     * Reload all tools\n     */\n    async reloadTools(): Promise<void> {\n        debug.log('[ToolLoader] Reloading all tools...');\n\n        // Store current tools\n        const currentTools = new Map(this.loadedTools);\n\n        // Clear loaded tools\n        this.loadedTools.clear();\n\n        // Reload each tool\n        for (const [_, info] of currentTools) {\n            if (!info.path.startsWith('builtin:')) {\n                await this.loadToolFile(info.path);\n            }\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    async cleanup(): Promise<void> {\n        // Close all watchers\n        for (const cleanup of this.watcherCleanup) {\n            cleanup();\n        }\n        this.watcherCleanup = [];\n\n        // Clear loaded tools\n        this.loadedTools.clear();\n    }\n\n    /**\n     * Load a module with shared dependencies from the main clanker package\n     */\n    private loadWithSharedDependencies(requireFunc: any, filePath: string): any {\n        const Module = requireFunc('module');\n        const originalResolveFilename = Module._resolveFilename;\n\n        // Create a custom resolver that shares dependencies from main clanker\n        Module._resolveFilename = function (request: string, parent: any, isMain: boolean) {\n            // Check if this is a dependency that should be shared\n            if (shouldShareDependency(request)) {\n                try {\n                    // Try to resolve from the main clanker module context\n                    // This allows tools to use React, Ink, and other deps from clanker\n                    const mainModule = require.main || module;\n                    return originalResolveFilename.call(this, request, mainModule, false);\n                } catch (e) {\n                    // If that fails, try from the current module context\n                    try {\n                        return originalResolveFilename.call(this, request, module, false);\n                    } catch (e2) {\n                        debug.log(`[ToolLoader] Failed to resolve shared dependency ${request}`);\n                    }\n                }\n            }\n\n            // Fall back to normal resolution\n            return originalResolveFilename.call(this, request, parent, isMain);\n        };\n\n        try {\n            // Clear cache to ensure fresh load\n            delete requireFunc.cache[filePath];\n            const loadedModule = requireFunc(filePath);\n            return loadedModule;\n        } finally {\n            // Always restore original resolution\n            Module._resolveFilename = originalResolveFilename;\n        }\n    }\n\n    /**\n     * Create a tool template file\n     */\n    static async createToolTemplate(toolName: string, baseDir: string = process.cwd()): Promise<void> {\n        const toolsDir = path.join(baseDir, '.clank', 'tools');\n\n        // Ensure directory exists\n        await fs.mkdir(toolsDir, {recursive: true});\n\n        const fileName = `${toolName}.ts`;\n        const filePath = path.join(toolsDir, fileName);\n\n        // Check if file already exists\n        try {\n            await fs.access(filePath);\n            throw new Error(`Tool file already exists: ${filePath}`);\n        } catch (error: any) {\n            if (error.code !== 'ENOENT') throw error;\n        }\n\n        // Create template content\n        const template = `/**\n * ${toolName} tool\n * \n * This is a template for creating a custom tool.\n * Edit this file to implement your tool's functionality.\n */\n\nimport { createTool, ToolCategory, ToolCapability } from '@ziggle/clanker';\n\n// Using the builder API\nexport default createTool()\n  .id('${toolName}')\n  .name('${toolName.charAt(0).toUpperCase() + toolName.slice(1)} Tool')\n  .description('Description of what this tool does')\n  .category(ToolCategory.Utility)\n  .capabilities(ToolCapability.FileRead)\n  .tags('custom', 'example')\n  \n  // Define arguments\n  .stringArg('input', 'Input value', { required: true })\n  .booleanArg('verbose', 'Enable verbose output', { default: false })\n  \n  // Define the execution logic\n  .execute(async (args, context) => {\n    const { input, verbose } = args;\n    \n    if (verbose) {\n      context.logger?.debug('Processing input:', input);\n    }\n    \n    // Your tool logic here\n    const result = \\`Processed: \\${input}\\`;\n    \n    return {\n      success: true,\n      output: result,\n      data: { processed: result }\n    };\n  })\n  .build();\n`;\n\n        await fs.writeFile(filePath, template, 'utf-8');\n        debug.log(`Created tool template: ${filePath}`);\n    }\n}\n\n/**\n * Create a tool loader instance\n */\nexport function createToolLoader(registry: ToolRegistry, options?: LoaderOptions): ToolLoader {\n    return new ToolLoader(registry, options);\n}","/**\n * Dynamic Tool Registry System\n * \n * This module provides a unified API for registering, discovering, and executing tools\n * with support for composition, validation, and dynamic prompt generation.\n */\n\nexport * from './types';\nexport * from './registry';\nexport * from './builder';\nexport * from './composition';\nexport * from './adapters';\nexport * from './validation';\nexport * from './loader';\nexport * from './logger';","/**\n * Public API exports for tool development\n * \n * This file exports the necessary types and functions for creating\n * tools that work with the Clanker system.\n */\n\n// Re-export everything from registry for tool developers\nexport * from './registry/index';\n\n// Also export specific items that might be in different locations\nexport type { ToolResult } from './types';"],"mappings":"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","names":["ToolCategory","ToolCapability","validators","path","init_types","path","init_registry","fs","path","os","init_types","GrokAgent","SettingsManager","filePath","init_store","EventEmitter","init_store","fs","path","fileURLToPath","__filename","builtInTools","module","fs","path","os","crypto","ToolLoader","filePath","require","loadedModule","fileUrl","module","requireFunc","init_registry","init_registry"]}