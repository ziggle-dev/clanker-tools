{"version":3,"sources":["../node_modules/tsup/assets/esm_shims.js","../src/clanker/client.ts","../src/registry/types.ts","../src/registry/validation.ts","../src/registry/composition.ts","../src/utils/debug-logger.ts","../src/ui/stage/types.ts","../src/utils/settings-manager.ts","../src/store/store.ts","../src/store/index.ts","../src/utils/confirmation-service.ts","../src/registry/logger.ts","../src/registry/registry.ts","../src/registry/builder.ts","../src/registry/adapters.ts","../src/registry/builtin-tools.ts","../src/registry/manifest-loader.ts","../src/registry/loader.ts","../src/registry/index.ts","../src/registry/retry-executor.ts","../src/utils/token-counter.ts","../src/clanker/agent.ts","../src/package-manager/repository-manager.ts","../src/package-manager/registry.ts","../src/package-manager/resolver.ts","../src/package-manager/experimental.ts","../src/package-manager/installer.ts","../src/package-manager/publisher.ts","../src/package-manager/core-tools.ts","../src/ui/components/ClankerLogo.tsx","../src/ui/components/chat/ChatLayout.tsx","../src/ui/components/command-suggestions.tsx","../src/ui/utils/markdown-renderer.tsx","../src/ui/components/VirtualScroll.tsx","../src/ui/components/chat-history.tsx","../src/ui/components/chat/ChatInput.tsx","../src/ui/components/chat/StatusBar.tsx","../src/ui/components/chat-indicator.tsx","../src/ui/components/chat/LoadingAndStatus.tsx","../src/ui/components/model-selection.tsx","../src/hooks/input/useMessageInput.ts","../src/utils/commands.ts","../src/hooks/input/useCommandInput.ts","../src/hooks/input/useInputHistory.ts","../src/hooks/ui/useModelSelection.ts","../src/hooks/useInputHandler.ts","../src/hooks/useConfirmationHandler.ts","../src/hooks/useProcessingTimer.ts","../src/registry/messages.ts","../src/registry/execution.ts","../src/hooks/useRegistries.ts","../src/ui/containers/ChatContainer.tsx","../src/ui/components/form/Input.tsx","../src/ui/components/form/Button.tsx","../src/ui/components/form/SelectDropdown.tsx","../src/ui/components/form/Select.tsx","../src/ui/components/form/Toggle.tsx","../src/ui/components/form/Form.tsx","../src/ui/components/form/FormInput.tsx","../src/ui/components/form/FormButton.tsx","../src/ui/components/form/FormSelect.tsx","../src/ui/components/form/FormToggle.tsx","../src/ui/components/form/FormRow.tsx","../src/ui/components/form/FormGrid.tsx","../src/ui/components/form/ProviderSelect.tsx","../src/ui/components/form/ClearFormButton.tsx","../src/ui/components/form/VimModeIndicator.tsx","../src/ui/components/form/FormActionButtons.tsx","../src/ui/components/form/index.ts","../src/commands/registry.ts","../src/ui/screens/CommandPaletteScreen.tsx","../src/ui/screens/SettingsScreen.tsx","../src/ui/screens/HelpScreen.tsx","../src/ui/components/Modal.tsx","../src/ui/screens/ModalScreen.tsx","../src/ui/screens/ExitConfirmationModal.tsx","../src/ui/screens/ToolConfirmationScreen.tsx","../src/ui/stage/StageRouter.tsx","../src/commands/builtin.ts","../src/ui/containers/AppContainer.tsx","../src/index.ts","../src/package-manager/index.ts","../src/package-manager/types.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import OpenAI from \"openai\";\nimport type {ChatCompletionMessageParam, ChatCompletionChunk} from \"openai/resources/chat\";\n\nexport type GrokMessage = ChatCompletionMessageParam;\n\nexport interface GrokTool {\n    type: \"function\";\n    function: {\n        name: string;\n        description: string;\n        parameters: {\n            type: \"object\";\n            properties: Record<string, unknown>;\n            required: string[];\n        };\n    };\n}\n\nexport interface GrokToolCall {\n    id: string;\n    type: \"function\";\n    function: {\n        name: string;\n        arguments: string;\n    };\n}\n\nexport interface SearchParameters {\n    mode?: \"auto\" | \"on\" | \"off\";\n    // sources removed - let API use default sources to avoid format issues\n}\n\nexport interface SearchOptions {\n    search_parameters?: SearchParameters;\n}\n\nexport interface GrokResponse {\n    choices: Array<{\n        message: {\n            role: string;\n            content: string | null;\n            tool_calls?: GrokToolCall[];\n        };\n        finish_reason: string;\n    }>;\n}\n\nexport class GrokClient {\n    private client: OpenAI;\n    private currentModel: string = \"grok-3-latest\";\n\n    constructor(apiKey: string, model?: string, baseURL?: string) {\n        this.client = new OpenAI({\n            apiKey,\n            baseURL: baseURL || process.env.GROK_BASE_URL || \"https://api.x.ai/v1\",\n            timeout: 360000,\n        });\n        if (model) {\n            this.currentModel = model;\n        }\n    }\n\n    setModel(model: string): void {\n        this.currentModel = model;\n    }\n\n    getCurrentModel(): string {\n        return this.currentModel;\n    }\n\n    async chat(\n        messages: GrokMessage[],\n        tools?: GrokTool[],\n        model?: string,\n        searchOptions?: SearchOptions\n    ): Promise<GrokResponse> {\n        try {\n            const requestPayload: Record<string, unknown> = {\n                model: model || this.currentModel,\n                messages: messages as unknown[],\n                temperature: 0.7,\n                max_tokens: 4000,\n            };\n\n            if (tools && tools.length > 0) {\n                requestPayload.tools = tools;\n                requestPayload.tool_choice = \"auto\" as const;\n            }\n\n            // Add search parameters if specified\n            if (searchOptions?.search_parameters) {\n                (requestPayload as { search_parameters?: unknown }).search_parameters = searchOptions.search_parameters;\n            }\n\n            const response = await this.client.chat.completions.create(\n                requestPayload as unknown as Parameters<typeof this.client.chat.completions.create>[0]\n            );\n\n            return response as GrokResponse;\n        } catch (error) {\n            throw new Error(`Grok API error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n\n    async* chatStream(\n        messages: GrokMessage[],\n        tools?: GrokTool[],\n        model?: string,\n        searchOptions?: SearchOptions\n    ): AsyncGenerator<ChatCompletionChunk, void, unknown> {\n        try {\n            const requestPayload: Record<string, unknown> = {\n                model: model || this.currentModel,\n                messages: messages as unknown[],\n                temperature: 0.7,\n                max_tokens: 4000,\n                stream: true as const,\n            };\n\n            if (tools && tools.length > 0) {\n                requestPayload.tools = tools;\n                requestPayload.tool_choice = \"auto\" as const;\n            }\n\n            // Add search parameters if specified\n            if (searchOptions?.search_parameters) {\n                (requestPayload as { search_parameters?: unknown }).search_parameters = searchOptions.search_parameters;\n            }\n\n            // Log timing for debugging\n            const stream = await this.client.chat.completions.create(\n                requestPayload as unknown as Parameters<typeof this.client.chat.completions.create>[0]\n            );\n\n            let firstChunk = true;\n\n            for await (const chunk of stream as AsyncIterable<ChatCompletionChunk>) {\n                if (firstChunk) {\n                    firstChunk = false;\n                }\n                yield chunk;\n            }\n        } catch (error) {\n            throw new Error(`Grok API error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n\n    async search(\n        query: string,\n        searchParameters?: SearchParameters\n    ): Promise<GrokResponse> {\n        const searchMessage: GrokMessage = {\n            role: \"user\",\n            content: query,\n        };\n\n        const searchOptions: SearchOptions = {\n            search_parameters: searchParameters || {mode: \"on\"},\n        };\n\n        return this.chat([searchMessage], [], undefined, searchOptions);\n    }\n}\n","/**\n * Core types for the dynamic tool registry system\n */\n\nimport {ToolResult} from '../types';\nimport React from 'react';\n\n// ============================================================================\n// Core Tool Types\n// ============================================================================\n\n/**\n * Tool metadata for registration and discovery\n */\nexport interface ToolMetadata {\n    id: string;\n    name: string;\n    description: string;\n    version?: string;\n    author?: string;\n    tags?: string[];\n    category?: ToolCategory;\n    capabilities?: ToolCapability[];\n}\n\n/**\n * Tool categories for organization\n */\nexport enum ToolCategory {\n    FileSystem = 'filesystem',\n    System = 'system',\n    Search = 'search',\n    Development = 'development',\n    Task = 'task',\n    Utility = 'utility',\n    Composition = 'composition'\n}\n\n/**\n * Tool capabilities for permission checking\n */\nexport enum ToolCapability {\n    FileRead = 'file:read',\n    FileWrite = 'file:write',\n    SystemExecute = 'system:execute',\n    NetworkAccess = 'network:access',\n    UserConfirmation = 'user:confirmation'\n}\n\n// ============================================================================\n// Argument Specification\n// ============================================================================\n\n/**\n * Argument type definitions\n */\nexport type ArgumentType = 'string' | 'number' | 'boolean' | 'array' | 'object' | 'any';\n\n/**\n * Argument specification for tools\n */\nexport interface ArgumentSpec {\n    name: string;\n    type: ArgumentType;\n    description: string;\n    required?: boolean;\n    default?: string | number | boolean | unknown[] | Record<string, unknown>;\n    enum?: Array<string | number | boolean>;\n    validate?: (value: unknown) => boolean | string;\n}\n\n/**\n * Tool arguments definition\n */\nexport type ToolArguments = Record<string, unknown>;\n\n// ============================================================================\n// Tool Definition\n// ============================================================================\n\n/**\n * Tool execution context\n */\nexport interface ToolContext {\n    registry: ToolRegistry;\n    workingDirectory: string;\n    confirmationService?: unknown;\n    logger?: ToolLogger;\n    state?: Map<string, unknown>;\n}\n\n/**\n * Tool execution function\n */\nexport type ToolExecutor = (\n    args: ToolArguments,\n    context: ToolContext\n) => Promise<ToolResult>;\n\n/**\n * Tool result render function for custom UI display\n */\nexport type ToolResultRenderer = (args: {\n    toolName: string;\n    arguments: ToolArguments;\n    result?: ToolResult;\n    isExecuting: boolean;\n}) => React.ReactElement | null;\n\n/**\n * Complete tool definition\n */\nexport interface ToolDefinition extends ToolMetadata {\n    arguments?: ArgumentSpec[];\n    execute: ToolExecutor;\n\n    // Optional lifecycle hooks\n    initialize?: (context: ToolContext) => Promise<void>;\n    cleanup?: (context: ToolContext) => Promise<void>;\n\n    // Composition support\n    inputSchema?: Schema;\n    outputSchema?: Schema;\n    composable?: boolean;\n\n    // Optional custom renderer for chat history\n    renderResult?: ToolResultRenderer;\n\n    // Optional examples for better AI understanding\n    examples?: {\n        description: string;\n        arguments: ToolArguments;\n        result?: string;\n    }[];\n}\n\n/**\n * Registered tool instance\n */\nexport interface RegisteredTool {\n    definition: ToolDefinition;\n    initialized: boolean;\n    lastExecuted?: Date;\n    executionCount: number;\n    totalDuration: number; // Total execution time in milliseconds\n    hash?: string; // Hash of the tool file for version tracking\n    filePath?: string; // Path to the tool file\n}\n\n// ============================================================================\n// Composition Types\n// ============================================================================\n\n/**\n * Schema for type validation in compositions\n */\nexport interface Schema {\n    type: ArgumentType;\n    properties?: Record<string, Schema>;\n    items?: Schema;\n    required?: string[];\n}\n\n/**\n * Composition patterns\n */\nexport type CompositionPattern =\n    | 'pipeline'    // Sequential execution\n    | 'parallel'    // Concurrent execution\n    | 'conditional' // Branching based on conditions\n    | 'map'        // Apply to collection\n    | 'reduce';    // Aggregate results\n\n/**\n * Composed tool that can be registered\n */\nexport interface ComposedTool extends ToolDefinition {\n    pattern: CompositionPattern;\n    tools: string[]; // Tool IDs\n    config?: Record<string, unknown>;    // Pattern-specific configuration\n}\n\n// ============================================================================\n// Registry Interface\n// ============================================================================\n\n/**\n * Tool registry for managing tools\n */\nexport interface ToolRegistry {\n    // Registration\n    register(tool: ToolDefinition): void;\n\n    unregister(toolId: string): void;\n\n    // Discovery\n    get(toolId: string): RegisteredTool | undefined;\n\n    list(filter?: ToolFilter): ToolDefinition[];\n\n    search(query: string): ToolDefinition[];\n\n    // Execution\n    execute(toolId: string, args: ToolArguments): Promise<ToolResult>;\n\n    // Composition\n    compose(pattern: CompositionPattern, tools: string[], config?: Record<string, unknown>): ComposedTool;\n\n    // Validation\n    validateArguments(toolId: string, args: ToolArguments): ValidationResult;\n}\n\n/**\n * Tool filter options\n */\nexport interface ToolFilter {\n    category?: ToolCategory;\n    capabilities?: ToolCapability[];\n    tags?: string[];\n    composable?: boolean;\n}\n\n/**\n * Validation result\n */\nexport interface ValidationResult {\n    valid: boolean;\n    errors?: ValidationError[];\n}\n\n/**\n * Validation error\n */\nexport interface ValidationError {\n    field: string;\n    message: string;\n    expected?: unknown;\n    received?: unknown;\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Tool logger interface\n */\nexport interface ToolLogger {\n    debug(message: string, ...args: unknown[]): void;\n\n    info(message: string, ...args: unknown[]): void;\n\n    warn(message: string, ...args: unknown[]): void;\n\n    error(message: string, ...args: unknown[]): void;\n}\n\n/**\n * Extract argument types from tool definition\n */\nexport type ExtractToolArgs<T extends ToolDefinition> = T extends {\n        arguments: infer Args;\n    }\n    ? Args extends readonly ArgumentSpec[]\n        ? { [K in Args[number] as K['name']]: unknown }\n        : Record<string, unknown>\n    : Record<string, unknown>;\n\n","/**\n * Argument validation utilities\n */\n\nimport {\n    ArgumentSpec,\n    ToolArguments,\n    ValidationResult,\n    ValidationError,\n    ArgumentType\n} from './types';\n\n/**\n * Validate arguments against specifications\n */\nexport function validateArguments(\n    specs: ArgumentSpec[],\n    args: ToolArguments\n): ValidationResult {\n    const errors: ValidationError[] = [];\n\n    // Check required arguments\n    for (const spec of specs) {\n        const value = args[spec.name];\n\n        // Check required\n        if (spec.required && (value === undefined || value === null)) {\n            errors.push({\n                field: spec.name,\n                message: `Required argument '${spec.name}' is missing`,\n                expected: spec.type\n            });\n            continue;\n        }\n\n        // Skip validation if not provided and not required\n        if (value === undefined || value === null) {\n            continue;\n        }\n\n        // Check type\n        const typeError = validateType(value, spec.type, spec.name);\n        if (typeError) {\n            errors.push(typeError);\n            continue;\n        }\n\n        // Check enum values\n        if (spec.enum && !spec.enum.includes(value as string | number | boolean)) {\n            errors.push({\n                field: spec.name,\n                message: `Value must be one of: ${spec.enum.join(', ')}`,\n                expected: spec.enum,\n                received: value\n            });\n        }\n\n        // Run custom validation\n        if (spec.validate) {\n            const result = spec.validate(value);\n            if (typeof result === 'string') {\n                errors.push({\n                    field: spec.name,\n                    message: result,\n                    received: value\n                });\n            } else if (result === false) {\n                errors.push({\n                    field: spec.name,\n                    message: `Validation failed for '${spec.name}'`,\n                    received: value\n                });\n            }\n        }\n    }\n\n    // Check for unknown arguments\n    const knownArgs = new Set(specs.map(s => s.name));\n    for (const key of Object.keys(args)) {\n        if (!knownArgs.has(key)) {\n            errors.push({\n                field: key,\n                message: `Unknown argument '${key}'`\n            });\n        }\n    }\n\n    return {\n        valid: errors.length === 0,\n        errors: errors.length > 0 ? errors : undefined\n    };\n}\n\n/**\n * Validate value type\n */\nfunction validateType(value: unknown, expectedType: ArgumentType, fieldName: string): ValidationError | null {\n    const actualType = getActualType(value);\n\n    if (expectedType === 'any') {\n        return null;\n    }\n\n    if (actualType !== expectedType) {\n        // Special case: number type can accept numeric strings\n        if (expectedType === 'number' && actualType === 'string' && !isNaN(Number(value))) {\n            return null;\n        }\n\n        return {\n            field: fieldName,\n            message: `Expected ${expectedType} but got ${actualType}`,\n            expected: expectedType,\n            received: actualType\n        };\n    }\n\n    return null;\n}\n\n/**\n * Get the actual type of a value\n */\nfunction getActualType(value: unknown): ArgumentType {\n    if (value === null || value === undefined) {\n        return 'any';\n    }\n\n    if (Array.isArray(value)) {\n        return 'array';\n    }\n\n    const type = typeof value;\n\n    switch (type) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return type;\n        case 'object':\n            return 'object';\n        default:\n            return 'any';\n    }\n}\n\n/**\n * Apply default values to arguments\n */\nexport function applyDefaults(\n    specs: ArgumentSpec[],\n    args: ToolArguments\n): ToolArguments {\n    const result = {...args};\n\n    for (const spec of specs) {\n        if (spec.default !== undefined && result[spec.name] === undefined) {\n            result[spec.name] = spec.default;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Coerce argument types\n */\nexport function coerceArguments(\n    specs: ArgumentSpec[],\n    args: ToolArguments\n): ToolArguments {\n    const result = {...args};\n\n    for (const spec of specs) {\n        const value = result[spec.name];\n        if (value === undefined || value === null) {\n            continue;\n        }\n\n        result[spec.name] = coerceValue(value, spec.type);\n    }\n\n    return result;\n}\n\n/**\n * Coerce a value to the expected type\n */\nfunction coerceValue(value: unknown, targetType: ArgumentType): unknown {\n    const actualType = getActualType(value);\n\n    if (actualType === targetType || targetType === 'any') {\n        return value;\n    }\n\n    // String to number\n    if (targetType === 'number' && actualType === 'string') {\n        const num = Number(value);\n        return isNaN(num) ? value : num;\n    }\n\n    // String to boolean\n    if (targetType === 'boolean' && actualType === 'string') {\n        return value === 'true' || value === '1' || value === 'yes';\n    }\n\n    // String to array (split by comma)\n    if (targetType === 'array' && actualType === 'string') {\n        return (value as string).split(',').map((s: string) => s.trim());\n    }\n\n    // String to object (parse JSON)\n    if (targetType === 'object' && actualType === 'string') {\n        try {\n            return JSON.parse(value as string);\n        } catch {\n            return value;\n        }\n    }\n\n    return value;\n}\n\n/**\n * Format validation errors for display\n */\nexport function formatValidationErrors(errors: ValidationError[]): string {\n    return errors.map(error => {\n        let message = `• ${error.message}`;\n        if (error.expected && error.received) {\n            message += ` (expected: ${JSON.stringify(error.expected)}, received: ${JSON.stringify(error.received)})`;\n        }\n        return message;\n    }).join('\\n');\n}\n\n/**\n * Create a validation function for common patterns\n */\nexport const validators = {\n    /**\n     * String validators\n     */\n    minLength: (min: number) => (value: string) =>\n        value.length >= min || `Must be at least ${min} characters`,\n\n    maxLength: (max: number) => (value: string) =>\n        value.length <= max || `Must be at most ${max} characters`,\n\n    pattern: (regex: RegExp) => (value: string) =>\n        regex.test(value) || `Does not match required pattern`,\n\n    email: () => (value: string) =>\n        /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) || 'Must be a valid email address',\n\n    url: () => (value: string) => {\n        try {\n            new URL(value);\n            return true;\n        } catch {\n            return 'Must be a valid URL';\n        }\n    },\n\n    /**\n     * Number validators\n     */\n    min: (min: number) => (value: number) =>\n        value >= min || `Must be at least ${min}`,\n\n    max: (max: number) => (value: number) =>\n        value <= max || `Must be at most ${max}`,\n\n    integer: () => (value: number) =>\n        Number.isInteger(value) || 'Must be an integer',\n\n    positive: () => (value: number) =>\n        value > 0 || 'Must be positive',\n\n    /**\n     * Array validators\n     */\n    minItems: (min: number) => (value: unknown[]) =>\n        value.length >= min || `Must have at least ${min} items`,\n\n    maxItems: (max: number) => (value: unknown[]) =>\n        value.length <= max || `Must have at most ${max} items`,\n\n    unique: () => (value: unknown[]) =>\n        new Set(value).size === value.length || 'Items must be unique',\n\n    /**\n     * Combine multiple validators\n     */\n    combine: (...validators: Array<(value: unknown) => boolean | string>) =>\n        (value: unknown) => {\n            for (const validator of validators) {\n                const result = validator(value);\n                if (result !== true) {\n                    return result;\n                }\n            }\n            return true;\n        }\n};","/**\n * Tool composition patterns\n */\n\nimport {\n    ToolDefinition,\n    ComposedTool,\n    CompositionPattern,\n    ToolArguments,\n    ToolContext,\n    ToolCategory\n} from './types';\nimport {ToolResult} from '../types';\n\n/**\n * Create a composed tool based on pattern\n */\nexport function createComposedTool(\n    pattern: CompositionPattern,\n    tools: ToolDefinition[],\n    config?: Record<string, unknown>\n): ComposedTool {\n    const toolIds = tools.map(t => t.id);\n    const name = `${pattern}_${toolIds.join('_')}`;\n    const description = `${pattern} composition of: ${toolIds.join(', ')}`;\n\n    let executor: (args: ToolArguments, context: ToolContext) => Promise<ToolResult>;\n\n    switch (pattern) {\n        case 'pipeline':\n            executor = createPipelineExecutor(tools);\n            break;\n        case 'parallel':\n            executor = createParallelExecutor(tools);\n            break;\n        case 'conditional':\n            executor = createConditionalExecutor(tools, config);\n            break;\n        case 'map':\n            executor = createMapExecutor(tools[0], config);\n            break;\n        case 'reduce':\n            executor = createReduceExecutor(tools[0], config);\n            break;\n        default:\n            throw new Error(`Unknown composition pattern: ${pattern}`);\n    }\n\n    const composedTool: ComposedTool = {\n        id: name,\n        name,\n        description,\n        category: ToolCategory.Composition,\n        composable: true,\n        pattern,\n        tools: toolIds,\n        config,\n        execute: executor,\n\n        // Inherit capabilities from all tools\n        capabilities: Array.from(new Set(\n            tools.flatMap(t => t.capabilities || [])\n        ))\n    };\n\n    return composedTool;\n}\n\n/**\n * Pipeline executor - sequential execution with output chaining\n */\nfunction createPipelineExecutor(tools: ToolDefinition[]) {\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        let currentInput = args;\n        let lastResult: ToolResult | null = null;\n\n        for (const tool of tools) {\n            const result = await context.registry.execute(tool.id, currentInput);\n\n            if (!result.success) {\n                return result;\n            }\n\n            // Chain output to next tool's input\n            currentInput = (result.data || result.output || {}) as ToolArguments;\n            lastResult = result;\n        }\n\n        return lastResult || {success: true};\n    };\n}\n\n/**\n * Parallel executor - concurrent execution\n */\nfunction createParallelExecutor(tools: ToolDefinition[]) {\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        const promises = tools.map(tool =>\n            context.registry.execute(tool.id, args)\n        );\n\n        const results = await Promise.all(promises);\n\n        // Check if all succeeded\n        const failures = results.filter(r => !r.success);\n        if (failures.length > 0) {\n            return {\n                success: false,\n                error: `${failures.length} tools failed: ${failures.map(f => f.error).join(', ')}`\n            };\n        }\n\n        // Return all results\n        return {\n            success: true,\n            data: results.map(r => r.data || r.output)\n        };\n    };\n}\n\n/**\n * Conditional executor - branching based on condition\n */\nfunction createConditionalExecutor(tools: ToolDefinition[], config: Record<string, unknown>) {\n    const {condition, branches} = config;\n\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        // Evaluate condition\n        let branchKey: string;\n\n        if (typeof condition === 'function') {\n            branchKey = await condition(args, context);\n        } else {\n            branchKey = args[condition as string] ? 'true' : 'false';\n        }\n\n        // Find tool for branch\n        const toolIndex = branches[branchKey];\n        if (toolIndex === undefined || toolIndex >= tools.length) {\n            return {\n                success: false,\n                error: `No tool defined for branch: ${branchKey}`\n            };\n        }\n\n        const tool = tools[toolIndex];\n        return context.registry.execute(tool.id, args);\n    };\n}\n\n/**\n * Map executor - apply tool to each item in collection\n */\nfunction createMapExecutor(tool: ToolDefinition, config: Record<string, unknown> = {}) {\n    const concurrency = (config.concurrency as number) || 1;\n    const continueOnError = (config.continueOnError as boolean) || false;\n\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        const {items, ...otherArgs} = args;\n\n        if (!Array.isArray(items)) {\n            return {\n                success: false,\n                error: 'Map requires \"items\" array in arguments'\n            };\n        }\n\n        const results: unknown[] = [];\n        const errors: Array<{ item: unknown; error: string | undefined }> = [];\n\n        if (concurrency === 1) {\n            // Sequential processing\n            for (const item of items) {\n                const itemArgs = {...otherArgs, item};\n                const result = await context.registry.execute(tool.id, itemArgs);\n\n                if (!result.success) {\n                    if (!continueOnError) {\n                        return result;\n                    }\n                    errors.push({item, error: result.error});\n                } else {\n                    results.push(result.data || result.output);\n                }\n            }\n        } else {\n            // Parallel processing with concurrency limit\n            const chunks: unknown[][] = [];\n            for (let i = 0; i < items.length; i += concurrency) {\n                chunks.push(items.slice(i, i + concurrency));\n            }\n\n            for (const chunk of chunks) {\n                const promises = chunk.map(item => {\n                    const itemArgs = {...otherArgs, item};\n                    return context.registry.execute(tool.id, itemArgs);\n                });\n\n                const chunkResults = await Promise.all(promises);\n\n                chunkResults.forEach((result, index) => {\n                    if (!result.success) {\n                        if (!continueOnError) {\n                            return result;\n                        }\n                        errors.push({item: chunk[index], error: result.error});\n                    } else {\n                        results.push(result.data || result.output);\n                    }\n                });\n            }\n        }\n\n        return {\n            success: errors.length === 0 || continueOnError,\n            data: results,\n            error: errors.length > 0 ? `${errors.length} items failed` : undefined\n        };\n    };\n}\n\n/**\n * Reduce executor - aggregate results\n */\nfunction createReduceExecutor(tool: ToolDefinition, config: Record<string, unknown>) {\n    const {reducer, initialValue} = config;\n\n    return async (args: ToolArguments, context: ToolContext): Promise<ToolResult> => {\n        const {items, ...otherArgs} = args;\n\n        if (!Array.isArray(items)) {\n            return {\n                success: false,\n                error: 'Reduce requires \"items\" array in arguments'\n            };\n        }\n\n        let accumulator = initialValue;\n\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            const itemArgs = {...otherArgs, item, accumulator, index: i};\n\n            const result = await context.registry.execute(tool.id, itemArgs);\n\n            if (!result.success) {\n                return result;\n            }\n\n            // Apply reducer\n            if (typeof reducer === 'function') {\n                accumulator = await reducer(accumulator, result.data || result.output, i);\n            } else {\n                accumulator = result.data || result.output;\n            }\n        }\n\n        return {\n            success: true,\n            data: accumulator\n        };\n    };\n}\n\n/**\n * Composition builder with fluent API\n */\nexport class CompositionBuilder {\n    private registry: { get(id: string): { definition: ToolDefinition } | undefined };\n\n    constructor(registry: { get(id: string): { definition: ToolDefinition } | undefined }) {\n        this.registry = registry;\n    }\n\n    /**\n     * Create a pipeline composition\n     */\n    pipeline(...toolIds: string[]): ComposedTool {\n        const tools = toolIds.map(id => {\n            const tool = this.registry.get(id);\n            if (!tool) throw new Error(`Tool '${id}' not found`);\n            return tool.definition;\n        });\n\n        return createComposedTool('pipeline', tools);\n    }\n\n    /**\n     * Create a parallel composition\n     */\n    parallel(...toolIds: string[]): ComposedTool {\n        const tools = toolIds.map(id => {\n            const tool = this.registry.get(id);\n            if (!tool) throw new Error(`Tool '${id}' not found`);\n            return tool.definition;\n        });\n\n        return createComposedTool('parallel', tools);\n    }\n\n    /**\n     * Create a conditional composition\n     */\n    conditional(\n        condition: string | ((args: ToolArguments, context: ToolContext) => string | Promise<string>),\n        branches: Record<string, string>\n    ): ComposedTool {\n        const branchTools: ToolDefinition[] = [];\n        const branchMap: Record<string, number> = {};\n\n        Object.entries(branches).forEach(([key, toolId], index) => {\n            const tool = this.registry.get(toolId);\n            if (!tool) throw new Error(`Tool '${toolId}' not found`);\n            branchTools.push(tool.definition);\n            branchMap[key] = index;\n        });\n\n        return createComposedTool('conditional', branchTools, {\n            condition,\n            branches: branchMap\n        });\n    }\n\n    /**\n     * Create a map composition\n     */\n    map(toolId: string, options?: { concurrency?: number; continueOnError?: boolean }): ComposedTool {\n        const tool = this.registry.get(toolId);\n        if (!tool) throw new Error(`Tool '${toolId}' not found`);\n\n        return createComposedTool('map', [tool.definition], options);\n    }\n\n    /**\n     * Create a reduce composition\n     */\n    reduce(\n        toolId: string,\n        reducer: (acc: unknown, value: unknown, index: number) => unknown,\n        initialValue?: unknown\n    ): ComposedTool {\n        const tool = this.registry.get(toolId);\n        if (!tool) throw new Error(`Tool '${toolId}' not found`);\n\n        return createComposedTool('reduce', [tool.definition], {\n            reducer,\n            initialValue\n        });\n    }\n}","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\n\nlet debugEnabled = false;\nlet logToFile = false;\nlet logStream: fs.WriteStream | null = null;\nlet logFilePath: string | null = null;\n\nexport function setDebugMode(enabled: boolean, fileLogging = false): void {\n  debugEnabled = enabled;\n  logToFile = fileLogging && enabled;\n  \n  if (logToFile && !logStream) {\n    initializeFileLogging();\n  } else if (!logToFile && logStream) {\n    closeFileLogging();\n  }\n}\n\nfunction initializeFileLogging(): void {\n  try {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const logDir = path.join(os.homedir(), '.clanker', 'debug', 'logs');\n    \n    // Create directory if it doesn't exist\n    fs.mkdirSync(logDir, { recursive: true });\n    \n    logFilePath = path.join(logDir, `debug_${timestamp}.log`);\n    logStream = fs.createWriteStream(logFilePath, { flags: 'a' });\n    \n    logToStream(`=== Debug log started at ${new Date().toISOString()} ===\\n`);\n    logToStream(`Log file: ${logFilePath}\\n`);\n    logToStream(`Process: ${process.argv.join(' ')}\\n`);\n    logToStream(`Working directory: ${process.cwd()}\\n`);\n    logToStream(`===========================================\\n\\n`);\n    \n    console.log(`[DEBUG] Logging to file: ${logFilePath}`);\n  } catch (error) {\n    console.error('[DEBUG] Failed to initialize file logging:', error);\n    logToFile = false;\n  }\n}\n\nfunction closeFileLogging(): void {\n  if (logStream) {\n    logToStream(`\\n=== Debug log ended at ${new Date().toISOString()} ===\\n`);\n    logStream.end();\n    logStream = null;\n  }\n}\n\nfunction logToStream(message: string): void {\n  if (logStream) {\n    logStream.write(message);\n  }\n}\n\nfunction formatArgs(args: any[]): string {\n  return args.map(arg => {\n    if (typeof arg === 'object') {\n      try {\n        return JSON.stringify(arg, null, 2);\n      } catch {\n        return String(arg);\n      }\n    }\n    return String(arg);\n  }).join(' ');\n}\n\nexport function isDebugMode(): boolean {\n  return debugEnabled;\n}\n\nexport function getLogFilePath(): string | null {\n  return logFilePath;\n}\n\nexport const debug = {\n  log: (...args: any[]) => {\n    if (debugEnabled) {\n      const timestamp = new Date().toISOString();\n      const message = formatArgs(args);\n      \n      console.log('[DEBUG]', ...args);\n      \n      if (logToFile && logStream) {\n        logToStream(`[${timestamp}] [LOG] ${message}\\n`);\n      }\n    }\n  },\n  error: (...args: any[]) => {\n    if (debugEnabled) {\n      const timestamp = new Date().toISOString();\n      const message = formatArgs(args);\n      \n      console.error('[DEBUG ERROR]', ...args);\n      \n      if (logToFile && logStream) {\n        logToStream(`[${timestamp}] [ERROR] ${message}\\n`);\n      }\n    }\n  },\n  warn: (...args: any[]) => {\n    if (debugEnabled) {\n      const timestamp = new Date().toISOString();\n      const message = formatArgs(args);\n      \n      console.warn('[DEBUG WARN]', ...args);\n      \n      if (logToFile && logStream) {\n        logToStream(`[${timestamp}] [WARN] ${message}\\n`);\n      }\n    }\n  },\n  info: (...args: any[]) => {\n    if (debugEnabled) {\n      const timestamp = new Date().toISOString();\n      const message = formatArgs(args);\n      \n      console.info('[DEBUG INFO]', ...args);\n      \n      if (logToFile && logStream) {\n        logToStream(`[${timestamp}] [INFO] ${message}\\n`);\n      }\n    }\n  }\n};\n\n// Ensure log is closed on process exit\nprocess.on('exit', closeFileLogging);\nprocess.on('SIGINT', () => {\n  closeFileLogging();\n  process.exit();\n});\nprocess.on('SIGTERM', () => {\n  closeFileLogging();\n  process.exit();\n});","export interface Stage {\n    id: string;\n    type: StageType;\n    props?: any;\n}\n\nexport enum StageType {\n    CHAT = 'chat',\n    COMMAND_PALETTE = 'command_palette',\n    SETTINGS = 'settings',\n    HELP = 'help',\n    MODAL = 'modal',\n    EXIT_CONFIRMATION = 'exit_confirmation',\n    TOOL_CONFIRMATION = 'tool_confirmation'\n}\n\nexport interface StageManager {\n    getCurrentStage(): Stage;\n    pushStage(stage: Stage): void;\n    popStage(): void;\n    replaceStage(stage: Stage): void;\n    clearStages(): void;\n    getStageStack(): Stage[];\n}\n\nexport interface ModalOptions {\n    title: string;\n    message?: string;\n    options: ModalOption[];\n}\n\nexport interface ModalOption {\n    label: string;\n    value: string;\n    variant?: 'primary' | 'secondary' | 'danger';\n}\n\nexport interface ModalResult {\n    selected: string;\n    cancelled: boolean;\n}","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { z } from 'zod';\n\n// Provider configuration\nexport const ProviderModels = {\n    grok: {\n        name: 'Grok',\n        baseURL: 'https://api.x.ai/v1',\n        models: [\n            { value: 'grok-4-0709', label: 'Grok 4' },\n            { value: 'grok-3', label: 'Grok 3' },\n            { value: 'grok-3-mini', label: 'Grok 3 Mini' },\n            { value: 'grok-3-fast', label: 'Grok 3 Fast' },\n            { value: 'grok-3-mini-fast', label: 'Grok 3 Mini Fast' },\n            { value: 'grok-2-vision-1212', label: 'Grok 2 Vision' },\n            { value: 'grok-2-image-1212', label: 'Grok 2 Image' }\n        ],\n        defaultModel: 'grok-3'\n    },\n    openai: {\n        name: 'OpenAI',\n        baseURL: 'https://api.openai.com/v1',\n        models: [\n            { value: 'gpt-4', label: 'GPT-4' },\n            { value: 'gpt-4-turbo', label: 'GPT-4 Turbo' },\n            { value: 'gpt-3.5-turbo', label: 'GPT-3.5 Turbo' }\n        ],\n        defaultModel: 'gpt-4-turbo'\n    },\n    custom: {\n        name: 'Custom',\n        baseURL: '',\n        models: [],\n        defaultModel: ''\n    }\n} as const;\n\nexport type Provider = keyof typeof ProviderModels;\n\n// Define the settings schema\nexport const SettingsSchema = z.object({\n    apiKey: z.string().min(1, 'API key is required'),\n    provider: z.enum(['grok', 'openai', 'custom'] as const).default('grok'),\n    customBaseURL: z.string().url().optional(),\n    model: z.string().default(ProviderModels.grok.defaultModel),\n    theme: z.enum(['light', 'dark', 'auto']).default('auto'),\n    autoEditEnabled: z.boolean().default(false),\n    vsCodeOpenEnabled: z.boolean().default(false),\n    dangerousBypassPermission: z.boolean().default(false),\n    virtualScrollingEnabled: z.boolean().default(true),\n    confirmationSettings: z.object({\n        alwaysEdit: z.boolean().default(false),\n        alwaysBash: z.boolean().default(false),\n        alwaysSearch: z.boolean().default(false),\n    }).default({}),\n    // Add version to track schema changes\n    version: z.number().default(1)\n});\n\nexport type Settings = z.infer<typeof SettingsSchema>;\n\nexport class SettingsManager {\n    private static instance: SettingsManager;\n    private settingsPath: string;\n    private settingsDir: string;\n    private currentVersion = 2;\n\n    private constructor() {\n        this.settingsDir = path.join(os.homedir(), '.clanker');\n        this.settingsPath = path.join(this.settingsDir, 'settings.json');\n    }\n\n    static getInstance(): SettingsManager {\n        if (!SettingsManager.instance) {\n            SettingsManager.instance = new SettingsManager();\n        }\n        return SettingsManager.instance;\n    }\n\n    /**\n     * Ensure the settings directory exists\n     */\n    private ensureSettingsDir(): void {\n        if (!fs.existsSync(this.settingsDir)) {\n            fs.mkdirSync(this.settingsDir, { recursive: true });\n        }\n    }\n\n    /**\n     * Load settings from file\n     */\n    loadSettings(): { settings: Partial<Settings>, isValid: boolean, errors: z.ZodError | null } {\n        try {\n            this.ensureSettingsDir();\n            \n            if (!fs.existsSync(this.settingsPath)) {\n                return { settings: {}, isValid: false, errors: null };\n            }\n\n            const fileContent = fs.readFileSync(this.settingsPath, 'utf-8');\n            const rawSettings = JSON.parse(fileContent);\n            \n            // Try to parse with schema\n            const result = SettingsSchema.safeParse(rawSettings);\n            \n            if (result.success) {\n                return { settings: result.data, isValid: true, errors: null };\n            } else {\n                // Return partial settings and validation errors\n                return { settings: rawSettings, isValid: false, errors: result.error };\n            }\n        } catch (error) {\n            console.error('Failed to load settings:', error);\n            return { settings: {}, isValid: false, errors: null };\n        }\n    }\n\n    /**\n     * Save settings to file\n     */\n    saveSettings(settings: Settings): void {\n        try {\n            this.ensureSettingsDir();\n            \n            // Add version\n            const settingsWithVersion = { ...settings, version: this.currentVersion };\n            \n            fs.writeFileSync(\n                this.settingsPath,\n                JSON.stringify(settingsWithVersion, null, 2),\n                'utf-8'\n            );\n        } catch (error) {\n            console.error('Failed to save settings:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Check if settings need to be configured\n     * Returns true if settings are missing, invalid, or have new fields\n     */\n    needsConfiguration(): boolean {\n        const { isValid, settings } = this.loadSettings();\n        \n        if (!isValid) return true;\n        \n        // Check if we have all required fields\n        const requiredFields = ['apiKey'];\n        for (const field of requiredFields) {\n            if (!settings[field as keyof Settings]) {\n                return true;\n            }\n        }\n        \n        // Check version for schema changes\n        if (!settings.version || settings.version < this.currentVersion) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    /**\n     * Get fields that need configuration\n     */\n    getMissingFields(): string[] {\n        const { settings } = this.loadSettings();\n        const schema = SettingsSchema.shape;\n        const missingFields: string[] = [];\n        \n        // Check each field in the schema\n        for (const [key, value] of Object.entries(schema)) {\n            if (key === 'version') continue;\n            \n            // Check if field is required and missing\n            if (!value.isOptional() && !settings[key as keyof Settings]) {\n                missingFields.push(key);\n            }\n        }\n        \n        return missingFields;\n    }\n\n    /**\n     * Validate a single field\n     */\n    validateField(field: keyof Settings, value: any): string | undefined {\n        try {\n            const fieldSchema = SettingsSchema.shape[field];\n            fieldSchema.parse(value);\n            return undefined;\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return error.errors[0]?.message || 'Invalid value';\n            }\n            return 'Invalid value';\n        }\n    }\n}","import { proxy } from 'valtio';\nimport * as crypto from 'crypto';\nimport { GrokAgent } from '../clanker/agent';\nimport { MessageRegistryMessage } from '../registry/messages';\nimport { ToolExecution } from '../registry/execution';\nimport { ConfirmationOptions } from '../utils/confirmation-service';\nimport { GrokToolCall } from '../clanker/client';\nimport { debug } from '../utils/debug-logger';\nimport { Stage, StageType } from '../ui/stage/types';\n\n// File tracker types\ninterface FileInfo {\n    hash: string;\n    lastRead: Date;\n    lineCount: number;\n}\n\n// Define the complete store state\nexport interface AppState {\n    // Agent slice\n    agent: GrokAgent | null;\n    isInitializing: boolean;\n    initError: string | null;\n    \n    // Messages slice\n    messages: MessageRegistryMessage[];\n    messageCount: number;\n    \n    // Executions slice\n    executions: Map<string, ToolExecution>;\n    activeExecutions: string[];\n    \n    // File tracker slice\n    trackedFiles: Map<string, FileInfo>;\n    \n    // UI slice\n    isProcessing: boolean;\n    isStreaming: boolean;\n    tokenCount: number;\n    inputTokenCount: number;\n    outputTokenCount: number;\n    processingTime: number;\n    inputValue: string;\n    cursorPosition: number;\n    inputHistory: string[];\n    historyIndex: number;\n    showHelp: boolean;\n    showModelSelector: boolean;\n    exitConfirmation: boolean;\n    exitConfirmationTime: number;\n    showCommandSuggestions: boolean;\n    selectedCommandIndex: number;\n    commandSuggestions: string[];\n    showModelSelection: boolean;\n    selectedModelIndex: number;\n    availableModels: string[];\n    showCommandForm: boolean;\n    \n    // Stage management\n    stageStack: Stage[];\n    \n    // Settings slice\n    autoEditEnabled: boolean;\n    vsCodeOpenEnabled: boolean;\n    dangerousBypassPermission: boolean;\n    virtualScrollingEnabled: boolean;\n    confirmationSettings: {\n        alwaysEdit: boolean;\n        alwaysBash: boolean;\n        alwaysSearch: boolean;\n    };\n    theme: 'light' | 'dark' | 'auto';\n    model: string;\n    \n    // Confirmation slice\n    confirmationOptions: ConfirmationOptions | null;\n    confirmationResolver: ((result: ConfirmationResult) => void) | null;\n}\n\nexport interface ConfirmationResult {\n    confirmed: boolean;\n    dontAskAgain?: boolean;\n    feedback?: string;\n}\n\n// Create the proxy store with initial state\nexport const store = proxy<AppState>({\n    // Agent slice\n    agent: null,\n    isInitializing: false,\n    initError: null,\n    \n    // Messages slice\n    messages: [],\n    messageCount: 0,\n    \n    // Executions slice\n    executions: new Map(),\n    activeExecutions: [],\n    \n    // File tracker slice\n    trackedFiles: new Map(),\n    \n    // UI slice\n    isProcessing: false,\n    isStreaming: false,\n    tokenCount: 0,\n    inputTokenCount: 0,\n    outputTokenCount: 0,\n    processingTime: 0,\n    inputValue: '',\n    cursorPosition: 0,\n    inputHistory: [],\n    historyIndex: -1,\n    showHelp: false,\n    showModelSelector: false,\n    exitConfirmation: false,\n    exitConfirmationTime: 0,\n    showCommandSuggestions: false,\n    selectedCommandIndex: 0,\n    commandSuggestions: [],\n    showModelSelection: false,\n    selectedModelIndex: 0,\n    availableModels: ['grok-4-latest', 'grok-3-latest', 'grok-4', 'grok-3', 'grok-beta'],\n    showCommandForm: false,\n    \n    // Stage management\n    stageStack: [{ id: 'main', type: StageType.CHAT }],\n    \n    // Settings slice\n    autoEditEnabled: false,\n    vsCodeOpenEnabled: false,\n    dangerousBypassPermission: false,\n    virtualScrollingEnabled: true,\n    confirmationSettings: {\n        alwaysEdit: false,\n        alwaysBash: false,\n        alwaysSearch: false,\n    },\n    theme: 'auto',\n    model: 'grok-beta',\n    \n    // Confirmation slice\n    confirmationOptions: null,\n    confirmationResolver: null,\n});\n\n// Store actions as separate functions\nexport const actions = {\n    // Agent actions\n    setAgent(agent: GrokAgent) {\n        store.agent = agent;\n        store.initError = null;\n    },\n    \n    async initializeAgent(options: {\n        apiKey: string;\n        baseURL?: string;\n        model?: string;\n        maxToolRounds?: number;\n        systemPrompt?: string;\n        loadDynamicTools?: boolean;\n        dynamicToolsPath?: string;\n    }) {\n        store.isInitializing = true;\n        store.initError = null;\n        \n        try {\n            const { GrokAgent } = await import('../clanker/agent');\n            const agent = new GrokAgent(options);\n            store.agent = agent;\n            store.isInitializing = false;\n        } catch (error) {\n            store.isInitializing = false;\n            store.initError = error instanceof Error ? error.message : 'Unknown error';\n            throw error;\n        }\n    },\n    \n    clearAgent() {\n        store.agent = null;\n        store.initError = null;\n    },\n    \n    setInitializing(isInitializing: boolean) {\n        store.isInitializing = isInitializing;\n    },\n    \n    setInitError(error: string | null) {\n        store.initError = error;\n    },\n    \n    // Message actions\n    addMessage(message: Omit<MessageRegistryMessage, 'id' | 'timestamp'>) {\n        const id = `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        const newMessage: MessageRegistryMessage = {\n            ...message,\n            id,\n            timestamp: new Date(),\n        };\n        \n        store.messages.push(newMessage);\n        store.messageCount = store.messages.length;\n    },\n    \n    updateMessage(id: string, updates: Partial<MessageRegistryMessage>) {\n        const index = store.messages.findIndex(msg => msg.id === id);\n        if (index !== -1) {\n            Object.assign(store.messages[index], updates);\n        }\n    },\n    \n    clearMessages() {\n        store.messages = [];\n        store.messageCount = 0;\n    },\n    \n    setMessages(messages: MessageRegistryMessage[]) {\n        store.messages = messages;\n        store.messageCount = messages.length;\n    },\n    \n    startStreaming(messageId: string) {\n        const message = store.messages.find(msg => msg.id === messageId);\n        if (message) {\n            if (!message.metadata) message.metadata = {};\n            message.metadata.isStreaming = true;\n        }\n    },\n    \n    appendToMessage(messageId: string, content: string) {\n        const message = store.messages.find(msg => msg.id === messageId);\n        if (message) {\n            message.content += content;\n        }\n    },\n    \n    finishStreaming(messageId: string, metadata?: MessageRegistryMessage['metadata']) {\n        const message = store.messages.find(msg => msg.id === messageId);\n        if (message) {\n            if (!message.metadata) message.metadata = {};\n            Object.assign(message.metadata, metadata);\n            message.metadata.isStreaming = false;\n        }\n    },\n    \n    addToolCalls(messageId: string, toolCalls: GrokToolCall[]) {\n        const message = store.messages.find(msg => msg.id === messageId);\n        if (message) {\n            message.toolCalls = toolCalls;\n        }\n    },\n    \n    // Execution actions\n    addExecution(execution: Omit<ToolExecution, 'id' | 'startTime' | 'status'>): string {\n        const id = `exec-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        const newExecution: ToolExecution = {\n            ...execution,\n            id,\n            status: 'executing',\n            startTime: new Date(),\n        };\n        \n        store.executions.set(id, newExecution);\n        store.activeExecutions.push(id);\n        \n        return id;\n    },\n    \n    updateExecution(id: string, updates: Partial<ToolExecution>) {\n        const execution = store.executions.get(id);\n        if (execution) {\n            Object.assign(execution, updates);\n            store.executions.set(id, execution);\n        }\n    },\n    \n    completeExecution(id: string, result: ToolExecution['result']) {\n        const execution = store.executions.get(id);\n        if (execution) {\n            execution.status = 'completed';\n            execution.result = result;\n            execution.endTime = new Date();\n            store.executions.set(id, execution);\n            store.activeExecutions = store.activeExecutions.filter(execId => execId !== id);\n        }\n    },\n    \n    failExecution(id: string, error: string) {\n        const execution = store.executions.get(id);\n        if (execution) {\n            execution.status = 'failed';\n            execution.result = {\n                success: false,\n                error\n            };\n            execution.endTime = new Date();\n            store.executions.set(id, execution);\n            store.activeExecutions = store.activeExecutions.filter(execId => execId !== id);\n        }\n    },\n    \n    getExecution(id: string): ToolExecution | undefined {\n        return store.executions.get(id);\n    },\n    \n    clearExecutions() {\n        store.executions = new Map();\n        store.activeExecutions = [];\n    },\n    \n    // UI actions\n    setProcessing(isProcessing: boolean) {\n        store.isProcessing = isProcessing;\n    },\n    \n    setStreaming(isStreaming: boolean) {\n        store.isStreaming = isStreaming;\n    },\n    \n    updateTokenCount(count: number) {\n        store.tokenCount = count;\n        store.outputTokenCount = count;\n    },\n    \n    updateInputTokenCount(count: number) {\n        store.inputTokenCount = count;\n    },\n    \n    updateOutputTokenCount(count: number) {\n        store.outputTokenCount = count;\n        store.tokenCount = count;\n    },\n    \n    updateProcessingTime(time: number) {\n        store.processingTime = time;\n    },\n    \n    setInputValue(value: string) {\n        store.inputValue = value;\n    },\n    \n    getInputValue(): string {\n        return store.inputValue;\n    },\n    \n    setCursorPosition(position: number) {\n        store.cursorPosition = position;\n    },\n    \n    addToHistory(input: string) {\n        if (!input.trim()) return;\n        \n        // Remove duplicate if it exists\n        const filtered = store.inputHistory.filter(item => item !== input);\n        // Add to the end\n        const newHistory = [...filtered, input];\n        // Limit history size\n        store.inputHistory = newHistory.length > 100 \n            ? newHistory.slice(-100) \n            : newHistory;\n        store.historyIndex = -1;\n    },\n    \n    navigateHistory(direction: 'up' | 'down') {\n        if (direction === 'up') {\n            const newIndex = store.historyIndex === -1\n                ? store.inputHistory.length - 1\n                : Math.max(0, store.historyIndex - 1);\n            \n            if (newIndex >= 0 && newIndex < store.inputHistory.length) {\n                store.historyIndex = newIndex;\n                store.inputValue = store.inputHistory[newIndex];\n                store.cursorPosition = store.inputHistory[newIndex].length;\n            }\n        } else { // down\n            if (store.historyIndex === -1) return;\n            \n            const newIndex = store.historyIndex + 1;\n            \n            if (newIndex >= store.inputHistory.length) {\n                store.historyIndex = -1;\n                store.inputValue = '';\n                store.cursorPosition = 0;\n            } else {\n                store.historyIndex = newIndex;\n                store.inputValue = store.inputHistory[newIndex];\n                store.cursorPosition = store.inputHistory[newIndex].length;\n            }\n        }\n    },\n    \n    toggleHelp() {\n        store.showHelp = !store.showHelp;\n    },\n    \n    toggleModelSelector() {\n        store.showModelSelector = !store.showModelSelector;\n    },\n    \n    setExitConfirmation(show: boolean) {\n        store.exitConfirmation = show;\n        if (show) {\n            store.exitConfirmationTime = Date.now();\n        }\n    },\n    \n    // Settings actions\n    setAutoEdit(enabled: boolean) {\n        store.autoEditEnabled = enabled;\n        actions.saveSettings();\n    },\n    \n    setVSCodeOpen(enabled: boolean) {\n        store.vsCodeOpenEnabled = enabled;\n        actions.saveSettings();\n    },\n    \n    setDangerousBypassPermission(enabled: boolean) {\n        store.dangerousBypassPermission = enabled;\n        actions.saveSettings();\n    },\n    \n    setVirtualScrolling(enabled: boolean) {\n        store.virtualScrollingEnabled = enabled;\n        actions.saveSettings();\n    },\n    \n    updateConfirmationSettings(settings: Partial<AppState['confirmationSettings']>) {\n        Object.assign(store.confirmationSettings, settings);\n        actions.saveSettings();\n    },\n    \n    setTheme(theme: AppState['theme']) {\n        store.theme = theme;\n        actions.saveSettings();\n    },\n    \n    setModel(model: string) {\n        store.model = model;\n        actions.saveSettings();\n    },\n    \n    // Command form actions\n    setShowCommandForm(show: boolean) {\n        store.showCommandForm = show;\n    },\n    \n    // UI actions\n    setShowHelp(show: boolean) {\n        store.showHelp = show;\n    },\n    \n    async loadSettings() {\n        try {\n            const { SettingsManager } = await import('../utils/settings-manager');\n            const settingsManager = SettingsManager.getInstance();\n            const { settings, isValid } = settingsManager.loadSettings();\n            \n            if (isValid && settings) {\n                // Update store with loaded settings\n                if (settings.model) store.model = settings.model;\n                if (settings.theme) store.theme = settings.theme;\n                if (settings.autoEditEnabled !== undefined) store.autoEditEnabled = settings.autoEditEnabled;\n                if (settings.vsCodeOpenEnabled !== undefined) store.vsCodeOpenEnabled = settings.vsCodeOpenEnabled;\n                if (settings.dangerousBypassPermission !== undefined) store.dangerousBypassPermission = settings.dangerousBypassPermission;\n                if (settings.virtualScrollingEnabled !== undefined) store.virtualScrollingEnabled = settings.virtualScrollingEnabled;\n                if (settings.confirmationSettings) {\n                    Object.assign(store.confirmationSettings, settings.confirmationSettings);\n                }\n            }\n        } catch (error) {\n            debug.error('Failed to load settings:', error);\n        }\n    },\n    \n    async saveSettings() {\n        try {\n            const settingsToSave = {\n                autoEditEnabled: store.autoEditEnabled,\n                vsCodeOpenEnabled: store.vsCodeOpenEnabled,\n                dangerousBypassPermission: store.dangerousBypassPermission,\n                virtualScrollingEnabled: store.virtualScrollingEnabled,\n                confirmationSettings: store.confirmationSettings,\n                theme: store.theme,\n                model: store.model,\n            };\n            \n            // debug.log('Saving settings:', settingsToSave);\n        } catch (error) {\n            debug.error('Failed to save settings:', error);\n        }\n    },\n    \n    // Confirmation actions\n    requestConfirmation(options: ConfirmationOptions): Promise<ConfirmationResult> {\n        return new Promise<ConfirmationResult>((resolve) => {\n            store.confirmationOptions = options;\n            store.confirmationResolver = resolve;\n        });\n    },\n    \n    respondToConfirmation(result: ConfirmationResult) {\n        if (store.confirmationResolver) {\n            store.confirmationResolver(result);\n            store.confirmationOptions = null;\n            store.confirmationResolver = null;\n        }\n    },\n    \n    cancelConfirmation() {\n        if (store.confirmationResolver) {\n            store.confirmationResolver({ confirmed: false });\n            store.confirmationOptions = null;\n            store.confirmationResolver = null;\n        }\n    },\n    \n    // File tracker actions\n    updateFile(filePath: string, content: string) {\n        const hash = crypto.createHash('sha256').update(content).digest('hex');\n        const lineCount = content.split('\\n').length;\n        \n        store.trackedFiles.set(filePath, {\n            hash,\n            lastRead: new Date(),\n            lineCount\n        });\n    },\n    \n    hasFile(filePath: string): boolean {\n        return store.trackedFiles.has(filePath);\n    },\n    \n    getFileInfo(filePath: string): FileInfo | undefined {\n        return store.trackedFiles.get(filePath);\n    },\n    \n    verifyFileHash(filePath: string, content: string): boolean {\n        const fileInfo = store.trackedFiles.get(filePath);\n        if (!fileInfo) return false;\n        \n        const currentHash = crypto.createHash('sha256').update(content).digest('hex');\n        return fileInfo.hash === currentHash;\n    },\n    \n    clearFile(filePath: string) {\n        store.trackedFiles.delete(filePath);\n    },\n    \n    clearAllFiles() {\n        store.trackedFiles.clear();\n    },\n    \n    // Stage management actions\n    getCurrentStage(): Stage {\n        return store.stageStack[store.stageStack.length - 1];\n    },\n    \n    pushStage(stage: Stage) {\n        store.stageStack.push(stage);\n    },\n    \n    popStage() {\n        if (store.stageStack.length > 1) {\n            store.stageStack.pop();\n        }\n    },\n    \n    replaceStage(stage: Stage) {\n        if (store.stageStack.length > 0) {\n            store.stageStack[store.stageStack.length - 1] = stage;\n        }\n    },\n    \n    clearStages() {\n        store.stageStack = [{ id: 'main', type: StageType.CHAT }];\n    },\n    \n    getStageStack(): Stage[] {\n        return store.stageStack;\n    },\n};\n\n// Export file tracker actions separately for convenience\nexport const fileTrackerActions = {\n    updateFile: actions.updateFile,\n    hasFile: actions.hasFile,\n    getFileInfo: actions.getFileInfo,\n    verifyFileHash: actions.verifyFileHash,\n    clearFile: actions.clearFile,\n    clearAllFiles: actions.clearAllFiles,\n};","// Re-export everything from the valtio store\nexport { store, actions } from './store';\nexport type { AppState, ConfirmationResult } from './store';\n\n// Re-export types for convenience\nexport type { MessageRegistryMessage } from '../registry/messages';\nexport type { ToolExecution } from '../registry/execution';\nexport type { ConfirmationOptions } from '../utils/confirmation-service';\nexport type { GrokAgent } from '../clanker/agent';","import {EventEmitter} from \"events\";\nimport {store} from \"../store\";\n\nexport interface ConfirmationOptions {\n    operation: string;\n    filename: string;\n    content?: string; // Content to show in confirmation dialog\n}\n\nexport interface ConfirmationResult {\n    confirmed: boolean;\n    dontAskAgain?: boolean;\n    feedback?: string;\n}\n\nexport class ConfirmationService extends EventEmitter {\n    private static instance: ConfirmationService;\n    private skipConfirmationThisSession = false;\n    private pendingConfirmation: Promise<ConfirmationResult> | null = null;\n    private resolveConfirmation: ((result: ConfirmationResult) => void) | null =\n        null;\n\n    // Session flags for different operation types\n    private sessionFlags = {\n        fileOperations: false,\n        bashCommands: false,\n        allOperations: false,\n        createFiles: false,\n        editFiles: false,\n    };\n\n    static getInstance(): ConfirmationService {\n        if (!ConfirmationService.instance) {\n            ConfirmationService.instance = new ConfirmationService();\n        }\n        return ConfirmationService.instance;\n    }\n\n    constructor() {\n        super();\n    }\n\n    async requestConfirmation(\n        options: ConfirmationOptions,\n        operationType: \"file\" | \"bash\" | \"file_create\" | \"file_edit\" = \"file\"\n    ): Promise<ConfirmationResult> {\n        // Check if dangerously bypass permission is enabled\n        if (store.dangerousBypassPermission) {\n            return {confirmed: true};\n        }\n\n        // Check if auto-edit is enabled for file operations only\n        if (store.autoEditEnabled && (operationType === \"file_edit\" || operationType === \"file_create\")) {\n            return {confirmed: true};\n        }\n\n        // Check session flags\n        if (\n            this.sessionFlags.allOperations ||\n            (operationType === \"file\" && this.sessionFlags.fileOperations) ||\n            (operationType === \"bash\" && this.sessionFlags.bashCommands) ||\n            (operationType === \"file_create\" && this.sessionFlags.createFiles) ||\n            (operationType === \"file_edit\" && this.sessionFlags.editFiles)\n        ) {\n            return {confirmed: true};\n        }\n\n\n        // Create a promise that will be resolved by the UI component\n        this.pendingConfirmation = new Promise<ConfirmationResult>((resolve) => {\n            this.resolveConfirmation = resolve;\n        });\n\n        // Emit custom event that the UI can listen to (using setImmediate to ensure the UI updates)\n        setImmediate(() => {\n            this.emit(\"confirmation-requested\", options);\n        });\n\n        const result = await this.pendingConfirmation;\n\n        if (result.dontAskAgain) {\n            // Set the appropriate session flag based on operation type\n            if (operationType === \"file\") {\n                this.sessionFlags.fileOperations = true;\n            } else if (operationType === \"bash\") {\n                this.sessionFlags.bashCommands = true;\n            } else if (operationType === \"file_create\") {\n                this.sessionFlags.createFiles = true;\n            } else if (operationType === \"file_edit\") {\n                this.sessionFlags.editFiles = true;\n            }\n            // Could also set allOperations for global skip\n        }\n\n        return result;\n    }\n\n    confirmOperation(confirmed: boolean, dontAskAgain?: boolean): void {\n        if (this.resolveConfirmation) {\n            this.resolveConfirmation({confirmed, dontAskAgain});\n            this.resolveConfirmation = null;\n            this.pendingConfirmation = null;\n        }\n    }\n\n    rejectOperation(feedback?: string): void {\n        if (this.resolveConfirmation) {\n            this.resolveConfirmation({confirmed: false, feedback});\n            this.resolveConfirmation = null;\n            this.pendingConfirmation = null;\n        }\n    }\n\n\n    isPending(): boolean {\n        return this.pendingConfirmation !== null;\n    }\n\n    resetSession(): void {\n        this.sessionFlags = {\n            fileOperations: false,\n            bashCommands: false,\n            allOperations: false,\n            createFiles: false,\n            editFiles: false,\n        };\n    }\n\n    getSessionFlags() {\n        return {...this.sessionFlags};\n    }\n\n    setSessionFlag(\n        flagType: \"fileOperations\" | \"bashCommands\" | \"allOperations\",\n        value: boolean\n    ) {\n        this.sessionFlags[flagType] = value;\n    }\n}\n","/**\n * Logger implementation for tool execution\n */\n\nimport { ToolLogger } from './types';\n\n/**\n * Console logger implementation\n */\nexport class ConsoleLogger implements ToolLogger {\n  private prefix: string;\n  private enabled: boolean;\n\n  constructor(prefix: string = '[Tool]', enabled: boolean = true) {\n    this.prefix = prefix;\n    this.enabled = enabled;\n  }\n\n  debug(message: string, ...args: unknown[]): void {\n    if (this.enabled && process.env.DEBUG === 'true') {\n      console.log(`${this.prefix} DEBUG:`, message, ...args);\n    }\n  }\n\n  info(message: string, ...args: unknown[]): void {\n    if (this.enabled) {\n      console.log(`${this.prefix} INFO:`, message, ...args);\n    }\n  }\n\n  warn(message: string, ...args: unknown[]): void {\n    if (this.enabled) {\n      console.warn(`${this.prefix} WARN:`, message, ...args);\n    }\n  }\n\n  error(message: string, ...args: unknown[]): void {\n    if (this.enabled) {\n      console.error(`${this.prefix} ERROR:`, message, ...args);\n    }\n  }\n}\n\n/**\n * Create a logger instance for a specific tool\n */\nexport function createToolLogger(toolId: string, enabled: boolean = true): ToolLogger {\n  // Disable logging in interactive mode to avoid interfering with TUI\n  const isInteractive = process.stdout.isTTY && !process.env.CI;\n  return isInteractive ? new NullLogger() : new ConsoleLogger(`[${toolId}]`, enabled);\n}\n\n/**\n * Null logger that discards all messages\n */\nexport class NullLogger implements ToolLogger {\n  debug(): void {\n    // No-op\n  }\n\n  info(): void {\n    // No-op\n  }\n\n  warn(): void {\n    // No-op\n  }\n\n  error(): void {\n    // No-op\n  }\n}","/**\n * Core tool registry implementation\n */\n\nimport {\n  ToolDefinition,\n  RegisteredTool,\n  ToolRegistry,\n  ToolArguments,\n  ToolFilter,\n  ValidationResult,\n  ToolContext,\n  CompositionPattern,\n  ComposedTool\n} from './types';\nimport { ToolResult } from '../types';\nimport { validateArguments } from './validation';\nimport { createComposedTool } from './composition';\nimport { ConfirmationService } from '../utils/confirmation-service';\nimport { createToolLogger } from './logger';\n\n/**\n * Main tool registry implementation\n */\nexport class ToolRegistryImpl implements ToolRegistry {\n  private tools = new Map<string, RegisteredTool>();\n  private context: ToolContext;\n  \n  constructor(workingDirectory: string = process.cwd()) {\n    this.context = {\n      registry: this,\n      workingDirectory,\n      confirmationService: ConfirmationService.getInstance(),\n      state: new Map()\n    };\n  }\n  \n  /**\n   * Register a new tool\n   */\n  register(tool: ToolDefinition): void {\n    if (this.tools.has(tool.id)) {\n      throw new Error(`Tool with id '${tool.id}' already registered`);\n    }\n    \n    this.tools.set(tool.id, {\n      definition: tool,\n      initialized: false,\n      executionCount: 0,\n      totalDuration: 0\n    });\n  }\n  \n  /**\n   * Unregister a tool\n   */\n  async unregister(toolId: string): Promise<void> {\n    const tool = this.tools.get(toolId);\n    if (!tool) {\n      throw new Error(`Tool '${toolId}' not found`);\n    }\n    \n    // Cleanup if needed\n    if (tool.definition.cleanup && tool.initialized) {\n      await tool.definition.cleanup(this.context);\n    }\n    \n    this.tools.delete(toolId);\n  }\n  \n  /**\n   * Get a registered tool\n   */\n  get(toolId: string): RegisteredTool | undefined {\n    return this.tools.get(toolId);\n  }\n  \n  /**\n   * List tools with optional filter\n   */\n  list(filter?: ToolFilter): ToolDefinition[] {\n    let tools = Array.from(this.tools.values()).map(t => t.definition);\n    \n    if (filter) {\n      if (filter.category) {\n        tools = tools.filter(t => t.category === filter.category);\n      }\n      \n      if (filter.capabilities && filter.capabilities.length > 0) {\n        tools = tools.filter(t => \n          t.capabilities && \n          filter.capabilities!.every(cap => t.capabilities!.includes(cap))\n        );\n      }\n      \n      if (filter.tags && filter.tags.length > 0) {\n        tools = tools.filter(t =>\n          t.tags &&\n          filter.tags!.some(tag => t.tags!.includes(tag))\n        );\n      }\n      \n      if (filter.composable !== undefined) {\n        tools = tools.filter(t => t.composable === filter.composable);\n      }\n    }\n    \n    return tools;\n  }\n  \n  /**\n   * Search tools by query\n   */\n  search(query: string): ToolDefinition[] {\n    const lowerQuery = query.toLowerCase();\n    return Array.from(this.tools.values())\n      .map(t => t.definition)\n      .filter(tool => {\n        const searchText = [\n          tool.id,\n          tool.name,\n          tool.description,\n          ...(tool.tags || [])\n        ].join(' ').toLowerCase();\n        \n        return searchText.includes(lowerQuery);\n      });\n  }\n  \n  /**\n   * Execute a tool\n   */\n  async execute(toolId: string, args: ToolArguments): Promise<ToolResult> {\n    const registeredTool = this.tools.get(toolId);\n    if (!registeredTool) {\n      return {\n        success: false,\n        error: `Tool '${toolId}' not found`\n      };\n    }\n    \n    const tool = registeredTool.definition;\n    \n    // Validate arguments\n    const validation = this.validateArguments(toolId, args);\n    if (!validation.valid) {\n      return {\n        success: false,\n        error: `Validation failed: ${validation.errors!.map(e => e.message).join(', ')}`\n      };\n    }\n    \n    // Initialize tool if needed\n    if (!registeredTool.initialized && tool.initialize) {\n      try {\n        const initContext: ToolContext = {\n          ...this.context,\n          logger: createToolLogger(toolId)\n        };\n        await tool.initialize(initContext);\n        registeredTool.initialized = true;\n      } catch (error) {\n        return {\n          success: false,\n          error: `Failed to initialize tool: ${error instanceof Error ? error.message : String(error)}`\n        };\n      }\n    }\n    \n    // Execute tool\n    const startTime = Date.now();\n    \n    try {\n      // Create a context with logger for this specific execution\n      const executionContext: ToolContext = {\n        ...this.context,\n        logger: createToolLogger(toolId)\n      };\n      \n      const result = await tool.execute(args, executionContext);\n      \n      // Update metrics\n      const duration = Date.now() - startTime;\n      registeredTool.executionCount++;\n      registeredTool.lastExecuted = new Date();\n      registeredTool.totalDuration += duration;\n      \n      return result;\n    } catch (error) {\n      return {\n        success: false,\n        error: `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n      };\n    }\n  }\n  \n  /**\n   * Create a composed tool\n   */\n  compose(pattern: CompositionPattern, toolIds: string[], config?: Record<string, unknown>): ComposedTool {\n    // Verify all tools exist\n    const tools = toolIds.map(id => {\n      const tool = this.get(id);\n      if (!tool) {\n        throw new Error(`Tool '${id}' not found for composition`);\n      }\n      return tool.definition;\n    });\n    \n    return createComposedTool(pattern, tools, config || {});\n  }\n  \n  /**\n   * Validate tool arguments\n   */\n  validateArguments(toolId: string, args: ToolArguments): ValidationResult {\n    const tool = this.get(toolId);\n    if (!tool) {\n      return {\n        valid: false,\n        errors: [{ field: 'toolId', message: `Tool '${toolId}' not found` }]\n      };\n    }\n    \n    return validateArguments(tool.definition.arguments || [], args);\n  }\n  \n  /**\n   * Get the registry context\n   */\n  getContext(): ToolContext {\n    return this.context;\n  }\n  \n  /**\n   * Update working directory\n   */\n  setWorkingDirectory(dir: string): void {\n    this.context.workingDirectory = dir;\n  }\n  \n  /**\n   * Get tool statistics\n   */\n  getStats(): {\n    totalTools: number;\n    byCategory: Record<string, number>;\n    byCapability: Record<string, number>;\n    mostUsed: Array<{ toolId: string; count: number }>;\n  } {\n    const tools = Array.from(this.tools.entries());\n    \n    const byCategory: Record<string, number> = {};\n    const byCapability: Record<string, number> = {};\n    \n    tools.forEach(([_, tool]) => {\n      const def = tool.definition;\n      \n      // Count by category\n      if (def.category) {\n        byCategory[def.category] = (byCategory[def.category] || 0) + 1;\n      }\n      \n      // Count by capability\n      if (def.capabilities) {\n        def.capabilities.forEach(cap => {\n          byCapability[cap] = (byCapability[cap] || 0) + 1;\n        });\n      }\n    });\n    \n    // Get most used tools\n    const mostUsed = tools\n      .map(([id, tool]) => ({ toolId: id, count: tool.executionCount }))\n      .filter(t => t.count > 0)\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n    \n    return {\n      totalTools: tools.length,\n      byCategory,\n      byCapability,\n      mostUsed\n    };\n  }\n\n  /**\n   * Get execution stats in the format expected by tests\n   */\n  getExecutionStats(): Record<string, { executionCount: number; totalDuration: number }> {\n    const stats: Record<string, { executionCount: number; totalDuration: number }> = {};\n    \n    this.tools.forEach((tool, id) => {\n      stats[id] = {\n        executionCount: tool.executionCount,\n        totalDuration: tool.totalDuration\n      };\n    });\n    \n    return stats;\n  }\n}\n\n/**\n * Create a new tool registry instance\n */\nexport function createToolRegistry(workingDirectory?: string): ToolRegistry {\n  return new ToolRegistryImpl(workingDirectory);\n}","/**\n * Tool builder for creating tools with a fluent API\n */\n\nimport {\n    ToolDefinition,\n    ToolMetadata,\n    ArgumentSpec,\n    ToolExecutor,\n    ToolContext,\n    ToolCategory,\n    ToolCapability,\n    Schema,\n    ToolResultRenderer,\n    ToolArguments\n} from './types';\n\n/**\n * Builder for creating tool definitions\n */\nexport class ToolBuilder {\n    private metadata: Partial<ToolMetadata> = {};\n    private args: ArgumentSpec[] = [];\n    private executor?: ToolExecutor;\n    private initHook?: (context: ToolContext) => Promise<void>;\n    private cleanupHook?: (context: ToolContext) => Promise<void>;\n    private schemas: { input?: Schema; output?: Schema } = {};\n    private isComposable?: boolean;\n    private renderer?: ToolResultRenderer;\n    private examplesList?: { description: string; arguments: ToolArguments; result?: string }[];\n\n    /**\n     * Set tool ID (required)\n     */\n    id(id: string): ToolBuilder {\n        this.metadata.id = id;\n        return this;\n    }\n\n    /**\n     * Set tool name\n     */\n    name(name: string): ToolBuilder {\n        this.metadata.name = name;\n        return this;\n    }\n\n    /**\n     * Set tool description\n     */\n    description(description: string): ToolBuilder {\n        this.metadata.description = description;\n        return this;\n    }\n\n    /**\n     * Set tool version\n     */\n    version(version: string): ToolBuilder {\n        this.metadata.version = version;\n        return this;\n    }\n\n    /**\n     * Set tool author\n     */\n    author(author: string): ToolBuilder {\n        this.metadata.author = author;\n        return this;\n    }\n\n    /**\n     * Set tool category\n     */\n    category(category: ToolCategory): ToolBuilder {\n        this.metadata.category = category;\n        return this;\n    }\n\n    /**\n     * Add tags\n     */\n    tags(...tags: string[]): ToolBuilder {\n        this.metadata.tags = [...(this.metadata.tags || []), ...tags];\n        return this;\n    }\n\n    /**\n     * Add capabilities\n     */\n    capabilities(...capabilities: ToolCapability[]): ToolBuilder {\n        this.metadata.capabilities = [...(this.metadata.capabilities || []), ...capabilities];\n        return this;\n    }\n\n    /**\n     * Add an argument\n     */\n    argument(spec: ArgumentSpec): ToolBuilder {\n        this.args.push(spec);\n        return this;\n    }\n\n    /**\n     * Add a string argument (convenience method)\n     */\n    stringArg(name: string, description: string, options?: {\n        required?: boolean;\n        default?: string;\n        enum?: string[];\n        validate?: (value: string) => true | string;\n    }): ToolBuilder {\n        return this.argument({\n            name,\n            type: 'string',\n            description,\n            ...options\n        });\n    }\n\n    /**\n     * Add a number argument (convenience method)\n     */\n    numberArg(name: string, description: string, options?: {\n        required?: boolean;\n        default?: number;\n        validate?: (value: number) => true | string;\n    }): ToolBuilder {\n        return this.argument({\n            name,\n            type: 'number',\n            description,\n            ...options\n        });\n    }\n\n    /**\n     * Add a boolean argument (convenience method)\n     */\n    booleanArg(name: string, description: string, options?: {\n        required?: boolean;\n        default?: boolean;\n    }): ToolBuilder {\n        return this.argument({\n            name,\n            type: 'boolean',\n            description,\n            ...options\n        });\n    }\n\n    /**\n     * Add an array argument (convenience method)\n     */\n    arrayArg(name: string, description: string, options?: {\n        required?: boolean;\n        default?: unknown[];\n        validate?: (value: unknown[]) => boolean | string;\n    }): ToolBuilder {\n        return this.argument({\n            name,\n            type: 'array',\n            description,\n            ...options\n        });\n    }\n\n    /**\n     * Set input schema for composition\n     */\n    inputSchema(schema: Schema): ToolBuilder {\n        this.schemas.input = schema;\n        return this;\n    }\n\n    /**\n     * Set output schema for composition\n     */\n    outputSchema(schema: Schema): ToolBuilder {\n        this.schemas.output = schema;\n        return this;\n    }\n\n    /**\n     * Make tool composable\n     */\n    composable(value: boolean = true): ToolBuilder {\n        this.isComposable = value;\n        return this;\n    }\n\n    /**\n     * Set execution function\n     */\n    execute(executor: ToolExecutor): ToolBuilder {\n        this.executor = executor;\n        return this;\n    }\n\n    /**\n     * Set initialization hook\n     */\n    onInitialize(hook: (context: ToolContext) => Promise<void>): ToolBuilder {\n        this.initHook = hook;\n        return this;\n    }\n\n    /**\n     * Set cleanup hook\n     */\n    onCleanup(hook: (context: ToolContext) => Promise<void>): ToolBuilder {\n        this.cleanupHook = hook;\n        return this;\n    }\n\n    /**\n     * Set custom result renderer\n     */\n    renderResult(renderer: ToolResultRenderer): ToolBuilder {\n        this.renderer = renderer;\n        return this;\n    }\n\n    /**\n     * Add examples for better AI understanding\n     */\n    examples(examples: { description: string; arguments: ToolArguments; result?: string }[]): ToolBuilder {\n        this.examplesList = examples;\n        return this;\n    }\n\n    /**\n     * Build the tool definition\n     */\n    build(): ToolDefinition {\n        if (!this.metadata.id) {\n            throw new Error('Tool ID is required');\n        }\n\n        if (!this.metadata.name) {\n            this.metadata.name = this.metadata.id;\n        }\n\n        if (!this.metadata.description) {\n            throw new Error('Tool description is required');\n        }\n\n        if (!this.executor) {\n            throw new Error('Tool executor is required');\n        }\n\n        const tool: ToolDefinition = {\n            id: this.metadata.id,\n            name: this.metadata.name,\n            description: this.metadata.description,\n            version: this.metadata.version,\n            author: this.metadata.author,\n            tags: this.metadata.tags,\n            category: this.metadata.category,\n            capabilities: this.metadata.capabilities,\n            arguments: this.args.length > 0 ? this.args : undefined,\n            execute: this.executor,\n            composable: this.isComposable,\n            inputSchema: this.schemas.input,\n            outputSchema: this.schemas.output,\n            renderResult: this.renderer,\n            examples: this.examplesList\n        };\n\n        if (this.initHook) {\n            tool.initialize = this.initHook;\n        }\n\n        if (this.cleanupHook) {\n            tool.cleanup = this.cleanupHook;\n        }\n\n        return tool;\n    }\n}\n\n/**\n * Create a new tool builder\n */\nexport function createTool(): ToolBuilder {\n    return new ToolBuilder();\n}\n","/**\n * Adapters for converting between tool formats\n */\n\nimport { GrokTool } from '../clanker/client';\nimport {\n  ToolDefinition,\n  ArgumentSpec,\n  ToolCapability,\n  ToolRegistry,\n  ToolArguments,\n  ToolContext\n} from './types';\nimport { ToolResult } from '../types';\nimport { applyDefaults, coerceArguments } from './validation';\n\n/**\n * Convert a ToolDefinition to GrokTool format\n */\nexport function toolDefinitionToGrokTool(tool: ToolDefinition): GrokTool {\n  const properties: Record<string, unknown> = {};\n  const required: string[] = [];\n  \n  // Convert arguments to OpenAI function parameter format\n  if (tool.arguments) {\n    for (const arg of tool.arguments) {\n      properties[arg.name] = argumentSpecToProperty(arg);\n      \n      if (arg.required) {\n        required.push(arg.name);\n      }\n    }\n  }\n  \n  return {\n    type: \"function\",\n    function: {\n      name: tool.id,\n      description: generateToolDescription(tool),\n      parameters: {\n        type: \"object\",\n        properties,\n        required\n      }\n    }\n  };\n}\n\n/**\n * Convert ArgumentSpec to OpenAI property format\n */\nfunction argumentSpecToProperty(arg: ArgumentSpec): Record<string, unknown> {\n  const property: Record<string, unknown> = {\n    type: mapArgumentType(arg.type),\n    description: arg.description\n  };\n  \n  // Add enum values\n  if (arg.enum) {\n    property.enum = arg.enum;\n  }\n  \n  // Add default value\n  if (arg.default !== undefined) {\n    property.default = arg.default;\n  }\n  \n  return property;\n}\n\n/**\n * Map argument types to OpenAI types\n */\nfunction mapArgumentType(type: string): string {\n  switch (type) {\n    case 'any':\n      return 'string'; // OpenAI doesn't have 'any', use string as fallback\n    default:\n      return type;\n  }\n}\n\n/**\n * Generate a comprehensive description from ToolDefinition\n */\nfunction generateToolDescription(tool: ToolDefinition): string {\n  const parts: string[] = [tool.description];\n  \n  // Add capability information\n  if (tool.capabilities && tool.capabilities.length > 0) {\n    const capabilities = tool.capabilities\n      .map(cap => describeCapability(cap))\n      .filter(desc => desc)\n      .join(', ');\n    \n    if (capabilities) {\n      parts.push(`Capabilities: ${capabilities}`);\n    }\n  }\n  \n  // Add tags\n  if (tool.tags && tool.tags.length > 0) {\n    parts.push(`Tags: ${tool.tags.join(', ')}`);\n  }\n  \n  // Add examples\n  if (tool.examples && tool.examples.length > 0) {\n    parts.push('\\n\\nExamples:');\n    tool.examples.forEach((example, index) => {\n      parts.push(`\\nExample ${index + 1}: ${example.description}`);\n      parts.push(`Arguments: ${JSON.stringify(example.arguments, null, 2)}`);\n      if (example.result) {\n        parts.push(`Expected result: ${example.result}`);\n      }\n    });\n  }\n  \n  return parts.join('. ');\n}\n\n/**\n * Describe a capability in natural language\n */\nfunction describeCapability(capability: ToolCapability): string {\n  const descriptions: Record<ToolCapability, string> = {\n    [ToolCapability.FileRead]: 'read files',\n    [ToolCapability.FileWrite]: 'write files',\n    [ToolCapability.SystemExecute]: 'execute system commands',\n    [ToolCapability.NetworkAccess]: 'access network resources',\n    [ToolCapability.UserConfirmation]: 'request user confirmation'\n  };\n  \n  return descriptions[capability] || '';\n}\n\n/**\n * Generate all Grok tools from registry\n */\nexport function generateGrokTools(registry: ToolRegistry): GrokTool[] {\n  const tools = registry.list();\n  return tools.map(tool => toolDefinitionToGrokTool(tool));\n}\n\n/**\n * Create a legacy tool wrapper for backward compatibility\n */\nexport function createLegacyToolWrapper(\n  tool: ToolDefinition,\n  context: ToolContext\n): { name: string; description: string; execute: (...args: unknown[]) => Promise<ToolResult> } {\n  return {\n    name: tool.name,\n    description: tool.description,\n    \n    execute: async (...args: unknown[]): Promise<ToolResult> => {\n      // Convert positional arguments to named arguments\n      let namedArgs: ToolArguments = {};\n      \n      if (tool.arguments && args.length > 0) {\n        // If first arg is an object and we have multiple args defined,\n        // assume it contains all named arguments\n        if (typeof args[0] === 'object' && !Array.isArray(args[0]) && \n            tool.arguments.length > 1) {\n          namedArgs = args[0] as ToolArguments;\n        } else {\n          // Map positional args to named args\n          tool.arguments.forEach((spec, index) => {\n            if (index < args.length) {\n              namedArgs[spec.name] = args[index];\n            }\n          });\n        }\n      }\n      \n      // Apply defaults and coercion\n      namedArgs = applyDefaults(tool.arguments || [], namedArgs);\n      namedArgs = coerceArguments(tool.arguments || [], namedArgs);\n      \n      // Execute with context\n      return tool.execute(namedArgs, context);\n    }\n  };\n}\n\n/**\n * Create a tool execution wrapper for Grok agent\n */\nexport function createToolExecutor(registry: ToolRegistry) {\n  return async (toolName: string, args: unknown): Promise<ToolResult> => {\n    // Parse arguments if they come as a string\n    let parsedArgs = args;\n    if (typeof args === 'string') {\n      try {\n        parsedArgs = JSON.parse(args);\n      } catch {\n        parsedArgs = { input: args };\n      }\n    }\n    \n    return registry.execute(toolName, parsedArgs as ToolArguments);\n  };\n}\n\n/**\n * Create dynamic tool descriptions for prompts\n */\nexport function generateToolPromptSection(tools: ToolDefinition[]): string {\n  const sections: string[] = [\n    `You have access to ${tools.length} tools:`\n  ];\n  \n  // Group tools by category\n  const byCategory = new Map<string, ToolDefinition[]>();\n  const uncategorized: ToolDefinition[] = [];\n  \n  for (const tool of tools) {\n    if (tool.category) {\n      const existing = byCategory.get(tool.category) || [];\n      existing.push(tool);\n      byCategory.set(tool.category, existing);\n    } else {\n      uncategorized.push(tool);\n    }\n  }\n  \n  // Add categorized tools\n  for (const [category, categoryTools] of byCategory) {\n    sections.push(`\\n## ${category.charAt(0).toUpperCase() + category.slice(1)} Tools\\n`);\n    \n    for (const tool of categoryTools) {\n      sections.push(formatToolForPrompt(tool));\n    }\n  }\n  \n  // Add uncategorized tools\n  if (uncategorized.length > 0) {\n    sections.push('\\n## Other Tools\\n');\n    \n    for (const tool of uncategorized) {\n      sections.push(formatToolForPrompt(tool));\n    }\n  }\n  \n  // Add usage instructions\n  sections.push('\\n## Tool Usage\\n');\n  sections.push('- Always check tool arguments before calling');\n  sections.push('- Handle tool errors gracefully');\n  sections.push('- Use appropriate tools for the task');\n  sections.push('- Combine tools when needed for complex tasks');\n  \n  return sections.join('\\n');\n}\n\n/**\n * Format a single tool for prompt\n */\nfunction formatToolForPrompt(tool: ToolDefinition): string {\n  const lines: string[] = [\n    `### ${tool.name}`,\n    tool.description\n  ];\n  \n  if (tool.arguments && tool.arguments.length > 0) {\n    lines.push('\\nArguments:');\n    \n    for (const arg of tool.arguments) {\n      const required = arg.required ? ' (required)' : ' (optional)';\n      const defaultStr = arg.default !== undefined ? `, default: ${JSON.stringify(arg.default)}` : '';\n      \n      lines.push(`- ${arg.name}: ${arg.type}${required} - ${arg.description}${defaultStr}`);\n      \n      if (arg.enum) {\n        lines.push(`  Allowed values: ${arg.enum.join(', ')}`);\n      }\n    }\n  }\n  \n  if (tool.capabilities && tool.capabilities.length > 0) {\n    lines.push(`\\nRequires: ${tool.capabilities.map(c => describeCapability(c)).join(', ')}`);\n  }\n  \n  return lines.join('\\n');\n}\n","/**\n * Built-in tools registry\n * \n * As of v1.1.31, all core tools are now installed via the package manager\n * rather than being built into the CLI. This provides better modularity\n * and allows tools to be updated independently.\n * \n * This file remains for backward compatibility but exports empty arrays.\n */\n\nimport { ToolDefinition } from './types';\n\n// Array of all built-in tools - now empty as tools are loaded dynamically\nexport const builtInTools: ToolDefinition[] = [];\n\n// Map for quick lookup - now empty\nexport const builtInToolsMap = new Map<string, ToolDefinition>();","/**\n * Manifest-based tool loader for built-in tools\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { fileURLToPath } from 'url';\nimport { ToolDefinition } from './types';\nimport { debug } from '../utils/debug-logger';\n\ninterface ToolManifest {\n  version: string;\n  generated: string;\n  tools: Array<{\n    id: string;\n    module: string;\n  }>;\n}\n\nexport async function loadBuiltInToolsFromManifest(): Promise<ToolDefinition[]> {\n  const tools: ToolDefinition[] = [];\n  \n  try {\n    // Determine the base directory\n    let baseDir: string;\n    \n    // Check if we're in a bundled environment\n    if (typeof __dirname !== 'undefined') {\n      // CommonJS environment\n      baseDir = __dirname;\n    } else if (typeof import.meta.url !== 'undefined') {\n      // ES module environment\n      const __filename = fileURLToPath(import.meta.url);\n      baseDir = path.dirname(__filename);\n    } else {\n      // Fallback\n      baseDir = process.cwd();\n    }\n    \n    // Look for manifest in dist directory\n    // In bundled environment, we're in dist/index.js, so manifest is in same directory\n    // In dev environment, we're in src/registry/, so go up to find dist/\n    let manifestPath = path.join(baseDir, 'tool-manifest.json');\n    \n    if (!fs.existsSync(manifestPath)) {\n      // Try going up from registry folder (dev environment)\n      manifestPath = path.join(baseDir, '..', '..', 'dist', 'tool-manifest.json');\n    }\n    \n    debug.log(`[ManifestLoader] Looking for manifest at: ${manifestPath}`);\n    \n    if (!fs.existsSync(manifestPath)) {\n      debug.warn('[ManifestLoader] No tool manifest found, falling back to static imports');\n      // Fall back to using the static builtin-tools.ts\n      const { builtInTools } = await import('./builtin-tools');\n      return builtInTools;\n    }\n    \n    // Read and parse manifest\n    const manifestContent = fs.readFileSync(manifestPath, 'utf-8');\n    const manifest: ToolManifest = JSON.parse(manifestContent);\n    \n    debug.log(`[ManifestLoader] Found manifest with ${manifest.tools.length} tools`);\n    \n    // Load each tool from the manifest\n    for (const toolInfo of manifest.tools) {\n      try {\n        // In bundled environment, modules are relative to dist/\n        // In dev environment, they're relative to dist/ as well\n        const modulePath = path.isAbsolute(toolInfo.module) \n          ? toolInfo.module \n          : path.join(path.dirname(manifestPath), toolInfo.module);\n        debug.log(`[ManifestLoader] Loading tool ${toolInfo.id} from ${modulePath}`);\n        \n        // Dynamic import\n        const module = await import(modulePath);\n        const tool = module.default || module;\n        \n        if (isValidTool(tool)) {\n          tools.push(tool);\n          debug.log(`[ManifestLoader] Successfully loaded tool: ${tool.id}`);\n        } else {\n          debug.warn(`[ManifestLoader] Invalid tool in ${modulePath}`);\n        }\n      } catch (error) {\n        debug.error(`[ManifestLoader] Failed to load tool ${toolInfo.id}:`, error);\n      }\n    }\n    \n    debug.log(`[ManifestLoader] Loaded ${tools.length} tools from manifest`);\n    return tools;\n    \n  } catch (error) {\n    debug.error('[ManifestLoader] Error loading manifest:', error);\n    // Fall back to static imports\n    const { builtInTools } = await import('./builtin-tools');\n    return builtInTools;\n  }\n}\n\nfunction isValidTool(obj: any): obj is ToolDefinition {\n  return obj && \n         typeof obj === 'object' &&\n         typeof obj.id === 'string' &&\n         typeof obj.description === 'string' &&\n         typeof obj.execute === 'function';\n}","/**\n * Dynamic tool loader with clean, reusable directory scanning\n */\n\nimport * as fs from 'fs/promises';\nimport * as fsSync from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport * as crypto from 'crypto';\nimport {pathToFileURL} from 'url';\nimport {ToolDefinition, ToolRegistry} from './types';\nimport {debug} from '../utils/debug-logger';\nimport {loadBuiltInToolsFromManifest} from './manifest-loader';\n\n/**\n * Check if a module should be shared from the main clanker package\n */\nfunction shouldShareDependency(request: string): boolean {\n    // Share React and Ink\n    if (request === 'react' || request === 'ink' || request.startsWith('ink/')) {\n        return true;\n    }\n\n    // Share @ziggler/clanker and its exports\n    if (request === '@ziggler/clanker' || request.startsWith('@ziggler/clanker/')) {\n        return true;\n    }\n\n    // Share relative imports that are part of clanker's internal structure\n    if (request.startsWith('../../registry') || request.startsWith('../../utils/') ||\n        request.startsWith('../../ui/') || request.startsWith('../../store/')) {\n        return true;\n    }\n\n    // Share other common dependencies that tools might need\n    const sharedDeps = [\n        'chalk', 'fs-extra', 'zod', 'commander', 'dotenv',\n        'openai', 'axios', 'uuid', 'prismjs', 'immer'\n    ];\n\n    return sharedDeps.includes(request);\n}\n\n/**\n * Options for loading tools\n */\nexport interface LoaderOptions {\n    /**\n     * Base directories to search for tools\n     * Defaults to ['.', '~/.clank']\n     */\n    directories?: string[];\n\n    /**\n     * Whether to search recursively\n     * Defaults to true\n     */\n    recursive?: boolean;\n\n    /**\n     * File extensions to load\n     * Defaults to ['.ts', '.tsx', '.js', '.jsx']\n     */\n    extensions?: string[];\n\n    /**\n     * Whether to watch for changes\n     */\n    watch?: boolean;\n\n    /**\n     * Whether to load built-in tools\n     * Defaults to true\n     */\n    loadBuiltins?: boolean;\n}\n\n/**\n * Tool loader for dynamic tool discovery\n */\nexport class ToolLoader {\n    private options: Required<LoaderOptions>;\n    private loadedTools = new Map<string, { path: string; hash: string }>(); // toolId -> {filePath, hash}\n    private watcherCleanup: (() => void)[] = [];\n    private fileWatchers = new Map<string, fsSync.FSWatcher>(); // filePath -> watcher\n\n    constructor(private registry: ToolRegistry, options: LoaderOptions = {}) {\n        // Get user home directory in a cross-platform way\n        const homeDir = os.homedir();\n        const clankDir = path.join(homeDir, '.clanker');\n\n        this.options = {\n            directories: options.directories || [process.cwd(), clankDir],\n            recursive: options.recursive ?? true,\n            extensions: options.extensions || ['.ts', '.tsx', '.js', '.jsx'],\n            watch: options.watch ?? false,\n            loadBuiltins: options.loadBuiltins ?? true\n        };\n\n        debug.log(`[ToolLoader] Configured directories:`, this.options.directories);\n    }\n\n    /**\n     * Load all tools from configured directories\n     */\n    async loadTools(): Promise<void> {\n        // Load built-in tools first if enabled\n        if (this.options.loadBuiltins) {\n            await this.loadBuiltinTools();\n        }\n\n        // Load from each configured directory\n        for (const dir of this.options.directories) {\n            const toolsDir = path.join(dir, dir.endsWith('tools') ? '' : 'tools');\n            debug.log(`[ToolLoader] Loading from directory: ${dir} -> ${toolsDir}`);\n            await this.loadFromDirectory(toolsDir);\n        }\n\n        // Set up watchers if enabled\n        if (this.options.watch) {\n            await this.setupWatchers();\n        }\n    }\n\n    /**\n     * Load built-in tools from the package\n     */\n    private async loadBuiltinTools(): Promise<void> {\n        try {\n            // Try to load from manifest first, fall back to static imports\n            const tools = await loadBuiltInToolsFromManifest();\n\n            debug.log(`[ToolLoader] Loading ${tools.length} built-in tools`);\n\n            // Register all built-in tools directly\n            for (const tool of tools) {\n                if (this.isValidTool(tool)) {\n                    this.registry.register(tool);\n                    const registeredTool = this.registry.get(tool.id);\n                    if (registeredTool) {\n                        registeredTool.hash = 'builtin';\n                        registeredTool.filePath = `builtin:${tool.id}`;\n                    }\n                    this.loadedTools.set(tool.id, {path: `builtin:${tool.id}`, hash: 'builtin'});\n                    debug.log(`[ToolLoader] Loaded built-in tool: ${tool.id}`);\n                } else {\n                    debug.warn(`[ToolLoader] Invalid built-in tool`);\n                }\n            }\n\n            debug.log(`[ToolLoader] Successfully loaded ${tools.length} built-in tools`);\n        } catch (error) {\n            debug.warn('[ToolLoader] Failed to load built-in tools:', error);\n        }\n    }\n\n    /**\n     * Load tools from a directory\n     */\n    private async loadFromDirectory(directory: string): Promise<void> {\n        // Early return if directory doesn't exist\n        if (!await this.exists(directory)) {\n            debug.log(`[ToolLoader] Directory does not exist: ${directory}`);\n            return;\n        }\n\n        debug.log(`[ToolLoader] Scanning directory: ${directory}`);\n        try {\n            await this.scanDirectory(directory, this.options.recursive);\n        } catch (error) {\n            debug.error(`[ToolLoader] Error scanning directory ${directory}:`, error);\n        }\n    }\n\n    /**\n     * Recursively scan a directory for tool files\n     */\n    private async scanDirectory(directory: string, recursive: boolean): Promise<void> {\n        let entries: fsSync.Dirent[];\n\n        try {\n            entries = await fs.readdir(directory, {withFileTypes: true});\n        } catch (error) {\n            // Directory not accessible, skip silently\n            return;\n        }\n\n        // Check if this is a package-managed tool directory with 'current' symlink\n        const currentLink = entries.find(entry => entry.name === 'current' && entry.isSymbolicLink());\n        if (currentLink) {\n            // This is a versioned tool directory, load from current version\n            const currentPath = path.join(directory, 'current', 'index.js');\n            if (await this.exists(currentPath)) {\n                debug.log(`[ToolLoader] Found package-managed tool at ${currentPath}`);\n                await this.loadToolFile(currentPath);\n                return; // Don't scan subdirectories for versioned tools\n            }\n        }\n\n        // Process files first\n        const files = entries\n            .filter(entry => entry.isFile() && this.isToolFile(entry.name))\n            .map(entry => path.join(directory, entry.name));\n\n        debug.log(`[ToolLoader] Found ${files.length} tool files in ${directory}`);\n        for (const file of files) {\n            await this.loadToolFile(file);\n        }\n\n        // Process subdirectories if recursive\n        if (!recursive) return;\n\n        const subdirs = entries\n            .filter(entry => entry.isDirectory())\n            .map(entry => path.join(directory, entry.name));\n\n        for (const subdir of subdirs) {\n            await this.scanDirectory(subdir, true);\n        }\n    }\n\n    /**\n     * Load a single tool file\n     */\n    private async loadToolFile(filePath: string): Promise<void> {\n        try {\n            debug.log(`[ToolLoader] Attempting to load: ${filePath}`);\n\n            // Compute file hash\n            const fileHash = await this.computeFileHash(filePath);\n            debug.log(`[ToolLoader] File hash for ${filePath}: ${fileHash.substring(0, 8)}...`);\n\n            // Check if tool is already loaded with same hash\n            const existingEntry = Array.from(this.loadedTools.entries())\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                .find(([_, info]) => info.path === filePath);\n\n            if (existingEntry && existingEntry[1].hash === fileHash) {\n                debug.log(`[ToolLoader] Tool already loaded with same version: ${existingEntry[0]}`);\n                return;\n            }\n\n            // Dynamic import\n            const moduleExports = await this.importModule(filePath);\n            debug.log(`[ToolLoader] Module exports for ${filePath}:`, Object.keys(moduleExports));\n\n            const tool = await this.extractTool(moduleExports);\n\n            if (!tool) {\n                debug.warn(`[ToolLoader] No valid tool found in ${filePath}`);\n                return;\n            }\n\n            debug.log(`[ToolLoader] Extracted tool:`, {id: tool.id, name: tool.name});\n\n            // Validate tool\n            if (!this.isValidTool(tool)) {\n                debug.warn(`[ToolLoader] Invalid tool in ${filePath}`);\n                return;\n            }\n\n            // Unload old version if exists\n            if (this.loadedTools.has(tool.id)) {\n                const oldInfo = this.loadedTools.get(tool.id)!;\n                if (oldInfo.hash !== fileHash) {\n                    debug.log(`[ToolLoader] Tool ${tool.id} has changed, unloading old version`);\n                    await this.unloadTool(tool.id);\n                } else {\n                    debug.log(`[ToolLoader] Tool ${tool.id} unchanged, skipping reload`);\n                    return;\n                }\n            }\n\n            // Register the tool with hash info\n            this.registry.register(tool);\n            const registeredTool = this.registry.get(tool.id);\n            if (registeredTool) {\n                registeredTool.hash = fileHash;\n                registeredTool.filePath = filePath;\n            }\n\n            this.loadedTools.set(tool.id, {path: filePath, hash: fileHash});\n\n            debug.log(`[ToolLoader] Loaded tool: ${tool.id} from ${filePath}`);\n        } catch (error) {\n            debug.error(`[ToolLoader] Failed to load ${filePath}:`, error);\n        }\n    }\n\n    /**\n     * Import a module handling TypeScript if needed\n     */\n    private async importModule(filePath: string): Promise<any> {\n        try {\n            // For .js files in production, try different approaches\n            if (filePath.endsWith('.js')) {\n                // First try createRequire which works in ESM context\n                try {\n                    const {createRequire} = await import('module');\n                    // Use process.cwd() as fallback if import.meta.url is not available\n                    const baseUrl = typeof import.meta !== 'undefined' && import.meta.url\n                        ? import.meta.url\n                        : pathToFileURL(process.cwd() + '/').href;\n                    const require = createRequire(baseUrl);\n\n                    // Set up custom module resolution for shared dependencies\n                    const loadedModule = this.loadWithSharedDependencies(require, filePath);\n\n                    debug.log(`[ToolLoader] Loaded ${filePath} using createRequire with shared deps`);\n                    return loadedModule;\n                } catch (error) {\n                    debug.log(`[ToolLoader] createRequire failed for ${filePath}:`, error);\n                }\n\n                // Try Node.js require directly (for CommonJS modules)\n                try {\n                    // Use eval to avoid bundler trying to resolve require\n                    const requireFunc = eval('require');\n                    const loadedModule = this.loadWithSharedDependencies(requireFunc, filePath);\n                    debug.log(`[ToolLoader] Loaded ${filePath} using direct require with shared deps`);\n                    return loadedModule;\n                } catch (error) {\n                    debug.log(`[ToolLoader] Direct require failed for ${filePath}:`, error);\n                }\n\n                // Try dynamic import with file URL\n                try {\n                    const fileUrl = pathToFileURL(filePath).href;\n                    const module = await import(fileUrl);\n                    debug.log(`[ToolLoader] Loaded ${filePath} using dynamic import`);\n                    return module;\n                } catch (error) {\n                    debug.log(`[ToolLoader] Dynamic import failed for ${filePath}:`, error);\n                }\n            }\n\n            // For TypeScript files (.ts, .tsx), use dynamic import\n            const fileUrl = pathToFileURL(filePath).href;\n            const module = await import(fileUrl);\n            return module;\n        } catch (error) {\n            debug.error(`[ToolLoader] Import error for ${filePath}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Extract tool from module exports\n     */\n    private async extractTool(moduleExports: any): Promise<ToolDefinition | null> {\n        // Handle default export\n        if (moduleExports.default) {\n            const defaultExport = moduleExports.default;\n\n            // If it's a function, call it\n            if (typeof defaultExport === 'function') {\n                try {\n                    const result = await defaultExport();\n                    if (this.isValidTool(result)) return result;\n                } catch {\n                    // Function might not be callable, try as tool\n                    if (this.isValidTool(defaultExport)) {\n                        return defaultExport;\n                    }\n                }\n            }\n\n            // If it's already a tool\n            if (this.isValidTool(defaultExport)) {\n                return defaultExport;\n            }\n\n            // If it's an array of tools, take the first one\n            if (Array.isArray(defaultExport) && defaultExport.length > 0) {\n                const firstTool = defaultExport[0];\n                if (this.isValidTool(firstTool)) return firstTool;\n            }\n        }\n\n        // Handle named exports\n        const namedExports = ['tool', 'createTool'];\n        for (const exportName of namedExports) {\n            if (exportName in moduleExports) {\n                const exported = moduleExports[exportName];\n\n                if (typeof exported === 'function') {\n                    try {\n                        const result = await exported();\n                        if (this.isValidTool(result)) return result;\n                    } catch {\n                        // Not callable\n                    }\n                }\n\n                if (this.isValidTool(exported)) {\n                    return exported;\n                }\n            }\n        }\n\n        // Check if the module itself is a tool\n        if (this.isValidTool(moduleExports)) {\n            return moduleExports;\n        }\n\n        return null;\n    }\n\n    /**\n     * Validate if an object is a valid tool\n     */\n    private isValidTool(obj: any): obj is ToolDefinition {\n        return obj &&\n            typeof obj === 'object' &&\n            typeof obj.id === 'string' &&\n            typeof obj.description === 'string' &&\n            typeof obj.execute === 'function';\n    }\n\n    /**\n     * Check if a file should be loaded as a tool\n     */\n    private isToolFile(filename: string): boolean {\n        return this.options.extensions.some(ext => filename.endsWith(ext));\n    }\n\n    /**\n     * Check if a path exists\n     */\n    private async exists(path: string): Promise<boolean> {\n        try {\n            await fs.access(path);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Compute hash of a file\n     */\n    private async computeFileHash(filePath: string): Promise<string> {\n        try {\n            const content = await fs.readFile(filePath);\n            return crypto.createHash('sha256').update(content).digest('hex');\n        } catch (error) {\n            debug.error(`[ToolLoader] Failed to compute hash for ${filePath}:`, error);\n            return '';\n        }\n    }\n\n    /**\n     * Unload a tool and run cleanup\n     */\n    private async unloadTool(toolId: string): Promise<void> {\n        debug.log(`[ToolLoader] Unloading tool: ${toolId}`);\n\n        const tool = this.registry.get(toolId);\n        if (tool && tool.definition.cleanup) {\n            try {\n                const context = {\n                    registry: this.registry,\n                    workingDirectory: process.cwd()\n                };\n                await tool.definition.cleanup(context);\n                debug.log(`[ToolLoader] Cleanup completed for ${toolId}`);\n            } catch (error) {\n                debug.error(`[ToolLoader] Cleanup failed for ${toolId}:`, error);\n            }\n        }\n\n        // Unregister from registry\n        await this.registry.unregister(toolId);\n\n        // Remove from loaded tools\n        this.loadedTools.delete(toolId);\n    }\n\n    /**\n     * Reload all tools (for --watch-tools command)\n     */\n    async reloadAllTools(): Promise<void> {\n        debug.log('[ToolLoader] Reloading all tools...');\n\n        // Unload all currently loaded tools\n        const toolIds = Array.from(this.loadedTools.keys());\n        for (const toolId of toolIds) {\n            // Skip built-in tools\n            if (this.loadedTools.get(toolId)?.path.startsWith('builtin:')) {\n                continue;\n            }\n            await this.unloadTool(toolId);\n        }\n\n        // Clear module cache for dynamic imports\n        if (typeof require !== 'undefined' && require.cache) {\n            for (const [toolId, info] of this.loadedTools) {\n                if (info.path && !info.path.startsWith('builtin:')) {\n                    delete require.cache[info.path];\n                }\n            }\n        }\n\n        // Reload all tools\n        await this.loadTools();\n\n        debug.log('[ToolLoader] Tool reload complete');\n    }\n\n    /**\n     * Set up file watchers for hot reloading\n     */\n    private async setupWatchers(): Promise<void> {\n        const {watch} = await import('fs');\n\n        for (const dir of this.options.directories) {\n            const toolsDir = path.join(dir, dir.endsWith('tools') ? '' : 'tools');\n\n            if (!await this.exists(toolsDir)) continue;\n\n            const watcher = watch(toolsDir, {recursive: true}, async (eventType, filename) => {\n                if (!filename || !this.isToolFile(filename)) return;\n\n                const filePath = path.join(toolsDir, filename);\n\n                try {\n                    const stats = await fs.stat(filePath);\n                    if (stats.isFile()) {\n                        debug.log(`[ToolLoader] Reloading ${filename}...`);\n                        await this.loadToolFile(filePath);\n                    }\n                } catch {\n                    // File was deleted, unregister if loaded\n                    const toolId = this.findToolByPath(filePath);\n                    if (toolId) {\n                        await this.registry.unregister(toolId);\n                        this.loadedTools.delete(toolId);\n                        debug.log(`[ToolLoader] Unregistered ${toolId}`);\n                    }\n                }\n            });\n\n            // Store cleanup function\n            this.watcherCleanup.push(() => watcher.close());\n        }\n    }\n\n    /**\n     * Find tool ID by file path\n     */\n    private findToolByPath(filePath: string): string | undefined {\n        for (const [toolId, info] of this.loadedTools.entries()) {\n            if (info.path === filePath) return toolId;\n        }\n        return undefined;\n    }\n\n    /**\n     * Get loaded tools info\n     */\n    getLoadedTools(): Array<{ toolId: string; filePath: string; hash: string }> {\n        return Array.from(this.loadedTools.entries()).map(([toolId, info]) => ({\n            toolId,\n            filePath: info.path,\n            hash: info.hash\n        }));\n    }\n\n    /**\n     * Reload all tools\n     */\n    async reloadTools(): Promise<void> {\n        debug.log('[ToolLoader] Reloading all tools...');\n\n        // Store current tools\n        const currentTools = new Map(this.loadedTools);\n\n        // Clear loaded tools\n        this.loadedTools.clear();\n\n        // Reload each tool\n        for (const [_, info] of currentTools) {\n            if (!info.path.startsWith('builtin:')) {\n                await this.loadToolFile(info.path);\n            }\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    async cleanup(): Promise<void> {\n        // Close all watchers\n        for (const cleanup of this.watcherCleanup) {\n            cleanup();\n        }\n        this.watcherCleanup = [];\n\n        // Clear loaded tools\n        this.loadedTools.clear();\n    }\n\n    /**\n     * Load a module with shared dependencies from the main clanker package\n     */\n    private loadWithSharedDependencies(requireFunc: any, filePath: string): any {\n        const Module = requireFunc('module');\n        const originalResolveFilename = Module._resolveFilename;\n\n        // Create a custom resolver that shares dependencies from main clanker\n        Module._resolveFilename = function (request: string, parent: any, isMain: boolean) {\n            // Check if this is a dependency that should be shared\n            if (shouldShareDependency(request)) {\n                try {\n                    // Try to resolve from the main clanker module context\n                    // This allows tools to use React, Ink, and other deps from clanker\n                    const mainModule = require.main || module;\n                    return originalResolveFilename.call(this, request, mainModule, false);\n                } catch (e) {\n                    // If that fails, try from the current module context\n                    try {\n                        return originalResolveFilename.call(this, request, module, false);\n                    } catch (e2) {\n                        debug.log(`[ToolLoader] Failed to resolve shared dependency ${request}`);\n                    }\n                }\n            }\n\n            // Fall back to normal resolution\n            return originalResolveFilename.call(this, request, parent, isMain);\n        };\n\n        try {\n            // Clear cache to ensure fresh load\n            delete requireFunc.cache[filePath];\n            const loadedModule = requireFunc(filePath);\n            return loadedModule;\n        } finally {\n            // Always restore original resolution\n            Module._resolveFilename = originalResolveFilename;\n        }\n    }\n\n    /**\n     * Create a tool template file\n     */\n    static async createToolTemplate(toolName: string, baseDir: string = process.cwd()): Promise<void> {\n        const toolsDir = path.join(baseDir, '.clank', 'tools');\n\n        // Ensure directory exists\n        await fs.mkdir(toolsDir, {recursive: true});\n\n        const fileName = `${toolName}.ts`;\n        const filePath = path.join(toolsDir, fileName);\n\n        // Check if file already exists\n        try {\n            await fs.access(filePath);\n            throw new Error(`Tool file already exists: ${filePath}`);\n        } catch (error: any) {\n            if (error.code !== 'ENOENT') throw error;\n        }\n\n        // Create template content\n        const template = `/**\n * ${toolName} tool\n * \n * This is a template for creating a custom tool.\n * Edit this file to implement your tool's functionality.\n */\n\nimport { createTool, ToolCategory, ToolCapability } from '@ziggle/clanker';\n\n// Using the builder API\nexport default createTool()\n  .id('${toolName}')\n  .name('${toolName.charAt(0).toUpperCase() + toolName.slice(1)} Tool')\n  .description('Description of what this tool does')\n  .category(ToolCategory.Utility)\n  .capabilities(ToolCapability.FileRead)\n  .tags('custom', 'example')\n  \n  // Define arguments\n  .stringArg('input', 'Input value', { required: true })\n  .booleanArg('verbose', 'Enable verbose output', { default: false })\n  \n  // Define the execution logic\n  .execute(async (args, context) => {\n    const { input, verbose } = args;\n    \n    if (verbose) {\n      context.logger?.debug('Processing input:', input);\n    }\n    \n    // Your tool logic here\n    const result = \\`Processed: \\${input}\\`;\n    \n    return {\n      success: true,\n      output: result,\n      data: { processed: result }\n    };\n  })\n  .build();\n`;\n\n        await fs.writeFile(filePath, template, 'utf-8');\n        debug.log(`Created tool template: ${filePath}`);\n    }\n}\n\n/**\n * Create a tool loader instance\n */\nexport function createToolLoader(registry: ToolRegistry, options?: LoaderOptions): ToolLoader {\n    return new ToolLoader(registry, options);\n}","/**\n * Dynamic Tool Registry System\n * \n * This module provides a unified API for registering, discovering, and executing tools\n * with support for composition, validation, and dynamic prompt generation.\n */\n\nexport * from './types';\nexport * from './registry';\nexport * from './builder';\nexport * from './composition';\nexport * from './adapters';\nexport * from './validation';\nexport * from './loader';\nexport * from './logger';","/**\n * Enhanced tool executor with retry logic and intelligent error correction\n */\n\nimport {ToolRegistry, ToolArguments} from './types';\nimport {ToolResult} from '../types';\nimport {debug} from '../utils/debug-logger';\n\ninterface RetryContext {\n    toolName: string;\n    originalArgs: ToolArguments;\n    attempt: number;\n    previousErrors: Array<{\n        error: string;\n        args: ToolArguments;\n    }>;\n}\n\n/**\n * Analyze error and suggest argument corrections\n */\nfunction analyzeErrorAndSuggestFix(error: string, args: ToolArguments, toolName: string): ToolArguments | null {\n    const errorLower = error.toLowerCase();\n\n    // Handle quoting issues in bash/input commands\n    if ((toolName === 'bash' || toolName === 'input') &&\n        (errorLower.includes('unexpected eof') || errorLower.includes('matching'))) {\n        // Try to fix quoting issues\n        if (args.command && typeof args.command === 'string') {\n            // Escape single quotes properly\n            const fixed = args.command.replace(/'/g, \"'\\\"'\\\"'\");\n            return {...args, command: fixed};\n        }\n        if (args.prompt && typeof args.prompt === 'string') {\n            // For input tool, escape quotes\n            const fixed = args.prompt.replace(/\"/g, '\\\\\"').replace(/'/g, \"\\\\'\");\n            return {...args, prompt: fixed};\n        }\n    }\n\n    // Handle file not found errors\n    if (errorLower.includes('no such file') || errorLower.includes('not found') ||\n        errorLower.includes('does not exist')) {\n        // For file operations, try different path variations\n        if (args.path || args.file_path) {\n            const originalPath = (args.path || args.file_path) as string;\n\n            // Try without leading ./\n            if (originalPath.startsWith('./')) {\n                return {...args, path: originalPath.substring(2), file_path: originalPath.substring(2)};\n            }\n\n            // Try with ./ prefix\n            if (!originalPath.startsWith('/') && !originalPath.startsWith('./')) {\n                return {...args, path: './' + originalPath, file_path: './' + originalPath};\n            }\n\n            // Try with different extensions\n            if (toolName === 'search' && args.query) {\n                // If searching for a file, try different patterns\n                const query = args.query as string;\n                if (!query.includes('*')) {\n                    return {...args, query: `*${query}*`};\n                }\n            }\n        }\n    }\n\n    // Handle permission errors\n    if (errorLower.includes('permission denied') || errorLower.includes('access denied')) {\n        // For bash commands, try with sudo (but be careful)\n        if (toolName === 'bash' && args.command && typeof args.command === 'string') {\n            const cmd = args.command as string;\n            if (!cmd.startsWith('sudo ')) {\n                debug.warn('[RetryExecutor] Permission denied, but NOT auto-adding sudo for safety');\n                // Don't auto-add sudo, but suggest it in the error\n                return null;\n            }\n        }\n    }\n\n    // Handle argument type errors\n    if (errorLower.includes('invalid argument') || errorLower.includes('type error')) {\n        // Try to coerce types\n        const newArgs = {...args};\n        for (const [key, value] of Object.entries(newArgs)) {\n            if (typeof value === 'string' && value.match(/^\\d+$/)) {\n                // Try converting string numbers to actual numbers\n                newArgs[key] = parseInt(value, 10);\n            }\n        }\n        return newArgs;\n    }\n\n    return null;\n}\n\n/**\n * Generate fallback suggestions after max retries\n */\nfunction generateFallbackSuggestions(context: RetryContext): string {\n    const {toolName, originalArgs, previousErrors} = context;\n    const suggestions: string[] = [];\n\n    // Analyze the pattern of errors\n    const lastError = previousErrors[previousErrors.length - 1]?.error || '';\n\n    const preamble = `After ${context.attempt} attempts, the last error was: \"${lastError}, the original arguments were: ${JSON.stringify(originalArgs)}\"`\n\n    if (toolName === 'search') {\n        suggestions.push(\n            'Try using the list tool to explore the directory structure',\n            'Use the bash tool with \"find . -name \\'*pattern*\\'\" for a broader search',\n            'Check if the file has a different extension (e.g., .txt instead of .md)'\n        );\n    } else if (toolName === 'read_file' || toolName === 'view_file') {\n        suggestions.push(\n            'Use the list tool to verify the file exists in the expected location',\n            'Try the pwd tool to confirm the current working directory',\n            'Use bash with \"ls -la\" to see all files including hidden ones'\n        );\n    } else if (toolName === 'bash') {\n        if (lastError.includes('command not found')) {\n            suggestions.push(\n                'Check if the command is installed with \"which <command>\"',\n                'Try using the full path to the command',\n                'Consider using an alternative command'\n            );\n        } else if (lastError.includes('permission')) {\n            suggestions.push(\n                'The command may require elevated permissions',\n                'Try a different approach that doesn\\'t require special permissions',\n                'Check file ownership and permissions with \"ls -la\"'\n            );\n        }\n    } else if (toolName === 'input') {\n        suggestions.push(\n            'The input dialog may not be supported in this environment',\n            'Consider asking the user to provide the information directly in their message',\n            'Try a simpler prompt without special characters'\n        );\n    }\n\n    // General suggestions\n    suggestions.push(\n        'Review the error messages for clues about what went wrong',\n        'Consider breaking down the task into smaller steps',\n        'Ask the user for clarification or additional information'\n    );\n\n    return `${preamble}. Consider these alternative approaches:\\n${suggestions.map(s => `- ${s}`).join('\\n')}`;\n}\n\n/**\n * Create an enhanced tool executor with retry logic\n */\nexport function createRetryToolExecutor(registry: ToolRegistry) {\n    return async (toolName: string, args: ToolArguments, maxRetries: number = 5): Promise<ToolResult> => {\n        const context: RetryContext = {\n            toolName,\n            originalArgs: args,\n            attempt: 0,\n            previousErrors: []\n        };\n\n        let currentArgs = args;\n\n        while (context.attempt < maxRetries) {\n            context.attempt++;\n            debug.log(`[RetryExecutor] Attempt ${context.attempt} for ${toolName}`);\n\n            try {\n                const result = await registry.execute(toolName, currentArgs);\n\n                if (result.success) {\n                    if (context.attempt > 1) {\n                        debug.log(`[RetryExecutor] Succeeded on attempt ${context.attempt}`);\n                    }\n                    return result;\n                }\n\n                // Tool executed but returned an error\n                const error = result.error || 'Unknown error';\n                context.previousErrors.push({error, args: currentArgs});\n\n                debug.warn(`[RetryExecutor] Tool ${toolName} failed: ${error}`);\n\n                // Try to fix the error\n                const fixedArgs = analyzeErrorAndSuggestFix(error, currentArgs, toolName);\n\n                if (fixedArgs && context.attempt < maxRetries) {\n                    debug.log(`[RetryExecutor] Attempting to fix error with modified arguments`);\n                    currentArgs = fixedArgs;\n                    continue;\n                }\n\n                // Can't fix automatically, but still have retries\n                if (context.attempt < maxRetries) {\n                    debug.log(`[RetryExecutor] No automatic fix available, retrying with original args`);\n                    currentArgs = args;\n                    continue;\n                }\n\n                // Max retries reached\n                const fallbackMsg = generateFallbackSuggestions(context);\n                return {\n                    success: false,\n                    error: `${error}\\n\\n${fallbackMsg}`,\n                    data: {\n                        attempts: context.attempt,\n                        errors: context.previousErrors\n                    }\n                };\n\n            } catch (error) {\n                // Unexpected error during execution\n                const errorMsg = error instanceof Error ? error.message : String(error);\n                context.previousErrors.push({error: errorMsg, args: currentArgs});\n\n                debug.error(`[RetryExecutor] Unexpected error: ${errorMsg}`);\n\n                if (context.attempt >= maxRetries) {\n                    const fallbackMsg = generateFallbackSuggestions(context);\n                    return {\n                        success: false,\n                        error: `Execution failed: ${errorMsg}\\n\\n${fallbackMsg}`,\n                        data: {\n                            attempts: context.attempt,\n                            errors: context.previousErrors\n                        }\n                    };\n                }\n            }\n        }\n\n        // Should not reach here, but just in case\n        return {\n            success: false,\n            error: 'Max retries exceeded',\n            data: {\n                attempts: context.attempt,\n                errors: context.previousErrors\n            }\n        };\n    };\n}\n\n/**\n * Try to fix malformed JSON\n */\nfunction tryFixJson(jsonString: string): string | null {\n    // Remove trailing non-JSON characters after the last }\n    let cleaned = jsonString.replace(/\\}[^}]*$/, '}');\n    \n    // Try to extract JSON object from string\n    const jsonMatch = cleaned.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n        return jsonMatch[0];\n    }\n    \n    // If it's just whitespace, return empty object\n    if (!cleaned.trim()) {\n        return '{}';\n    }\n    \n    return null;\n}\n\n/**\n * Wrapper for the standard createToolExecutor that adds retry logic\n */\nexport function createToolExecutorWithRetry(registry: ToolRegistry) {\n    const retryExecutor = createRetryToolExecutor(registry);\n\n    return async (toolName: string, args: unknown): Promise<ToolResult> => {\n        // Parse arguments if they come as a string\n        let parsedArgs = args;\n        if (typeof args === 'string') {\n            try {\n                parsedArgs = JSON.parse(args);\n            } catch (error) {\n                // Try to fix common JSON errors\n                const fixed = tryFixJson(args as string);\n                if (fixed) {\n                    try {\n                        parsedArgs = JSON.parse(fixed);\n                    } catch {\n                        // If still fails, check if tool accepts no arguments\n                        const tool = registry.get(toolName);\n                        if (tool && (!tool.definition.arguments || tool.definition.arguments.length === 0)) {\n                            parsedArgs = {};\n                        } else {\n                            parsedArgs = {input: args};\n                        }\n                    }\n                } else {\n                    parsedArgs = {input: args};\n                }\n            }\n        }\n\n        // Use retry executor with default 5 retries\n        return retryExecutor(toolName, parsedArgs as ToolArguments, 5);\n    };\n}","import { get_encoding, encoding_for_model, Tiktoken, TiktokenModel } from 'tiktoken';\n\nexport class TokenCounter {\n  private encoder: Tiktoken;\n\n  constructor(model: string = 'gpt-4') {\n    try {\n      // Try to get encoding for specific model\n      this.encoder = encoding_for_model(model as TiktokenModel);\n    } catch {\n      // Fallback to cl100k_base (used by GPT-4 and most modern models)\n      this.encoder = get_encoding('cl100k_base');\n    }\n  }\n\n  /**\n   * Count tokens in a string\n   */\n  countTokens(text: string): number {\n    if (!text) return 0;\n    return this.encoder.encode(text).length;\n  }\n\n  /**\n   * Count tokens in messages array (for chat completions)\n   */\n  countMessageTokens(messages: Array<{ role: string; content: string | null; tool_calls?: unknown; [key: string]: unknown }>): number {\n    let totalTokens = 0;\n    \n    for (const message of messages) {\n      // Every message follows <|start|>{role/name}\\n{content}<|end|\\>\\n\n      totalTokens += 3; // Base tokens per message\n      \n      if (message.content && typeof message.content === 'string') {\n        totalTokens += this.countTokens(message.content);\n      }\n      \n      if (message.role) {\n        totalTokens += this.countTokens(message.role);\n      }\n      \n      // Add extra tokens for tool calls if present\n      if (message.tool_calls) {\n        totalTokens += this.countTokens(JSON.stringify(message.tool_calls));\n      }\n    }\n    \n    totalTokens += 3; // Every reply is primed with <|start|>assistant<|message|>\n    \n    return totalTokens;\n  }\n\n  /**\n   * Estimate tokens for streaming content\n   * This is an approximation since we don't have the full response yet\n   */\n  estimateStreamingTokens(accumulatedContent: string): number {\n    return this.countTokens(accumulatedContent);\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose(): void {\n    this.encoder.free();\n  }\n}\n\n/**\n * Format token count for display (e.g., 1.2k for 1200)\n */\nexport function formatTokenCount(count: number): string {\n  if (count <= 999) {\n    return count.toString();\n  }\n  \n  if (count < 1_000_000) {\n    const k = count / 1000;\n    return k % 1 === 0 ? `${k}k` : `${k.toFixed(1)}k`;\n  }\n  \n  const m = count / 1_000_000;\n  return m % 1 === 0 ? `${m}m` : `${m.toFixed(1)}m`;\n}\n\n/**\n * Create a token counter instance\n */\nexport function createTokenCounter(model?: string): TokenCounter {\n  return new TokenCounter(model);\n}","/**\n * GrokAgent implementation with dynamic tool registry\n */\n\nimport {GrokClient, GrokTool, GrokMessage, GrokToolCall} from './client';\nimport {ToolResult} from '../types';\nimport {\n    ToolRegistry,\n    createToolRegistry,\n    ToolLoader,\n    createToolLoader,\n    generateGrokTools\n} from '../registry';\nimport { createToolExecutorWithRetry } from '../registry/retry-executor';\nimport {EventEmitter} from 'events';\nimport {TokenCounter, createTokenCounter} from '../utils/token-counter';\nimport {debug} from '../utils/debug-logger';\nimport * as path from 'path';\n\n\ninterface GrokAgentOptions {\n    apiKey: string;\n    baseURL?: string;\n    model?: string;\n    maxToolRounds?: number;\n    systemPrompt?: string;\n    loadDynamicTools?: boolean;\n    dynamicToolsPath?: string;\n    watchTools?: boolean;\n}\n\nexport interface StreamingChunk {\n    type: 'content' | 'tool_calls' | 'tool_result' | 'done' | 'token_count';\n    content?: string;\n    toolCalls?: GrokToolCall[];\n    toolCall?: GrokToolCall;\n    toolResult?: ToolResult;\n    tokenCount?: number;\n}\n\nexport class GrokAgent extends EventEmitter {\n    private client: GrokClient;\n    private model: string;\n    private maxToolRounds: number;\n    private registry: ToolRegistry;\n    private toolLoader?: ToolLoader;\n    private executeToolWithRegistry: (name: string, args: Record<string, unknown>) => Promise<ToolResult>;\n    private tokenCounter: TokenCounter;\n\n    constructor(options: GrokAgentOptions) {\n        super();\n        this.client = new GrokClient(\n            options.apiKey,\n            options.model,\n            options.baseURL\n        );\n        this.model = options.model || 'grok-3-latest';\n        this.maxToolRounds = options.maxToolRounds || 30;\n        this.tokenCounter = createTokenCounter(this.model);\n\n        // Create registry\n        this.registry = createToolRegistry();\n\n        // Create tool executor with retry logic\n        this.executeToolWithRegistry = createToolExecutorWithRetry(this.registry);\n\n        // Create tool loader with appropriate directories\n        const directories: string[] = [];\n\n        // Always include ~/.clanker\n        const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n        if (homeDir) {\n            directories.push(path.join(homeDir, '.clanker'));\n        }\n\n        // Add custom path if specified\n        if (options.dynamicToolsPath) {\n            directories.push(options.dynamicToolsPath);\n        }\n\n        // Add current directory if dynamic tools enabled\n        if (options.loadDynamicTools) {\n            directories.push(process.cwd());\n        }\n\n        // Create loader\n        this.toolLoader = createToolLoader(this.registry, {\n            directories: directories.length > 0 ? directories : undefined,\n            recursive: true,\n            watch: options.watchTools ?? false,\n            loadBuiltins: true\n        });\n\n        // Tools will be loaded when needed via waitForToolsToLoad()\n    }\n\n\n    async chat(\n        messages: GrokMessage[],\n        systemPrompt?: string,\n        stream: boolean = false\n    ): Promise<string | AsyncGenerator<StreamingChunk, void, unknown>> {\n        const allMessages: GrokMessage[] = [];\n\n        // Add system prompt if provided\n        if (systemPrompt) {\n            allMessages.push({role: 'system', content: systemPrompt});\n        }\n\n        // Add user messages\n        allMessages.push(...messages);\n\n        // Get tool definitions from registry\n        const tools = generateGrokTools(this.registry);\n\n        if (stream) {\n            return this.streamChat(allMessages, tools);\n        } else {\n            return this.nonStreamChat(allMessages, tools);\n        }\n    }\n\n    private async* streamChat(\n        messages: GrokMessage[],\n        tools: GrokTool[]\n    ): AsyncGenerator<StreamingChunk, void, unknown> {\n        let rounds = 0;\n        let currentMessages = [...messages];\n        let totalTokens = this.tokenCounter.countMessageTokens(currentMessages as never); // Start with initial message tokens\n\n        while (rounds < this.maxToolRounds) {\n            // Use real streaming from Grok API\n            const stream = this.client.chatStream(\n                currentMessages,\n                tools.length > 0 ? tools : undefined,\n                this.model\n            );\n\n            let accumulatedContent = '';\n            const accumulatedToolCalls: GrokToolCall[] = [];\n            let currentToolCall: Partial<GrokToolCall> | null = null;\n            let lastFinishReason: string | null = null;\n\n            // Process the stream\n            for await (const chunk of stream) {\n                // Skip chunks without choices or delta\n                if (!chunk.choices || chunk.choices.length === 0 || !chunk.choices[0].delta) {\n                    continue;\n                }\n\n                // Handle tool calls\n                if (chunk.choices[0].delta.tool_calls) {\n                    for (const toolCallDelta of chunk.choices[0].delta.tool_calls) {\n                        if (toolCallDelta.index === 0 && !currentToolCall) {\n                            currentToolCall = {\n                                id: toolCallDelta.id,\n                                type: 'function' as const,\n                                function: {\n                                    name: toolCallDelta.function?.name || '',\n                                    arguments: toolCallDelta.function?.arguments || ''\n                                }\n                            };\n                        } else if (currentToolCall && toolCallDelta.function?.arguments) {\n                            currentToolCall.function!.arguments += toolCallDelta.function.arguments;\n                        }\n                    }\n                }\n\n                // Handle content streaming\n                if (chunk.choices[0].delta.content !== undefined && chunk.choices[0].delta.content !== null) {\n                    const content = chunk.choices[0].delta.content;\n                    accumulatedContent += content;\n\n                    yield {\n                        type: 'content',\n                        content\n                    };\n\n                    // Update token count in real-time\n                    const currentOutputTokens = this.tokenCounter.estimateStreamingTokens(accumulatedContent) +\n                        (accumulatedToolCalls.length > 0 ? this.tokenCounter.countTokens(JSON.stringify(accumulatedToolCalls)) : 0);\n\n                    yield {\n                        type: 'token_count',\n                        tokenCount: totalTokens + currentOutputTokens\n                    };\n                }\n\n                // Check for finish reason\n                if (chunk.choices[0].finish_reason) {\n                    lastFinishReason = chunk.choices[0].finish_reason;\n                    if (currentToolCall) {\n                        accumulatedToolCalls.push(currentToolCall as GrokToolCall);\n                    }\n                    break;\n                }\n            }\n\n            // Process accumulated results\n            if (accumulatedToolCalls.length > 0) {\n                // Emit tool calls\n                yield {\n                    type: 'tool_calls',\n                    toolCalls: accumulatedToolCalls\n                };\n\n                // Execute tool calls\n                const toolResults = await this.executeToolCalls(accumulatedToolCalls);\n\n                // Add assistant message\n                const assistantMessage = {\n                    role: 'assistant',\n                    content: accumulatedContent || '',\n                    tool_calls: accumulatedToolCalls\n                } as GrokMessage;\n                currentMessages.push(assistantMessage);\n\n                // Update total tokens to include the assistant message\n                totalTokens = this.tokenCounter.countMessageTokens(currentMessages as never);\n\n                // Add tool results and emit them\n                for (let i = 0; i < toolResults.length; i++) {\n                    const toolResult = toolResults[i];\n\n                    yield {\n                        type: 'tool_result',\n                        toolCall: accumulatedToolCalls[i],\n                        toolResult\n                    };\n\n                    const toolMessage = {\n                        role: 'tool',\n                        content: this.formatToolResult(toolResult),\n                        tool_call_id: accumulatedToolCalls[i].id\n                    } as GrokMessage;\n                    currentMessages.push(toolMessage);\n\n                    // Update total tokens after each tool result\n                    totalTokens = this.tokenCounter.countMessageTokens(currentMessages as never);\n\n                    // Emit updated token count\n                    yield {\n                        type: 'token_count',\n                        tokenCount: totalTokens\n                    };\n                }\n\n                rounds++;\n                currentToolCall = null;\n                debug.log(`[Agent] Tool execution complete, continuing to round ${rounds}`);\n                // Continue the loop to get assistant's response about the tool results\n            } else if (accumulatedContent) {\n                // No tool calls but we have content, we're done\n                yield {\n                    type: 'done'\n                };\n                return;\n            } else if (lastFinishReason === 'tool_calls') {\n                // Grok API quirk: finish_reason is tool_calls but no actual tool calls\n                // This seems to happen on the first round, continue to get actual response\n                rounds++;\n            } else {\n                // No tool calls and no content, we're done\n                yield {\n                    type: 'done'\n                };\n                return;\n            }\n        }\n\n        throw new Error(`Maximum tool rounds (${this.maxToolRounds}) exceeded`);\n    }\n\n    private async nonStreamChat(\n        messages: GrokMessage[],\n        tools: GrokTool[]\n    ): Promise<string> {\n        let rounds = 0;\n        let currentMessages = [...messages];\n\n        while (rounds < this.maxToolRounds) {\n            const response = await this.client.chat(\n                currentMessages,\n                tools.length > 0 ? tools : undefined,\n                this.model\n            );\n\n            const message = response.choices[0]?.message;\n            if (!message) {\n                throw new Error('No response from API');\n            }\n\n            if (message.tool_calls && message.tool_calls.length > 0) {\n                // Execute tool calls\n                const toolResults = await this.executeToolCalls(message.tool_calls);\n\n                // Add assistant message\n                currentMessages.push({\n                    role: 'assistant',\n                    content: message.content,\n                    tool_calls: message.tool_calls\n                } as GrokMessage);\n\n                // Add tool results\n                for (let i = 0; i < toolResults.length; i++) {\n                    currentMessages.push({\n                        role: 'tool',\n                        content: this.formatToolResult(toolResults[i]),\n                        tool_call_id: message.tool_calls[i].id\n                    } as GrokMessage);\n                }\n\n                rounds++;\n            } else {\n                // No tool calls, return the content\n                return message.content || '';\n            }\n        }\n\n        throw new Error(`Maximum tool rounds (${this.maxToolRounds}) exceeded`);\n    }\n\n    private async executeToolCalls(toolCalls: GrokToolCall[]): Promise<ToolResult[]> {\n        const results: ToolResult[] = [];\n\n        for (const toolCall of toolCalls) {\n            try {\n                const result = await this.executeTool(toolCall);\n                results.push(result);\n            } catch (error) {\n                results.push({\n                    success: false,\n                    error: `Tool execution error: ${error instanceof Error ? error.message : String(error)}`\n                });\n            }\n        }\n\n        return results;\n    }\n\n    async executeTool(toolCall: GrokToolCall): Promise<ToolResult> {\n        const toolName = toolCall.function.name;\n\n        // Safely parse arguments\n        let args: Record<string, unknown>;\n        try {\n            args = JSON.parse(toolCall.function.arguments);\n        } catch (error) {\n            debug.error(`[Agent] Failed to parse arguments for ${toolName}:`);\n            debug.error(`[Agent] Raw arguments: ${JSON.stringify(toolCall.function.arguments)}`);\n            debug.error(`[Agent] Error: ${error}`);\n            \n            // Get tool info to provide better error message\n            const tool = this.registry.get(toolName);\n            // const hasRequiredArgs = tool?.definition.arguments?.some(arg => arg.required) ?? false;\n            \n            // Build helpful error message\n            let errorMessage = `Failed to parse JSON arguments: ${error instanceof Error ? error.message : String(error)}`;\n            errorMessage += `\\n\\nThe raw arguments were: ${toolCall.function.arguments}`;\n            \n            if (tool) {\n                errorMessage += `\\n\\nTool \"${toolName}\" expects:`;\n                if (!tool.definition.arguments || tool.definition.arguments.length === 0) {\n                    errorMessage += '\\n- No arguments required (use empty object: {})';\n                } else {\n                    tool.definition.arguments.forEach(arg => {\n                        errorMessage += `\\n- ${arg.name}: ${arg.type}${arg.required ? ' (required)' : ' (optional)'}`;\n                        if (arg.description) {\n                            errorMessage += ` - ${arg.description}`;\n                        }\n                    });\n                }\n            }\n            \n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n\n        return this.executeToolWithRegistry(toolName, args);\n    }\n\n    private formatToolResult(result: ToolResult): string {\n        if (result.success) {\n            return result.output || JSON.stringify(result.data) || 'Success';\n        } else {\n            return `Error: ${result.error}`;\n        }\n    }\n\n    // Public API for registry access\n    getRegistry(): ToolRegistry {\n        return this.registry;\n    }\n    \n    async waitForToolsToLoad(): Promise<void> {\n        if (this.toolLoader) {\n            await this.toolLoader.loadTools();\n        }\n    }\n\n    // Get tool statistics\n    getToolStats(): Record<string, { executionCount: number; totalDuration: number }> {\n        // Type assertion to access the implementation's getExecutionStats method\n        const registryImpl = this.registry as ToolRegistry & {\n            getExecutionStats(): Record<string, { executionCount: number; totalDuration: number }>\n        };\n        return registryImpl.getExecutionStats();\n    }\n\n    // Get the underlying Grok client\n    getClient(): GrokClient {\n        return this.client;\n    }\n\n    // Reload dynamic tools\n    async reloadDynamicTools(): Promise<void> {\n        if (this.toolLoader) {\n            await this.toolLoader.reloadAllTools();\n        }\n    }\n\n    // Clean up resources\n    dispose(): void {\n        this.tokenCounter.dispose();\n        if (this.toolLoader) {\n            this.toolLoader.cleanup();\n        }\n    }\n}","/**\n * Repository manager for handling multiple tool registries\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { debug } from '../utils/debug-logger';\n\ninterface Repository {\n    url: string;\n    name: string;\n    description?: string;\n    enabled: boolean;\n    addedAt: string;\n}\n\ninterface RepositorySettings {\n    repositories: Repository[];\n    defaultRepository: string;\n}\n\nconst DEFAULT_REPOSITORY: Repository = {\n    url: 'https://github.com/ziggle-dev/clanker-tools',\n    name: 'Official Clanker Tools',\n    description: 'The official Clanker tool registry',\n    enabled: true,\n    addedAt: new Date().toISOString()\n};\n\nconst CORE_TOOLS_REPOSITORY: Repository = {\n    url: 'https://github.com/ziggle-dev/clanker-core-tools',\n    name: 'clanker-core-tools',\n    description: 'Core tools for Clanker CLI',\n    enabled: true,\n    addedAt: new Date().toISOString()\n};\n\nexport class RepositoryManager {\n    private settingsPath: string;\n    private settings: RepositorySettings;\n    \n    constructor() {\n        this.settingsPath = path.join(os.homedir(), '.clanker', 'settings.json');\n    }\n    \n    private async loadSettings(): Promise<void> {\n        try {\n            const content = await fs.readFile(this.settingsPath, 'utf8');\n            const allSettings = JSON.parse(content);\n            \n            // Initialize repositories if not present\n            if (!allSettings.repositories) {\n                allSettings.repositories = [DEFAULT_REPOSITORY];\n                allSettings.defaultRepository = DEFAULT_REPOSITORY.url;\n                await this.saveSettings(allSettings);\n            }\n            \n            // Ensure core tools repository is present (for v0.1.31+)\n            const hasCoreTools = allSettings.repositories.some(r => \n                r.url === 'https://github.com/ziggle-dev/clanker-core-tools'\n            );\n            if (!hasCoreTools) {\n                allSettings.repositories.push(CORE_TOOLS_REPOSITORY);\n                await this.saveSettings(allSettings);\n            }\n            \n            this.settings = {\n                repositories: allSettings.repositories,\n                defaultRepository: allSettings.defaultRepository || DEFAULT_REPOSITORY.url\n            };\n            \n        } catch (error) {\n            // Settings file doesn't exist, create with defaults\n            debug.log('[RepositoryManager] Creating default settings');\n            this.settings = {\n                repositories: [DEFAULT_REPOSITORY],\n                defaultRepository: DEFAULT_REPOSITORY.url\n            };\n            \n            await this.ensureSettingsDir();\n            await this.saveSettings({\n                repositories: this.settings.repositories,\n                defaultRepository: this.settings.defaultRepository\n            });\n        }\n    }\n    \n    private async saveSettings(allSettings: any): Promise<void> {\n        // Merge repository settings with existing settings\n        const existingSettings = await this.loadExistingSettings();\n        const mergedSettings = {\n            ...existingSettings,\n            repositories: allSettings.repositories || this.settings.repositories,\n            defaultRepository: allSettings.defaultRepository || this.settings.defaultRepository\n        };\n        \n        await fs.writeFile(this.settingsPath, JSON.stringify(mergedSettings, null, 2));\n    }\n    \n    private async loadExistingSettings(): Promise<any> {\n        try {\n            const content = await fs.readFile(this.settingsPath, 'utf8');\n            return JSON.parse(content);\n        } catch {\n            return {};\n        }\n    }\n    \n    private async ensureSettingsDir(): Promise<void> {\n        const dir = path.dirname(this.settingsPath);\n        await fs.mkdir(dir, { recursive: true });\n    }\n    \n    async addRepository(repoUrl: string): Promise<void> {\n        await this.loadSettings();\n        \n        // Normalize URL\n        repoUrl = repoUrl.trim();\n        if (!repoUrl.startsWith('http://') && !repoUrl.startsWith('https://')) {\n            repoUrl = `https://github.com/${repoUrl}`;\n        }\n        \n        // Check if already exists\n        const existing = this.settings.repositories.find(r => r.url === repoUrl);\n        if (existing) {\n            console.log(`⚠️  Repository already exists: ${existing.name}`);\n            return;\n        }\n        \n        // Extract name from URL\n        const urlParts = repoUrl.split('/');\n        const repoName = urlParts[urlParts.length - 1] || 'Custom Repository';\n        \n        // Add new repository\n        const newRepo: Repository = {\n            url: repoUrl,\n            name: repoName,\n            description: `Custom repository: ${repoUrl}`,\n            enabled: true,\n            addedAt: new Date().toISOString()\n        };\n        \n        this.settings.repositories.push(newRepo);\n        \n        const allSettings = await this.loadExistingSettings();\n        allSettings.repositories = this.settings.repositories;\n        allSettings.defaultRepository = this.settings.defaultRepository;\n        \n        await this.saveSettings(allSettings);\n        \n        console.log(`✅ Added repository: ${newRepo.name}`);\n        console.log(`   URL: ${repoUrl}`);\n        console.log(`\\n💡 Note: Repository priority is determined by order in settings.json`);\n        console.log(`   The official repository remains the highest priority by default.`);\n    }\n    \n    async removeRepository(repoUrl: string): Promise<void> {\n        await this.loadSettings();\n        \n        // Normalize URL\n        repoUrl = repoUrl.trim();\n        if (!repoUrl.startsWith('http://') && !repoUrl.startsWith('https://')) {\n            repoUrl = `https://github.com/${repoUrl}`;\n        }\n        \n        // Prevent removing default repository\n        if (repoUrl === DEFAULT_REPOSITORY.url) {\n            console.error('❌ Cannot remove the official Clanker repository');\n            return;\n        }\n        \n        // Find and remove\n        const index = this.settings.repositories.findIndex(r => r.url === repoUrl);\n        if (index === -1) {\n            console.error('❌ Repository not found:', repoUrl);\n            return;\n        }\n        \n        const removed = this.settings.repositories.splice(index, 1)[0];\n        \n        const allSettings = await this.loadExistingSettings();\n        allSettings.repositories = this.settings.repositories;\n        \n        await this.saveSettings(allSettings);\n        \n        console.log(`✅ Removed repository: ${removed.name}`);\n    }\n    \n    async listRepositories(): Promise<void> {\n        await this.loadSettings();\n        \n        console.log('📦 Configured Repositories:\\n');\n        \n        this.settings.repositories.forEach((repo, index) => {\n            const isDefault = repo.url === this.settings.defaultRepository;\n            const priority = index + 1;\n            \n            console.log(`${priority}. ${repo.name}${isDefault ? ' (default)' : ''}`);\n            console.log(`   URL: ${repo.url}`);\n            if (repo.description) {\n                console.log(`   Description: ${repo.description}`);\n            }\n            console.log(`   Status: ${repo.enabled ? '✅ Enabled' : '❌ Disabled'}`);\n            console.log(`   Added: ${new Date(repo.addedAt).toLocaleDateString()}`);\n            console.log();\n        });\n        \n        console.log('💡 Tip: Repository search priority follows the order shown above.');\n        console.log('   Edit ~/.clanker/settings.json to change the priority order.');\n    }\n    \n    async getRepositories(): Promise<Repository[]> {\n        await this.loadSettings();\n        return this.settings.repositories.filter(r => r.enabled);\n    }\n    \n    async getDefaultRepository(): Promise<string> {\n        await this.loadSettings();\n        return this.settings.defaultRepository;\n    }\n}","/**\n * Registry client for fetching tool information from GitHub\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { debug } from '../utils/debug-logger';\nimport { \n  ToolRegistry, \n  ToolPackageMetadata, \n  ToolIdentifier,\n  PackageManagerOptions \n} from './types';\nimport { RepositoryManager } from './repository-manager';\n\nexport class RegistryClient {\n  private registryUrl: string;\n  private cacheDir: string;\n  private cacheTimeout: number = 1000; // 1 second for testing\n  private repoManager: RepositoryManager;\n\n  constructor(options: PackageManagerOptions = {}) {\n    this.registryUrl = options.registryUrl || 'https://raw.githubusercontent.com/ziggle-dev/clanker-tools/main';\n    this.cacheDir = options.cacheDir || path.join(process.env.HOME || '', '.clanker', 'cache');\n    this.repoManager = new RepositoryManager();\n  }\n\n  /**\n   * Fetch the tool registry from all configured repositories\n   */\n  async fetchRegistry(): Promise<ToolRegistry> {\n    const repositories = await this.repoManager.getRepositories();\n    const allTools: ToolRegistry['tools'] = [];\n    const errors: string[] = [];\n    \n    // Fetch from each repository in priority order\n    for (const repo of repositories) {\n      try {\n        debug.log(`[Registry] Fetching from ${repo.name}`);\n        const registryUrl = this.getRegistryUrl(repo.url);\n        const cacheFile = path.join(this.cacheDir, `registry-${this.hashUrl(repo.url)}.json`);\n        \n        // Check cache first\n        try {\n          const cached = await this.readCache<ToolRegistry>(cacheFile);\n          if (cached) {\n            debug.log(`[Registry] Using cached registry for ${repo.name}`);\n            allTools.push(...cached.tools);\n            continue;\n          }\n        } catch {\n          debug.log(`[Registry] Cache miss for ${repo.name}`);\n        }\n        \n        // Try to fetch from GitHub releases first\n        let registry: ToolRegistry | null = null;\n        \n        if (repo.url.includes('github.com')) {\n          registry = await this.fetchFromGitHubReleases(repo);\n        }\n        \n        // Fallback to registry.json if no releases\n        if (!registry) {\n          const url = `${registryUrl}/registry.json`;\n          const response = await fetch(url);\n          \n          if (!response.ok) {\n            throw new Error(`Failed to fetch from ${repo.name}: ${response.statusText}`);\n          }\n          \n          registry = await response.json() as ToolRegistry;\n        }\n        \n        // Cache the result\n        await this.writeCache(cacheFile, registry);\n        \n        // Add tools from this repository\n        allTools.push(...registry.tools);\n        \n      } catch (error) {\n        const errorMsg = `Failed to fetch from ${repo.name}: ${error instanceof Error ? error.message : String(error)}`;\n        debug.error(`[Registry] ${errorMsg}`);\n        errors.push(errorMsg);\n      }\n    }\n    \n    if (allTools.length === 0 && errors.length > 0) {\n      throw new Error(`Failed to fetch from any repository:\\n${errors.join('\\n')}`);\n    }\n    \n    // Deduplicate tools (first repository wins)\n    const uniqueTools = new Map<string, typeof allTools[0]>();\n    for (const tool of allTools) {\n      const key = `${tool.org}/${tool.name}`;\n      if (!uniqueTools.has(key)) {\n        uniqueTools.set(key, tool);\n      }\n    }\n    \n    return {\n      version: '1.0.0',\n      tools: Array.from(uniqueTools.values()),\n      updated: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Fetch metadata for a specific tool from repositories\n   */\n  async fetchToolMetadata(tool: ToolIdentifier): Promise<ToolPackageMetadata> {\n    debug.log(`[Registry] Fetching metadata for ${tool.org}/${tool.name}`);\n    \n    // First try to get from registry (which uses releases)\n    const registry = await this.fetchRegistry();\n    debug.log(`[Registry] Found ${registry.tools.length} tools in registry`);\n    \n    const toolInfo = registry.tools.find(t => \n      t.org === tool.org && t.name === tool.name\n    );\n    \n    if (toolInfo) {\n      debug.log(`[Registry] Found tool in registry:`, toolInfo);\n      // Convert registry format to metadata format\n      const version = toolInfo.version || toolInfo.latest || '1.0.0';\n      debug.log(`[Registry] Converting toolInfo to metadata. Version: ${version}`);\n      const metadata = {\n        id: toolInfo.id || `${toolInfo.org}/${toolInfo.name}`,\n        name: `${toolInfo.org}-clanker-tool-${toolInfo.name}`,\n        description: toolInfo.description,\n        author: toolInfo.author || 'Unknown',\n        homepage: toolInfo.homepage || toolInfo.repository || '',\n        repository: toolInfo.repository || '',\n        latest: version,\n        versions: {\n          [version]: {\n            date: toolInfo.updated || toolInfo.created || new Date().toISOString(),\n            minClankerVersion: '0.1.0',\n            sha256: 'example-hash-will-be-computed'\n          }\n        },\n        tags: toolInfo.keywords || []\n      };\n      debug.log(`[Registry] Created metadata:`, JSON.stringify(metadata, null, 2));\n      return metadata;\n    }\n    \n    // Fallback to old method for backward compatibility\n    const repositories = await this.repoManager.getRepositories();\n    const errors: string[] = [];\n    \n    // Try each repository in priority order\n    for (const repo of repositories) {\n      try {\n        const registryUrl = this.getRegistryUrl(repo.url);\n        const cacheFile = path.join(this.cacheDir, 'tools', `${this.hashUrl(repo.url)}-${tool.org}-${tool.name}.json`);\n        \n        // Check cache first\n        try {\n          const cached = await this.readCache<ToolPackageMetadata>(cacheFile);\n          if (cached) {\n            debug.log(`[Registry] Using cached metadata for ${tool.org}/${tool.name} from ${repo.name}`);\n            return cached;\n          }\n        } catch {\n          debug.log(`[Registry] Cache miss for ${tool.org}/${tool.name} from ${repo.name}`);\n        }\n        \n        // Fetch from repository\n        const url = `${registryUrl}/tools/${tool.org}/${tool.name}/metadata.json`;\n        const response = await fetch(url);\n        \n        if (!response.ok) {\n          throw new Error(`Not found in ${repo.name}`);\n        }\n        \n        const metadata = await response.json() as ToolPackageMetadata;\n        \n        // Cache the result\n        await this.writeCache(cacheFile, metadata);\n        \n        return metadata;\n        \n      } catch (error) {\n        const errorMsg = `${repo.name}: ${error instanceof Error ? error.message : String(error)}`;\n        debug.log(`[Registry] ${errorMsg}`);\n        errors.push(errorMsg);\n      }\n    }\n    \n    // Tool not found in any repository\n    throw new Error(`Tool not found: ${tool.org}/${tool.name}\\nSearched in:\\n${errors.join('\\n')}`);\n  }\n\n  /**\n   * Download a tool file from repositories\n   */\n  async downloadTool(tool: ToolIdentifier, version: string): Promise<Buffer> {\n    const repositories = await this.repoManager.getRepositories();\n    const errors: string[] = [];\n    \n    // Try each repository in priority order\n    for (const repo of repositories) {\n      try {\n        // Try to download from releases first\n        if (repo.url.includes('github.com')) {\n          const releaseBuffer = await this.downloadFromRelease(repo, tool, version);\n          if (releaseBuffer) {\n            return releaseBuffer;\n          }\n        }\n        \n        // Fallback to raw content\n        const registryUrl = this.getRegistryUrl(repo.url);\n        const url = `${registryUrl}/tools/${tool.org}/${tool.name}/${version}/index.js`;\n        \n        debug.log(`[Registry] Downloading ${tool.org}/${tool.name}@${version} from ${repo.name} (raw)`);\n        \n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`Not found in ${repo.name}: ${response.statusText}`);\n        }\n        \n        const buffer = await response.arrayBuffer();\n        return Buffer.from(buffer);\n        \n      } catch (error) {\n        const errorMsg = `${repo.name}: ${error instanceof Error ? error.message : String(error)}`;\n        debug.log(`[Registry] ${errorMsg}`);\n        errors.push(errorMsg);\n      }\n    }\n    \n    // Tool not found in any repository\n    throw new Error(`Failed to download tool ${tool.org}/${tool.name}@${version}\\nTried:\\n${errors.join('\\n')}`);\n  }\n  \n  /**\n   * Download tool from GitHub release\n   */\n  private async downloadFromRelease(repo: any, tool: ToolIdentifier, version: string): Promise<Buffer | null> {\n    try {\n      const match = repo.url.match(/github\\.com\\/([^/]+)\\/([^/]+)/);\n      if (!match) return null;\n      \n      const [, owner, repoName] = match;\n      \n      // Get the release (use cached if available)\n      let release = (this as any).currentRelease;\n      \n      if (!release) {\n        const releaseUrl = `https://api.github.com/repos/${owner}/${repoName}/releases/latest`;\n        const releaseResponse = await fetch(releaseUrl, {\n          headers: {\n            'Accept': 'application/vnd.github.v3+json',\n            ...(process.env.GITHUB_TOKEN && {\n              'Authorization': `token ${process.env.GITHUB_TOKEN}`\n            })\n          }\n        });\n        \n        if (!releaseResponse.ok) {\n          return null;\n        }\n        \n        release = await releaseResponse.json();\n      }\n      \n      // Look for the org archive\n      const orgAsset = release.assets?.find((asset: any) => \n        asset.name === `${tool.org}.tar.gz`\n      );\n      \n      if (!orgAsset) {\n        debug.log(`[Registry] No ${tool.org}.tar.gz in release`);\n        return null;\n      }\n      \n      // Download the archive\n      debug.log(`[Registry] Downloading ${tool.org}.tar.gz from release`);\n      const response = await fetch(orgAsset.browser_download_url);\n      \n      if (!response.ok) {\n        throw new Error(`Failed to download archive: ${response.statusText}`);\n      }\n      \n      const buffer = await response.arrayBuffer();\n      return Buffer.from(buffer);\n      \n    } catch (error) {\n      debug.error(`[Registry] Error downloading from release:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Search for tools in the registry\n   */\n  async searchTools(query: string): Promise<ToolRegistry['tools']> {\n    const registry = await this.fetchRegistry();\n    \n    const lowerQuery = query.toLowerCase();\n    return registry.tools.filter(tool => \n      tool.name.toLowerCase().includes(lowerQuery) ||\n      tool.description.toLowerCase().includes(lowerQuery) ||\n      tool.org.toLowerCase().includes(lowerQuery)\n    );\n  }\n\n  /**\n   * Read from cache\n   */\n  private async readCache<T>(filePath: string): Promise<T | null> {\n    try {\n      const stat = await fs.stat(filePath);\n      const age = Date.now() - stat.mtime.getTime();\n      \n      if (age > this.cacheTimeout) {\n        debug.log(`[Registry] Cache expired for ${filePath}`);\n        return null;\n      }\n      \n      const content = await fs.readFile(filePath, 'utf-8');\n      return JSON.parse(content) as T;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Write to cache\n   */\n  private async writeCache<T>(filePath: string, data: T): Promise<void> {\n    try {\n      await fs.mkdir(path.dirname(filePath), { recursive: true });\n      await fs.writeFile(filePath, JSON.stringify(data, null, 2));\n    } catch (error) {\n      debug.warn(`[Registry] Failed to write cache for ${filePath}:`, error);\n    }\n  }\n\n  /**\n   * Clear cache\n   */\n  async clearCache(): Promise<void> {\n    try {\n      await fs.rm(this.cacheDir, { recursive: true, force: true });\n      debug.log('[Registry] Cache cleared');\n    } catch (error) {\n      debug.warn('[Registry] Failed to clear cache:', error);\n    }\n  }\n  \n  /**\n   * Get registry URL from repository URL\n   */\n  private getRegistryUrl(repoUrl: string): string {\n    // Convert GitHub repo URL to raw content URL\n    if (repoUrl.includes('github.com')) {\n      const match = repoUrl.match(/github\\.com\\/([^/]+)\\/([^/]+)/);\n      if (match) {\n        const [, owner, repo] = match;\n        return `https://raw.githubusercontent.com/${owner}/${repo}/main`;\n      }\n    }\n    \n    // If it's already a raw URL or other format, use as-is\n    return repoUrl;\n  }\n  \n  /**\n   * Hash URL for cache file naming\n   */\n  private hashUrl(url: string): string {\n    // Simple hash for filename\n    let hash = 0;\n    for (let i = 0; i < url.length; i++) {\n      const char = url.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return Math.abs(hash).toString(16);\n  }\n  \n  /**\n   * Fetch tools from GitHub releases\n   */\n  private async fetchFromGitHubReleases(repo: any): Promise<ToolRegistry | null> {\n    try {\n      const match = repo.url.match(/github\\.com\\/([^/]+)\\/([^/]+)/);\n      if (!match) return null;\n      \n      const [, owner, repoName] = match;\n      debug.log(`[Registry] Checking for releases in ${owner}/${repoName}`);\n      \n      // Get latest release\n      const releaseUrl = `https://api.github.com/repos/${owner}/${repoName}/releases/latest`;\n      const releaseResponse = await fetch(releaseUrl, {\n        headers: {\n          'Accept': 'application/vnd.github.v3+json',\n          ...(process.env.GITHUB_TOKEN && {\n            'Authorization': `token ${process.env.GITHUB_TOKEN}`\n          })\n        }\n      });\n      \n      if (!releaseResponse.ok) {\n        debug.log(`[Registry] No releases found for ${repo.name} (${releaseResponse.status})`);\n        return null;\n      }\n      \n      const release = await releaseResponse.json() as any;\n      \n      // Find tools.json asset\n      const toolsAsset = release.assets?.find((asset: any) => \n        asset.name === 'tools.json'\n      );\n      \n      if (!toolsAsset) {\n        debug.log(`[Registry] No tools.json in release for ${repo.name}`);\n        return null;\n      }\n      \n      // Download tools.json\n      debug.log(`[Registry] Downloading tools.json from release ${release.tag_name}`);\n      const toolsResponse = await fetch(toolsAsset.browser_download_url);\n      \n      if (!toolsResponse.ok) {\n        throw new Error(`Failed to download tools.json: ${toolsResponse.statusText}`);\n      }\n      \n      const toolsIndex = await toolsResponse.json() as any;\n      \n      // Store release info for later use in downloadTool\n      (this as any).currentRelease = release;\n      \n      // Transform to our format\n      return {\n        version: toolsIndex.version || '1.0.0',\n        tools: toolsIndex.tools || [],\n        updated: toolsIndex.timestamp || new Date().toISOString()\n      };\n      \n    } catch (error) {\n      debug.error(`[Registry] Error fetching from releases:`, error);\n      return null;\n    }\n  }\n}","/**\n * Version resolver for tool dependencies and version constraints\n */\n\nimport { ToolPackageMetadata, VersionInfo } from './types';\n\nexport class VersionResolver {\n  /**\n   * Parse a version string (e.g., \"1.2.3\", \"latest\", \"^1.2.0\")\n   */\n  parseVersionSpec(spec: string): { \n    type: 'exact' | 'latest' | 'range';\n    value: string;\n  } {\n    if (spec === 'latest') {\n      return { type: 'latest', value: 'latest' };\n    }\n    \n    if (spec.startsWith('^') || spec.startsWith('~') || spec.includes('*')) {\n      return { type: 'range', value: spec };\n    }\n    \n    return { type: 'exact', value: spec };\n  }\n\n  /**\n   * Resolve a version spec to an exact version\n   */\n  resolveVersion(metadata: ToolPackageMetadata, spec: string): string {\n    const parsed = this.parseVersionSpec(spec);\n    \n    switch (parsed.type) {\n      case 'latest':\n        return metadata.latest;\n        \n      case 'exact':\n        if (!metadata.versions[parsed.value]) {\n          throw new Error(`Version ${parsed.value} not found for ${metadata.id}`);\n        }\n        return parsed.value;\n        \n      case 'range':\n        return this.resolveVersionRange(metadata, parsed.value);\n    }\n  }\n\n  /**\n   * Resolve a version range to the best matching version\n   */\n  private resolveVersionRange(metadata: ToolPackageMetadata, range: string): string {\n    const versions = Object.keys(metadata.versions);\n    \n    // Sort versions in descending order\n    const sortedVersions = versions.sort((a, b) => \n      this.compareVersions(b, a)\n    );\n    \n    // For now, implement simple range matching\n    if (range.startsWith('^')) {\n      // Compatible with version (same major)\n      const baseVersion = range.substring(1);\n      const [major] = baseVersion.split('.');\n      \n      for (const version of sortedVersions) {\n        if (version.startsWith(major + '.')) {\n          return version;\n        }\n      }\n    } else if (range.startsWith('~')) {\n      // Approximately equivalent (same major.minor)\n      const baseVersion = range.substring(1);\n      const [major, minor] = baseVersion.split('.');\n      \n      for (const version of sortedVersions) {\n        if (version.startsWith(`${major}.${minor}.`)) {\n          return version;\n        }\n      }\n    }\n    \n    // Fallback to latest\n    return metadata.latest;\n  }\n\n  /**\n   * Compare two version strings\n   */\n  compareVersions(a: string, b: string): number {\n    const partsA = a.split('.').map(Number);\n    const partsB = b.split('.').map(Number);\n    \n    for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {\n      const partA = partsA[i] || 0;\n      const partB = partsB[i] || 0;\n      \n      if (partA > partB) return 1;\n      if (partA < partB) return -1;\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Check if a version satisfies a constraint\n   */\n  satisfiesVersion(version: string, constraint: string): boolean {\n    const parsed = this.parseVersionSpec(constraint);\n    \n    switch (parsed.type) {\n      case 'exact':\n        return version === parsed.value;\n        \n      case 'latest':\n        return true; // Any version satisfies \"latest\"\n        \n      case 'range':\n        return this.versionInRange(version, parsed.value);\n    }\n  }\n\n  /**\n   * Check if a version is within a range\n   */\n  private versionInRange(version: string, range: string): boolean {\n    if (range.startsWith('^')) {\n      const baseVersion = range.substring(1);\n      const [baseMajor] = baseVersion.split('.');\n      const [versionMajor] = version.split('.');\n      return baseMajor === versionMajor && this.compareVersions(version, baseVersion) >= 0;\n    }\n    \n    if (range.startsWith('~')) {\n      const baseVersion = range.substring(1);\n      const [baseMajor, baseMinor] = baseVersion.split('.');\n      const [versionMajor, versionMinor] = version.split('.');\n      return baseMajor === versionMajor && \n             baseMinor === versionMinor && \n             this.compareVersions(version, baseVersion) >= 0;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Check Clanker version compatibility\n   */\n  checkClankerCompatibility(versionInfo: VersionInfo, currentClankerVersion: string): boolean {\n    if (!versionInfo.minClankerVersion) {\n      return true;\n    }\n    \n    return this.compareVersions(currentClankerVersion, versionInfo.minClankerVersion) >= 0;\n  }\n}","/**\n * Experimental tool support for testing unmerged PRs and staging branches\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { debug } from '../utils/debug-logger';\nimport { \n  ToolIdentifier, \n  InstalledTool,\n  PackageManagerOptions \n} from './types';\n\nexport interface ExperimentalTool extends InstalledTool {\n  experimental: true;\n  source: 'branch' | 'pr';\n  sourceRef: string; // branch name or PR number\n}\n\nexport interface ExperimentalManifest {\n  version: string;\n  experimental: ExperimentalTool[];\n  lastUpdated: string;\n}\n\nexport class ExperimentalToolManager {\n  private manifestPath: string;\n  private registryUrl: string;\n  \n  constructor(private options: PackageManagerOptions = {}) {\n    const baseDir = options.toolsDir || path.join(process.env.HOME || '', '.clanker', 'tools');\n    this.manifestPath = path.join(baseDir, 'experimental-manifest.json');\n    this.registryUrl = 'https://api.github.com/repos/ziggle-dev/clanker-tools';\n  }\n  \n  /**\n   * Check if experimental mode is enabled\n   */\n  async isEnabled(): Promise<boolean> {\n    // Check environment variable\n    if (process.env.CLANKER_EXPERIMENTAL === 'true') {\n      return true;\n    }\n    \n    // Check config file\n    try {\n      const configPath = path.join(process.env.HOME || '', '.clanker', 'config.json');\n      const config = await fs.readFile(configPath, 'utf-8');\n      const parsed = JSON.parse(config);\n      return parsed.experimental?.enabled === true;\n    } catch {\n      return false;\n    }\n  }\n  \n  /**\n   * Enable experimental mode\n   */\n  async enable(): Promise<void> {\n    const configPath = path.join(process.env.HOME || '', '.clanker', 'config.json');\n    let config: any = {};\n    \n    try {\n      const existing = await fs.readFile(configPath, 'utf-8');\n      config = JSON.parse(existing);\n    } catch {\n      // Config doesn't exist yet\n    }\n    \n    config.experimental = {\n      enabled: true,\n      autoUpgrade: true,\n      sources: ['branches', 'pull-requests']\n    };\n    \n    await fs.mkdir(path.dirname(configPath), { recursive: true });\n    await fs.writeFile(configPath, JSON.stringify(config, null, 2));\n    \n    debug.log('[Experimental] Experimental mode enabled');\n  }\n  \n  /**\n   * List available experimental tools from branches\n   */\n  async listAvailable(): Promise<ExperimentalTool[]> {\n    const tools: ExperimentalTool[] = [];\n    \n    try {\n      // Fetch branches from GitHub API\n      const response = await fetch(`${this.registryUrl}/branches`, {\n        headers: {\n          'Accept': 'application/vnd.github.v3+json',\n          'User-Agent': 'clanker-cli'\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to fetch branches: ${response.statusText}`);\n      }\n      \n      const branches = await response.json();\n      \n      // Filter for tool branches (format: org/tool@version)\n      const toolBranches = branches.filter((branch: any) => \n        branch.name.match(/^[^/]+\\/[^/]+@[\\d.]+$/)\n      );\n      \n      for (const branch of toolBranches) {\n        const [orgTool, version] = branch.name.split('@');\n        const [org, name] = orgTool.split('/');\n        \n        tools.push({\n          org,\n          name,\n          version,\n          installedAt: '',\n          path: '',\n          experimental: true,\n          source: 'branch',\n          sourceRef: branch.name\n        });\n      }\n      \n      // Also fetch open PRs\n      const prResponse = await fetch(`${this.registryUrl}/pulls?state=open`, {\n        headers: {\n          'Accept': 'application/vnd.github.v3+json',\n          'User-Agent': 'clanker-cli'\n        }\n      });\n      \n      if (prResponse.ok) {\n        const prs = await prResponse.json();\n        \n        for (const pr of prs) {\n          // Check if PR has a tool submission\n          if (pr.head.ref.match(/^[^/]+\\/[^/]+@[\\d.]+$/)) {\n            const [orgTool, version] = pr.head.ref.split('@');\n            const [org, name] = orgTool.split('/');\n            \n            tools.push({\n              org,\n              name,\n              version,\n              installedAt: '',\n              path: '',\n              experimental: true,\n              source: 'pr',\n              sourceRef: pr.number.toString()\n            });\n          }\n        }\n      }\n      \n    } catch (error) {\n      debug.error('[Experimental] Failed to list available tools:', error);\n    }\n    \n    return tools;\n  }\n  \n  /**\n   * Install an experimental tool\n   */\n  async install(toolSpec: string): Promise<void> {\n    debug.log(`[Experimental] Installing experimental tool: ${toolSpec}`);\n    \n    // Parse tool spec (org/tool@version, org/tool@pr-123, org/tool@branch)\n    let org: string, name: string, ref: string;\n    let source: 'branch' | 'pr';\n    \n    if (toolSpec.includes('@pr-')) {\n      // PR reference: org/tool@pr-123\n      const [orgTool, prRef] = toolSpec.split('@pr-');\n      [org, name] = orgTool.split('/');\n      ref = prRef;\n      source = 'pr';\n    } else if (toolSpec.includes('@')) {\n      // Branch reference: org/tool@branch-name\n      const [orgTool, branchRef] = toolSpec.split('@');\n      [org, name] = orgTool.split('/');\n      ref = branchRef;\n      source = 'branch';\n    } else {\n      throw new Error('Experimental tools must specify a version, branch, or PR number');\n    }\n    \n    // Resolve to actual branch name\n    let branchName = ref;\n    if (source === 'pr') {\n      // Get branch name from PR\n      const response = await fetch(`${this.registryUrl}/pulls/${ref}`, {\n        headers: {\n          'Accept': 'application/vnd.github.v3+json',\n          'User-Agent': 'clanker-cli'\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`PR #${ref} not found`);\n      }\n      \n      const pr = await response.json();\n      branchName = pr.head.ref;\n    }\n    \n    // Download tool from branch\n    const toolUrl = `https://raw.githubusercontent.com/ziggle-dev/clanker-tools/${branchName}/tools/${org}/${name}`;\n    \n    // Get latest version from branch\n    const versionsResponse = await fetch(`${toolUrl}`, {\n      headers: { 'User-Agent': 'clanker-cli' }\n    });\n    \n    if (!versionsResponse.ok) {\n      throw new Error(`Tool ${org}/${name} not found in branch ${branchName}`);\n    }\n    \n    // For now, assume version is in the branch name\n    const version = branchName.split('@')[1] || 'experimental';\n    \n    // Download tool files\n    const toolDir = path.join(\n      this.options.toolsDir || path.join(process.env.HOME || '', '.clanker', 'tools'),\n      org,\n      name,\n      version\n    );\n    \n    await fs.mkdir(toolDir, { recursive: true });\n    \n    // Download index.js\n    const indexResponse = await fetch(`${toolUrl}/${version}/index.js`, {\n      headers: { 'User-Agent': 'clanker-cli' }\n    });\n    \n    if (!indexResponse.ok) {\n      throw new Error(`Failed to download tool files`);\n    }\n    \n    const indexContent = await indexResponse.text();\n    await fs.writeFile(path.join(toolDir, 'index.js'), indexContent);\n    \n    // Download manifest.json\n    const manifestResponse = await fetch(`${toolUrl}/${version}/manifest.json`, {\n      headers: { 'User-Agent': 'clanker-cli' }\n    });\n    \n    if (manifestResponse.ok) {\n      const manifestContent = await manifestResponse.text();\n      await fs.writeFile(path.join(toolDir, 'manifest.json'), manifestContent);\n    }\n    \n    // Update experimental manifest\n    await this.addToManifest({\n      org,\n      name,\n      version,\n      installedAt: new Date().toISOString(),\n      path: toolDir,\n      experimental: true,\n      source,\n      sourceRef: ref\n    });\n    \n    console.log(`✅ Installed experimental tool: ${org}/${name}@${version} from ${source} ${ref}`);\n  }\n  \n  /**\n   * List installed experimental tools\n   */\n  async listInstalled(): Promise<ExperimentalTool[]> {\n    try {\n      const manifest = await this.loadManifest();\n      return manifest.experimental;\n    } catch {\n      return [];\n    }\n  }\n  \n  /**\n   * Upgrade experimental tools to stable versions\n   */\n  async upgradeToStable(): Promise<void> {\n    const experimental = await this.listInstalled();\n    let upgraded = 0;\n    \n    for (const tool of experimental) {\n      try {\n        // Check if tool is now in main registry\n        const registryResponse = await fetch(\n          `https://raw.githubusercontent.com/ziggle-dev/clanker-tools/main/tools/${tool.org}/${tool.name}/metadata.json`,\n          { headers: { 'User-Agent': 'clanker-cli' } }\n        );\n        \n        if (registryResponse.ok) {\n          const metadata = await registryResponse.json();\n          \n          // Check if our version is now stable\n          if (metadata.versions && metadata.versions[tool.version]) {\n            console.log(`📦 Upgrading ${tool.org}/${tool.name}@${tool.version} to stable`);\n            \n            // Remove experimental flag\n            await this.removeFromManifest(tool);\n            \n            // Tool is already installed in the right place, just remove experimental tracking\n            upgraded++;\n          }\n        }\n      } catch (error) {\n        debug.error(`[Experimental] Failed to check ${tool.org}/${tool.name}:`, error);\n      }\n    }\n    \n    if (upgraded > 0) {\n      console.log(`✅ Upgraded ${upgraded} tools to stable versions`);\n    } else {\n      console.log('ℹ️  No experimental tools ready for upgrade');\n    }\n  }\n  \n  /**\n   * Load experimental manifest\n   */\n  private async loadManifest(): Promise<ExperimentalManifest> {\n    try {\n      const content = await fs.readFile(this.manifestPath, 'utf-8');\n      return JSON.parse(content);\n    } catch {\n      return {\n        version: '1.0.0',\n        experimental: [],\n        lastUpdated: new Date().toISOString()\n      };\n    }\n  }\n  \n  /**\n   * Save experimental manifest\n   */\n  private async saveManifest(manifest: ExperimentalManifest): Promise<void> {\n    await fs.mkdir(path.dirname(this.manifestPath), { recursive: true });\n    await fs.writeFile(this.manifestPath, JSON.stringify(manifest, null, 2));\n  }\n  \n  /**\n   * Add tool to experimental manifest\n   */\n  private async addToManifest(tool: ExperimentalTool): Promise<void> {\n    const manifest = await this.loadManifest();\n    \n    // Remove existing entry if present\n    manifest.experimental = manifest.experimental.filter(\n      t => !(t.org === tool.org && t.name === tool.name)\n    );\n    \n    // Add new entry\n    manifest.experimental.push(tool);\n    manifest.lastUpdated = new Date().toISOString();\n    \n    await this.saveManifest(manifest);\n  }\n  \n  /**\n   * Remove tool from experimental manifest\n   */\n  private async removeFromManifest(tool: ExperimentalTool): Promise<void> {\n    const manifest = await this.loadManifest();\n    \n    manifest.experimental = manifest.experimental.filter(\n      t => !(t.org === tool.org && t.name === tool.name && t.version === tool.version)\n    );\n    \n    manifest.lastUpdated = new Date().toISOString();\n    await this.saveManifest(manifest);\n  }\n}\n\nexport function createExperimentalToolManager(options?: PackageManagerOptions): ExperimentalToolManager {\n  return new ExperimentalToolManager(options);\n}","/**\n * Tool installer for downloading and installing Clanker tools\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { debug } from '../utils/debug-logger';\nimport { RegistryClient } from './registry';\nimport { VersionResolver } from './resolver';\nimport {\n  ToolIdentifier,\n  ToolManifest,\n  InstalledTool,\n  InstallOptions,\n  PackageManagerOptions\n} from './types';\nimport { ExperimentalToolManager } from './experimental';\n\nexport class ToolInstaller {\n  private toolsDir: string;\n  private registry: RegistryClient;\n  private resolver: VersionResolver;\n  private manifestPath: string;\n  private experimental: ExperimentalToolManager;\n\n  constructor(options: PackageManagerOptions = {}) {\n    this.toolsDir = options.toolsDir || path.join(process.env.HOME || '', '.clanker', 'tools');\n    this.manifestPath = path.join(this.toolsDir, 'manifest.json');\n    this.registry = new RegistryClient(options);\n    this.resolver = new VersionResolver();\n    this.experimental = new ExperimentalToolManager(options);\n  }\n\n  /**\n   * Install a tool\n   */\n  async install(toolSpec: string, options: InstallOptions = {}): Promise<void> {\n    // Check if this is an experimental tool installation\n    if (toolSpec.includes('@pr-') || toolSpec.includes('@') && !toolSpec.match(/@[\\d.]+$/)) {\n      const isExperimental = await this.experimental.isEnabled();\n      if (isExperimental) {\n        await this.experimental.install(toolSpec);\n        return;\n      } else {\n        console.log('ℹ️  This appears to be an experimental tool. Use --enable-experimental first.');\n        return;\n      }\n    }\n    \n    const tool = this.parseToolSpec(toolSpec);\n    \n    debug.log(`[Installer] Installing ${tool.org}/${tool.name}${tool.version ? '@' + tool.version : ''}`);\n    \n    try {\n      // Fetch tool metadata\n      const metadata = await this.registry.fetchToolMetadata(tool);\n      debug.log(`[Installer] Fetched metadata:`, JSON.stringify(metadata, null, 2));\n      \n      // Resolve version\n      const version = this.resolver.resolveVersion(metadata, tool.version || 'latest');\n      tool.version = version;\n      debug.log(`[Installer] Resolved version: ${version}`);\n      \n      // Check if already installed\n      const manifest = await this.loadManifest();\n      const existing = manifest.installedTools.find(t => \n        t.org === tool.org && t.name === tool.name\n      );\n      \n      if (existing && existing.version === version && !options.force) {\n        console.log(`✅ ${tool.org}/${tool.name}@${version} is already installed`);\n        return;\n      }\n      \n      // Check Clanker compatibility\n      debug.log(`[Installer] Checking version info for version ${version}`);\n      debug.log(`[Installer] Available versions:`, Object.keys(metadata.versions));\n      const versionInfo = metadata.versions[version];\n      const clankerVersion = await this.getClankerVersion();\n      if (!this.resolver.checkClankerCompatibility(versionInfo, clankerVersion)) {\n        throw new Error(`This tool requires Clanker ${versionInfo.minClankerVersion} or higher (current: ${clankerVersion})`);\n      }\n      \n      // Download the tool\n      console.log(`📥 Downloading ${tool.org}/${tool.name}@${version}...`);\n      const downloadBuffer = await this.registry.downloadTool(tool, version);\n      \n      // Extract tool content (handle tar.gz archives)\n      const toolContent = await this.extractToolContent(downloadBuffer, tool);\n      \n      // Verify checksum if provided (skip if it's the example hash)\n      if (versionInfo.sha256 && versionInfo.sha256 !== 'example-hash-will-be-computed') {\n        const hash = crypto.createHash('sha256').update(toolContent).digest('hex');\n        if (hash !== versionInfo.sha256) {\n          throw new Error('Checksum verification failed');\n        }\n      }\n      \n      // Install to filesystem\n      const installPath = await this.installToFilesystem(tool, version, toolContent);\n      \n      // Update manifest\n      await this.updateManifest(tool, version, installPath);\n      \n      console.log(`✅ Successfully installed ${tool.org}/${tool.name}@${version}`);\n      \n      // Install dependencies if needed\n      if (!options.skipDependencies && versionInfo.dependencies) {\n        for (const [depName, depVersion] of Object.entries(versionInfo.dependencies)) {\n          console.log(`📦 Installing dependency: ${depName}@${depVersion}`);\n          await this.install(`${depName}@${depVersion}`, { ...options, skipDependencies: true });\n        }\n      }\n    } catch (error) {\n      console.error(`❌ Failed to install ${toolSpec}: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Uninstall a tool\n   */\n  async uninstall(toolSpec: string): Promise<void> {\n    const tool = this.parseToolSpec(toolSpec);\n    \n    debug.log(`[Installer] Uninstalling ${tool.org}/${tool.name}`);\n    \n    try {\n      const manifest = await this.loadManifest();\n      const installedIndex = manifest.installedTools.findIndex(t => \n        t.org === tool.org && t.name === tool.name\n      );\n      \n      if (installedIndex === -1) {\n        throw new Error(`Tool ${tool.org}/${tool.name} is not installed`);\n      }\n      \n      const installed = manifest.installedTools[installedIndex];\n      \n      // Remove from filesystem\n      const toolDir = path.dirname(installed.path);\n      await fs.rm(toolDir, { recursive: true, force: true });\n      \n      // Update manifest\n      manifest.installedTools.splice(installedIndex, 1);\n      await this.saveManifest(manifest);\n      \n      console.log(`✅ Successfully uninstalled ${tool.org}/${tool.name}`);\n    } catch (error) {\n      console.error(`❌ Failed to uninstall ${toolSpec}: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n\n  /**\n   * List installed tools\n   */\n  async listInstalled(): Promise<InstalledTool[]> {\n    const manifest = await this.loadManifest();\n    return manifest.installedTools;\n  }\n\n  /**\n   * Update a tool to the latest version\n   */\n  async update(toolSpec: string): Promise<void> {\n    const tool = this.parseToolSpec(toolSpec);\n    tool.version = 'latest';\n    \n    await this.install(`${tool.org}/${tool.name}@latest`, { force: true });\n  }\n\n  /**\n   * Parse tool specification string\n   */\n  private parseToolSpec(spec: string): ToolIdentifier {\n    // Support formats: \"org/name\", \"org/name@version\"\n    const match = spec.match(/^([^/]+)\\/([^@]+)(?:@(.+))?$/);\n    \n    if (!match) {\n      throw new Error(`Invalid tool specification: ${spec}`);\n    }\n    \n    return {\n      org: match[1],\n      name: match[2],\n      version: match[3]\n    };\n  }\n\n  /**\n   * Install tool to filesystem\n   */\n  private async installToFilesystem(tool: ToolIdentifier, version: string, content: Buffer): Promise<string> {\n    const toolDir = path.join(this.toolsDir, tool.org, tool.name, version);\n    const toolFile = path.join(toolDir, 'index.js');\n    \n    // Create directory structure\n    await fs.mkdir(toolDir, { recursive: true });\n    \n    // Write tool file\n    await fs.writeFile(toolFile, content);\n    \n    // Update current symlink\n    const currentLink = path.join(this.toolsDir, tool.org, tool.name, 'current');\n    try {\n      await fs.unlink(currentLink);\n    } catch {\n      // Ignore if doesn't exist\n    }\n    await fs.symlink(version, currentLink);\n    \n    return toolFile;\n  }\n\n  /**\n   * Extract tool content from download buffer\n   */\n  private async extractToolContent(buffer: Buffer, tool: ToolIdentifier): Promise<Buffer> {\n    // Check if it's a tar.gz file\n    if (buffer[0] === 0x1f && buffer[1] === 0x8b) {\n      // It's gzipped\n      debug.log(`[Installer] Extracting tar.gz for ${tool.org}/${tool.name}`);\n      \n      try {\n        // Use Node.js built-in zlib for decompression\n        const zlib = await import('zlib');\n        const gunzipped = await new Promise<Buffer>((resolve, reject) => {\n          zlib.gunzip(buffer, (err, result) => {\n            if (err) reject(err);\n            else resolve(result);\n          });\n        });\n        \n        // Simple tar extraction - look for the tool's index.js\n        const targetPath = `${tool.org}/${tool.name}/index.js`;\n        const files = this.parseTar(gunzipped);\n        \n        const toolFile = files.find(f => f.name.endsWith(targetPath));\n        if (toolFile) {\n          return toolFile.content;\n        }\n        \n        // Fallback: look for any index.js\n        const indexFile = files.find(f => f.name.endsWith('index.js'));\n        if (indexFile) {\n          return indexFile.content;\n        }\n        \n        throw new Error('No index.js found in archive');\n        \n      } catch (error) {\n        debug.error('[Installer] Failed to extract tar.gz:', error);\n        throw new Error(`Failed to extract tool: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n    \n    // Not a tar.gz, assume it's the raw JavaScript file\n    return buffer;\n  }\n  \n  /**\n   * Simple tar parser (basic implementation)\n   */\n  private parseTar(buffer: Buffer): Array<{name: string, content: Buffer}> {\n    const files: Array<{name: string, content: Buffer}> = [];\n    let offset = 0;\n    \n    while (offset < buffer.length) {\n      // Read header (512 bytes)\n      const header = buffer.slice(offset, offset + 512);\n      offset += 512;\n      \n      // Check if we've reached the end (empty header)\n      if (header.every(b => b === 0)) break;\n      \n      // Extract filename (first 100 bytes)\n      const nameEnd = header.indexOf(0);\n      const name = header.slice(0, nameEnd > 0 ? nameEnd : 100).toString('utf8').trim();\n      \n      // Extract file size (octal, bytes 124-135)\n      const sizeStr = header.slice(124, 135).toString('utf8').trim();\n      const size = parseInt(sizeStr, 8) || 0;\n      \n      if (name && size > 0) {\n        // Read file content\n        const content = buffer.slice(offset, offset + size);\n        files.push({ name, content });\n      }\n      \n      // Move to next 512-byte boundary\n      offset += Math.ceil(size / 512) * 512;\n    }\n    \n    return files;\n  }\n  \n  /**\n   * Load manifest file\n   */\n  private async loadManifest(): Promise<ToolManifest> {\n    try {\n      const content = await fs.readFile(this.manifestPath, 'utf-8');\n      return JSON.parse(content);\n    } catch {\n      // Return empty manifest if doesn't exist\n      return {\n        version: '1.0.0',\n        installedTools: [],\n        lastUpdated: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\n   * Save manifest file\n   */\n  private async saveManifest(manifest: ToolManifest): Promise<void> {\n    manifest.lastUpdated = new Date().toISOString();\n    \n    await fs.mkdir(path.dirname(this.manifestPath), { recursive: true });\n    await fs.writeFile(this.manifestPath, JSON.stringify(manifest, null, 2));\n  }\n\n  /**\n   * Update manifest with new tool\n   */\n  private async updateManifest(tool: ToolIdentifier, version: string, installPath: string): Promise<void> {\n    const manifest = await this.loadManifest();\n    \n    // Remove existing entry if any\n    const existingIndex = manifest.installedTools.findIndex(t => \n      t.org === tool.org && t.name === tool.name\n    );\n    \n    if (existingIndex >= 0) {\n      manifest.installedTools.splice(existingIndex, 1);\n    }\n    \n    // Add new entry\n    manifest.installedTools.push({\n      org: tool.org,\n      name: tool.name,\n      version,\n      installedAt: new Date().toISOString(),\n      path: installPath\n    });\n    \n    await this.saveManifest(manifest);\n  }\n\n  /**\n   * Get current Clanker version\n   */\n  private async getClankerVersion(): Promise<string> {\n    try {\n      // In bundled environment, package.json is at the root\n      const possiblePaths = [\n        path.join(__dirname, 'package.json'),\n        path.join(__dirname, '..', 'package.json'),\n        path.join(__dirname, '..', '..', 'package.json'),\n        path.join(process.cwd(), 'package.json')\n      ];\n      \n      for (const packagePath of possiblePaths) {\n        try {\n          const content = await fs.readFile(packagePath, 'utf-8');\n          const pkg = JSON.parse(content);\n          if (pkg.name === '@ziggler/clanker') {\n            return pkg.version;\n          }\n        } catch {\n          // Try next path\n        }\n      }\n      \n      // Fallback to hardcoded version\n      return '0.1.1';\n    } catch {\n      return '0.1.1';\n    }\n  }\n}","/**\n * Tool publisher for creating pull requests to add tools to the registry\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport open from 'open';\nimport { debug } from '../utils/debug-logger';\n\nconst execAsync = promisify(exec);\n\ninterface ToolMetadata {\n    id: string;\n    name: string;\n    version: string;\n    description: string;\n    author?: string;\n    org?: string;\n}\n\nexport async function publishTool(): Promise<void> {\n    console.log('🚀 Publishing tool to Clanker registry...\\n');\n    \n    try {\n        // 1. Check if we're in a tool project directory\n        const packageJsonPath = path.join(process.cwd(), 'package.json');\n        let packageJson: any;\n        \n        try {\n            const content = await fs.readFile(packageJsonPath, 'utf8');\n            packageJson = JSON.parse(content);\n        } catch (error) {\n            console.error('❌ Error: No package.json found in current directory');\n            console.error('   Make sure you run this command from your tool project directory');\n            process.exit(1);\n        }\n        \n        // 2. Extract tool metadata\n        const toolName = packageJson.name.replace(/^.*-clanker-tool-/, '');\n        const org = packageJson.name.match(/^(.*)-clanker-tool-/)?.[1] || 'community';\n        const version = packageJson.version || '1.0.0';\n        const description = packageJson.description || '';\n        const author = packageJson.author || 'Unknown';\n        \n        console.log('📋 Tool Information:');\n        console.log(`   Name: ${toolName}`);\n        console.log(`   Organization: ${org}`);\n        console.log(`   Version: ${version}`);\n        console.log(`   Author: ${author}\\n`);\n        \n        // 3. Validate project structure\n        console.log('🔍 Validating project structure...\\n');\n        \n        try {\n            const { stdout } = await execAsync('npm run validate-tool 2>&1 || true');\n            console.log(stdout);\n            \n            // Check exit code separately\n            try {\n                await execAsync('npm run validate-tool');\n            } catch (validationError) {\n                console.error('\\n❌ Validation failed. Fix issues before publishing.');\n                process.exit(1);\n            }\n        } catch (error) {\n            // If validate-tool script doesn't exist, do basic checks\n            console.log('⚠️  No validate-tool script found, doing basic checks...\\n');\n            \n            // Check for src directory\n            const srcPath = path.join(process.cwd(), 'src');\n            try {\n                await fs.access(srcPath);\n                const srcFiles = await fs.readdir(srcPath);\n                if (srcFiles.length === 0) {\n                    throw new Error('src directory is empty');\n                }\n                console.log('✅ Source files found in src/');\n            } catch (error) {\n                console.error('❌ Error: src directory not found or empty');\n                console.error('   Your tool source code must be in the src/ directory');\n                process.exit(1);\n            }\n        }\n        \n        \n        // 4. Check for required files\n        const readmePath = path.join(process.cwd(), 'README.md');\n        \n        let readmeContent = '';\n        try {\n            readmeContent = await fs.readFile(readmePath, 'utf8');\n        } catch {\n            console.warn('⚠️  Warning: No README.md found, creating a basic one');\n            readmeContent = `# ${toolName}\\n\\n${description}\\n\\nA Clanker tool by ${author}.`;\n        }\n        \n        // 5. Create tool manifest\n        const manifest = {\n            id: toolName.replace(/-/g, '_'),\n            name: toolName,\n            version,\n            description,\n            author,\n            repository: `https://github.com/${org}/${packageJson.name}`,\n            homepage: packageJson.homepage || '',\n            keywords: packageJson.keywords || ['clanker', 'tool'],\n            created: new Date().toISOString(),\n            updated: new Date().toISOString()\n        };\n        \n        // 6. Prepare PR body\n        const prBody = `## 🔧 New Tool: ${toolName}\n\n### Description\n${description}\n\n### Author\n${author}\n\n### Version\n${version}\n\n### Tool Details\n- **ID**: \\`${manifest.id}\\`\n- **Organization**: \\`${org}\\`\n- **Keywords**: ${manifest.keywords.join(', ')}\n\n### Source Code Structure\n- ✅ Source code in \\`src/\\` directory\n- ✅ Build configuration in \\`package.json\\`\n- ✅ No compiled files included (bin/ directory excluded)\n\n### Build Verification\n- ✅ \\`npm install\\` runs successfully\n- ✅ \\`npm run build\\` completes without errors\n- ✅ Tool can be bundled for distribution\n\n### Checklist\n- [ ] Tool follows naming conventions\n- [ ] Source code is in src/ directory\n- [ ] No compiled/bundled files included\n- [ ] package.json has build script\n- [ ] README.md is complete\n- [ ] Tool has been tested locally\n- [ ] Code is readable and maintainable\n\n### Files to Add\n- \\`tools/${org}/${toolName}/src/\\` (all source files)\n- \\`tools/${org}/${toolName}/package.json\\`\n- \\`tools/${org}/${toolName}/README.md\\`\n- \\`tools/${org}/${toolName}/tsconfig.json\\` (if using TypeScript)\n\n### Note\nThe \\`bin/\\` directory will be automatically generated during the CI/CD build process after merge.\n`;\n\n        // 7. Encode PR data for URL\n        const prTitle = `Add ${toolName} tool by ${author}`;\n        const encodedTitle = encodeURIComponent(prTitle);\n        const encodedBody = encodeURIComponent(prBody);\n        \n        // 8. Create GitHub PR URL\n        const baseRepo = 'ziggle-dev/clanker-tools';\n        const prUrl = `https://github.com/${baseRepo}/compare/main...main?quick_pull=1&title=${encodedTitle}&body=${encodedBody}`;\n        \n        console.log('📝 Publishing Instructions:\\n');\n        console.log('1. Fork the clanker-tools repository:');\n        console.log(`   https://github.com/${baseRepo}\\n`);\n        \n        console.log('2. Create the following directory structure in your fork:');\n        console.log(`   tools/${org}/${toolName}/`);\n        console.log(`   tools/${org}/${toolName}/${version}/\\n`);\n        \n        console.log('3. Copy your project structure:');\n        console.log(`   - tools/${org}/${toolName}/src/ (all source files)`);\n        console.log(`   - tools/${org}/${toolName}/package.json`);\n        console.log(`   - tools/${org}/${toolName}/README.md`);\n        console.log(`   - tools/${org}/${toolName}/tsconfig.json (if using TypeScript)`);\n        console.log(`\\n   ⚠️  Do NOT include:`);\n        console.log(`   - node_modules/`);\n        console.log(`   - bin/ or dist/ directories`);\n        console.log(`   - Any compiled/bundled files\\n`);\n        \n        console.log('4. Commit and push to your fork\\n');\n        \n        console.log('5. Create a pull request\\n');\n        \n        // Save manifest locally for reference\n        const manifestPath = path.join(process.cwd(), 'clanker-manifest.json');\n        await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));\n        console.log(`✅ Manifest saved to: ${manifestPath}\\n`);\n        \n        // Open browser to GitHub\n        console.log('🌐 Opening GitHub in your browser...');\n        console.log('   (If it doesn\\'t open, visit the URL manually)\\n');\n        \n        await open(`https://github.com/${baseRepo}`);\n        \n        console.log('📋 PR Template (copy this for your PR):');\n        console.log('─'.repeat(60));\n        console.log(prBody);\n        console.log('─'.repeat(60));\n        \n    } catch (error) {\n        console.error('❌ Error publishing tool:', error);\n        process.exit(1);\n    }\n}","/**\n * Core tools management\n * Handles auto-installation of core tools on first run\n */\n\nimport { ToolInstaller } from './installer';\nimport { debug } from '../utils/debug-logger';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\n\n// List of core tools that should be auto-installed\nconst CORE_TOOLS = [\n  'clanker/bash',\n  'clanker/pwd',\n  'clanker/list',\n  'clanker/read-file',\n  'clanker/write-to-file',\n  'clanker/remove',\n  'clanker/search',\n  'clanker/input',\n  'clanker/summarize',\n  'clanker/view-file',\n  'clanker/multi-edit',\n  'clanker/create-todo-list',\n  'clanker/list-todos',\n  'clanker/update-todo-list'\n];\n\nexport class CoreToolsManager {\n  private installer: ToolInstaller;\n  private coreToolsFile: string;\n\n  constructor() {\n    this.installer = new ToolInstaller();\n    this.coreToolsFile = path.join(os.homedir(), '.clanker', 'core-tools-installed.json');\n  }\n\n  /**\n   * Check if core tools are installed and install them if needed\n   */\n  async ensureCoreToolsInstalled(): Promise<void> {\n    try {\n      debug.log('[CoreTools] Checking core tools installation...');\n      \n      // Check if we've already installed core tools\n      const isInstalled = await this.checkInstallationStatus();\n      if (isInstalled) {\n        debug.log('[CoreTools] Core tools already installed');\n        return;\n      }\n\n      console.log('🔧 Installing core tools for first-time setup...');\n      \n      // Install each core tool\n      const results = await Promise.allSettled(\n        CORE_TOOLS.map(tool => this.installTool(tool))\n      );\n\n      // Count successes and failures\n      const succeeded = results.filter(r => r.status === 'fulfilled').length;\n      const failed = results.filter(r => r.status === 'rejected').length;\n\n      if (failed > 0) {\n        console.log(`⚠️  Installed ${succeeded}/${CORE_TOOLS.length} core tools (${failed} failed)`);\n        console.log('   You can manually install missing tools with: clanker --install <tool>');\n      } else {\n        console.log(`✅ Successfully installed all ${succeeded} core tools`);\n      }\n\n      // Mark as installed\n      await this.markAsInstalled();\n      \n    } catch (error) {\n      debug.error('[CoreTools] Failed to ensure core tools:', error);\n      console.error('⚠️  Failed to install core tools. You can install them manually.');\n    }\n  }\n\n  /**\n   * Install a single tool\n   */\n  private async installTool(toolSpec: string): Promise<void> {\n    try {\n      debug.log(`[CoreTools] Installing ${toolSpec}...`);\n      await this.installer.install(toolSpec);\n    } catch (error) {\n      debug.error(`[CoreTools] Failed to install ${toolSpec}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if core tools have been installed\n   */\n  private async checkInstallationStatus(): Promise<boolean> {\n    try {\n      const data = await fs.readFile(this.coreToolsFile, 'utf-8');\n      const status = JSON.parse(data);\n      return status.installed === true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Mark core tools as installed\n   */\n  private async markAsInstalled(): Promise<void> {\n    const dir = path.dirname(this.coreToolsFile);\n    await fs.mkdir(dir, { recursive: true });\n    \n    const status = {\n      installed: true,\n      version: '1.0.0',\n      installedAt: new Date().toISOString(),\n      tools: CORE_TOOLS\n    };\n    \n    await fs.writeFile(this.coreToolsFile, JSON.stringify(status, null, 2));\n  }\n\n  /**\n   * Force reinstall core tools\n   */\n  async reinstallCoreTools(): Promise<void> {\n    try {\n      // Remove installation marker\n      await fs.unlink(this.coreToolsFile).catch(() => {});\n      \n      // Reinstall\n      await this.ensureCoreToolsInstalled();\n    } catch (error) {\n      debug.error('[CoreTools] Failed to reinstall:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get list of core tools\n   */\n  getCoreTools(): string[] {\n    return [...CORE_TOOLS];\n  }\n}","import React, { useState, useEffect } from 'react';\nimport { Box, Text } from 'ink';\nimport { useInput } from 'ink';\nimport { GrokAgent } from '../../clanker/agent';\n\ninterface ClankerLogoProps {\n    agent?: GrokAgent;\n    onComplete?: () => void;\n}\n\ninterface DynamicContentProps {\n    agent?: GrokAgent;\n    onReady?: () => void;\n}\n\nconst DynamicContent: React.FC<DynamicContentProps> = ({ agent, onReady }) => {\n    const [displayText, setDisplayText] = useState('');\n    const [isStreaming, setIsStreaming] = useState(true);\n    const [hasFetched, setHasFetched] = useState(false);\n    \n    useEffect(() => {\n        if (hasFetched) return; // Prevent multiple fetches\n        \n        const fetchContent = async () => {\n            setHasFetched(true);\n            const categories = ['joke', 'tech_fact', 'dad_joke', 'inspirational', 'dark_humor'];\n            const weights = [30, 25, 25, 19, 1]; // Total: 100\n            const random = Math.random() * 100;\n            let accumulated = 0;\n            let selectedCategory = 'inspirational';\n            \n            for (let i = 0; i < weights.length; i++) {\n                accumulated += weights[i];\n                if (random < accumulated) {\n                    selectedCategory = categories[i];\n                    break;\n                }\n            }\n            \n            if (!agent) {\n                // Get fallback content and stream it\n                const fallback = getFallbackText(selectedCategory);\n                await streamText(fallback, setDisplayText);\n                setIsStreaming(false);\n                // Wait 5 seconds after streaming completes\n                await new Promise(resolve => setTimeout(resolve, 5000));\n                if (onReady) onReady();\n                return;\n            }\n            \n            try {\n                const prompts: Record<string, string> = {\n                    joke: \"Tell me a very short programmer joke (max 10 words). Be witty and clever.\",\n                    tech_fact: \"Share a fascinating tech or robot fact (max 15 words). Make it mind-blowing.\",\n                    dad_joke: \"Tell me a tech-related dad joke (max 10 words). Make it groan-worthy.\",\n                    inspirational: \"Give an inspirational quote for makers and tinkerers (max 10 words). Be motivating.\",\n                    dark_humor: \"Share a darkly humorous tech observation (max 12 words). Be subtly existential.\"\n                };\n                \n                const stream = await agent.chat([\n                    {role: 'user', content: prompts[selectedCategory]}\n                ], \"\", true);\n                \n                let fullText = '';\n                if (typeof stream === 'string') {\n                    fullText = stream;\n                    await streamText(fullText, setDisplayText);\n                } else {\n                    // Stream character by character as it comes in\n                    for await (const chunk of stream) {\n                        if (chunk.type === 'content' && chunk.content) {\n                            for (const char of chunk.content) {\n                                fullText += char;\n                                setDisplayText(fullText);\n                                await new Promise(resolve => setTimeout(resolve, 30));\n                            }\n                        }\n                    }\n                }\n                setIsStreaming(false);\n                // Wait 5 seconds after streaming completes\n                await new Promise(resolve => setTimeout(resolve, 5000));\n                if (onReady) onReady();\n            } catch (error) {\n                const fallback = getFallbackText(selectedCategory);\n                await streamText(fallback, setDisplayText);\n                setIsStreaming(false);\n                // Wait 5 seconds after streaming completes\n                await new Promise(resolve => setTimeout(resolve, 5000));\n                if (onReady) onReady();\n            }\n        };\n        \n        fetchContent();\n    }, []); // Run only once on mount\n    \n    return <Text>{parseMarkdownToJSX(displayText)}</Text>;\n};\n\n// Stream text character by character\nasync function streamText(text: string, setText: (text: string) => void) {\n    let current = '';\n    for (const char of text) {\n        current += char;\n        setText(current);\n        await new Promise(resolve => setTimeout(resolve, 30));\n    }\n}\n\n// Get fallback text (plain string)\nfunction getFallbackText(category: string): string {\n    const fallbacks: Record<string, string[]> = {\n        joke: [\n            \"**404**: Joke not found. *Please try again.*\",\n            \"There are only **10** types of people: those who understand {green:binary}\",\n            \"!false - It's {red:funny} because it's true\"\n        ],\n        tech_fact: [\n            \"The first computer bug was an {yellow:actual moth}\",\n            \"**CAPTCHA** stands for *Completely Automated Public Turing test*\",\n            \"The {blue:@ symbol} was used to save space in email\"\n        ],\n        dad_joke: [\n            \"Why do programmers prefer {gray:dark mode}? Light attracts **bugs**!\",\n            \"I'd tell you a UDP joke, but you might *not get it*\",\n            \"My code doesn't have bugs, it has {red:surprise features}\"\n        ],\n        inspirational: [\n            \"For the *tinkerers* and **makers** in all of us\",\n            \"Build things that make you {yellow:smile}\",\n            \"Every expert was once a {green:beginner}\",\n            \"**Create**, *iterate*, and never stop {blue:learning}\"\n        ],\n        dark_humor: [\n            \"We're all just {gray:biological computers} running on anxiety\",\n            \"AI will replace us all... *eventually*\",\n            \"Your code will outlive you. {red:Plan accordingly.}\"\n        ]\n    };\n    \n    const options = fallbacks[category] || fallbacks.inspirational;\n    return options[Math.floor(Math.random() * options.length)];\n}\n\n// Parse markdown-like syntax to JSX\nfunction parseMarkdownToJSX(text: string): React.ReactElement {\n    const parts: React.ReactElement[] = [];\n    let currentIndex = 0;\n    let key = 0;\n    \n    // Regex patterns for different markdown elements\n    const patterns = [\n        { regex: /\\*\\*(.*?)\\*\\*/g, style: 'bold' },\n        { regex: /\\*(.*?)\\*/g, style: 'italic' },\n        { regex: /\\{(\\w+):(.*?)\\}/g, style: 'color' }\n    ];\n    \n    // Combine all patterns and process text\n    const allMatches: Array<{index: number, length: number, content: string, style: string, color?: string}> = [];\n    \n    patterns.forEach(({ regex, style }) => {\n        let match;\n        while ((match = regex.exec(text)) !== null) {\n            if (style === 'color') {\n                allMatches.push({\n                    index: match.index,\n                    length: match[0].length,\n                    content: match[2],\n                    style: style,\n                    color: match[1]\n                });\n            } else {\n                allMatches.push({\n                    index: match.index,\n                    length: match[0].length,\n                    content: match[1],\n                    style: style\n                });\n            }\n        }\n    });\n    \n    // Sort matches by index\n    allMatches.sort((a, b) => a.index - b.index);\n    \n    // Process text with matches\n    allMatches.forEach((match) => {\n        // Add text before match\n        if (match.index > currentIndex) {\n            parts.push(<Text key={key++}>{text.substring(currentIndex, match.index)}</Text>);\n        }\n        \n        // Add styled text\n        switch (match.style) {\n            case 'bold':\n                parts.push(<Text key={key++} bold>{match.content}</Text>);\n                break;\n            case 'italic':\n                parts.push(<Text key={key++} italic>{match.content}</Text>);\n                break;\n            case 'color':\n                parts.push(<Text key={key++} color={match.color}>{match.content}</Text>);\n                break;\n        }\n        \n        currentIndex = match.index + match.length;\n    });\n    \n    // Add remaining text\n    if (currentIndex < text.length) {\n        parts.push(<Text key={key++}>{text.substring(currentIndex)}</Text>);\n    }\n    \n    return <>{parts}</>;\n}\n\n// Get fallback content when no agent is available\nfunction getFallbackContent(category: string): React.ReactElement {\n    const fallbacks: Record<string, Array<() => React.ReactElement>> = {\n        joke: [\n            () => <Text><Text bold>404</Text>: Joke not found. <Text italic>Please try again.</Text></Text>,\n            () => <Text>There are only <Text bold>10</Text> types of people: those who understand <Text color=\"green\">binary</Text></Text>,\n            () => <Text>!false - It's <Text color=\"red\">funny</Text> because it's true</Text>\n        ],\n        tech_fact: [\n            () => <Text>The first computer bug was an <Text color=\"yellow\">actual moth</Text></Text>,\n            () => <Text><Text bold>CAPTCHA</Text> stands for <Text italic>Completely Automated Public Turing test</Text></Text>,\n            () => <Text>The <Text color=\"blue\">@ symbol</Text> was used to save space in email</Text>\n        ],\n        dad_joke: [\n            () => <Text>Why do programmers prefer <Text color=\"gray\">dark mode</Text>? Light attracts <Text bold>bugs</Text>!</Text>,\n            () => <Text>I'd tell you a UDP joke, but you might <Text italic>not get it</Text></Text>,\n            () => <Text>My code doesn't have bugs, it has <Text color=\"red\">surprise features</Text></Text>\n        ],\n        inspirational: [\n            () => <Text>For the <Text italic>tinkerers</Text> and <Text bold>makers</Text> in all of us</Text>,\n            () => <Text>Build things that make you <Text color=\"yellow\">smile</Text></Text>,\n            () => <Text>Every expert was once a <Text color=\"green\">beginner</Text></Text>,\n            () => <Text><Text bold>Create</Text>, <Text italic>iterate</Text>, and never stop <Text color=\"blue\">learning</Text></Text>\n        ],\n        dark_humor: [\n            () => <Text>We're all just <Text color=\"gray\">biological computers</Text> running on anxiety</Text>,\n            () => <Text>AI will replace us all... <Text italic>eventually</Text></Text>,\n            () => <Text>Your code will outlive you. <Text color=\"red\">Plan accordingly.</Text></Text>\n        ]\n    };\n    \n    const options = fallbacks[category] || fallbacks.inspirational;\n    const selectedOption = options[Math.floor(Math.random() * options.length)];\n    return selectedOption();\n}\n\nexport const ClankerLogo: React.FC<ClankerLogoProps> = ({ agent, onComplete }) => {\n    const [shouldSkip, setShouldSkip] = useState(false);\n    const [contentReady, setContentReady] = useState(false);\n    const [minimumTimeElapsed, setMinimumTimeElapsed] = useState(false);\n    const [colorIndex, setColorIndex] = useState(0);\n    const [isVisible, setIsVisible] = useState(true);\n    \n    // Color cycle for the border\n    const colors = ['red', 'yellow', 'green', 'cyan', 'blue', 'magenta'];\n    \n    // Handle escape key\n    useInput((input, key) => {\n        if (key.escape) {\n            setShouldSkip(true);\n        }\n    });\n    \n    // Color cycling effect - always running\n    useEffect(() => {\n        const colorInterval = setInterval(() => {\n            setColorIndex((prev) => (prev + 1) % colors.length);\n        }, 200); // Change color every 200ms\n        \n        return () => clearInterval(colorInterval);\n    }, []);\n    \n    // Set minimum display time\n    useEffect(() => {\n        const timer = setTimeout(() => {\n            setMinimumTimeElapsed(true);\n        }, 5000); // Minimum 5 seconds display time\n        \n        return () => clearTimeout(timer);\n    }, []);\n    \n    useEffect(() => {\n        if (shouldSkip && onComplete) {\n            setIsVisible(false);\n            onComplete();\n            return;\n        }\n        \n        // Only transition when content is ready AND minimum time has elapsed\n        if (contentReady && minimumTimeElapsed && onComplete) {\n            setIsVisible(false);\n            onComplete();\n        }\n    }, [onComplete, shouldSkip, contentReady, minimumTimeElapsed]);\n    \n    // Only render when visible\n    if (!isVisible) {\n        return null;\n    }\n    \n    return (\n        <Box flexDirection=\"column\" alignItems=\"center\" justifyContent=\"center\" height=\"100%\">\n            {/* Outer rounded box with padding */}\n            <Box \n                flexDirection=\"column\" \n                borderStyle=\"round\" \n                borderColor={colors[colorIndex]}\n                paddingX={3}\n                paddingY={2}\n            >\n                {/* Inner content */}\n                <Box flexDirection=\"column\" alignItems=\"center\">\n                    <Box marginBottom={1}>\n                        <Text color={colors[colorIndex]}>\n                            {' ██████╗██╗      █████╗ ███╗   ██╗██╗  ██╗███████╗██████╗  \\n'}\n                            {'██╔════╝██║     ██╔══██╗████╗  ██║██║ ██╔╝██╔════╝██╔══██╗ \\n'}\n                            {'██║     ██║     ███████║██╔██╗ ██║█████╔╝ █████╗  ██████╔╝ \\n'}\n                            {'██║     ██║     ██╔══██║██║╚██╗██║██╔═██╗ ██╔══╝  ██╔══██╗ \\n'}\n                            {'╚██████╗███████╗██║  ██║██║ ╚████║██║  ██╗███████╗██║  ██║ \\n'}\n                            {' ╚═════╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝ '}\n                        </Text>\n                    </Box>\n                    <Box justifyContent=\"center\" paddingX={2} paddingY={1}>\n                        <DynamicContent agent={agent} onReady={() => setContentReady(true)} />\n                    </Box>\n                </Box>\n            </Box>\n            <Box marginTop={1}>\n                <Text dimColor>Press ESC to skip...</Text>\n            </Box>\n        </Box>\n    );\n};","import React from 'react';\nimport { Box, Text } from 'ink';\nimport Gradient from 'ink-gradient';\nimport BigText from 'ink-big-text';\n\ninterface ChatLayoutProps {\n  children: React.ReactNode;\n}\n\n// Memoized static layout component\nexport const ChatLayout: React.FC<ChatLayoutProps> = React.memo(({ children }) => {\n  return (\n    <Box flexDirection=\"column\" width=\"100%\" height=\"100%\">\n      <Box flexGrow={1} overflow=\"hidden\">\n        {children}\n      </Box>\n    </Box>\n  );\n});","import React from \"react\";\nimport { Box, Text } from \"ink\";\nimport { useSnapshot } from \"valtio\";\nimport { store } from \"../../store\";\n\n/**\n * CommandSuggestions component - shows command autocomplete suggestions\n * Uses Zustand store directly - no props needed\n */\nexport function CommandSuggestions() {\n  // Get state directly from store\n  const snap = useSnapshot(store);\n  const inputValue = snap.inputValue;\n  const showCommandSuggestions = snap.showCommandSuggestions;\n  const selectedCommandIndex = snap.selectedCommandIndex;\n  const commandSuggestions = snap.commandSuggestions;\n  \n  if (!showCommandSuggestions) return null;\n\n  // Parse suggestions (they come as \"command - description\" strings)\n  const parsedSuggestions = commandSuggestions.map(s => {\n    const [command, ...descParts] = s.split(\" - \");\n    return { command, description: descParts.join(\" - \") };\n  });\n\n  const filteredSuggestions = parsedSuggestions\n    .filter((suggestion) =>\n      inputValue.startsWith(\"/\")\n        ? suggestion.command.startsWith(\"/\")\n        : suggestion.command.toLowerCase().startsWith(inputValue.toLowerCase())\n    )\n    .slice(0, 8);\n\n  return (\n    <Box marginTop={1} flexDirection=\"column\">\n      {filteredSuggestions.map((suggestion, index) => (\n        <Box key={index} paddingLeft={1}>\n          <Text\n            color={index === selectedCommandIndex ? \"black\" : \"white\"}\n            backgroundColor={index === selectedCommandIndex ? \"cyan\" : undefined}\n          >\n            {suggestion.command}\n          </Text>\n          <Box marginLeft={1}>\n            <Text color=\"gray\">{suggestion.description}</Text>\n          </Box>\n        </Box>\n      ))}\n      <Box marginTop={1}>\n        <Text color=\"gray\" dimColor>\n          ↑↓ navigate • Enter/Tab select • Esc cancel\n        </Text>\n      </Box>\n    </Box>\n  );\n}","import React from 'react';\nimport { Box, Text } from 'ink';\nimport { marked } from 'marked';\nimport TerminalRenderer from 'marked-terminal';\n\n// Configure marked to use marked-terminal for terminal-friendly output\nmarked.setOptions({\n  renderer: new TerminalRenderer({\n    showSectionPrefix: false,\n    width: 80,\n    reflowText: true,\n    tab: 2,\n    firstHeading: (text: string) => text,\n    codespan: (text: string) => `\\x1b[36m${text}\\x1b[0m`, // Cyan for inline code\n    code: (code: string) => `\\x1b[90m${code}\\x1b[0m`, // Gray for code blocks\n  }) as any\n});\n\nexport const MarkdownRenderer = React.memo(function MarkdownRenderer({ content, streamingCursor = false }: { content: string; streamingCursor?: boolean }) {\n  // Process markdown content with marked-terminal\n  const rendered = React.useMemo(() => {\n    try {\n      return marked.parse(content) as string;\n    } catch (error) {\n      console.error('[MarkdownRenderer] Error parsing markdown:', error);\n      return content; // Fallback to raw content\n    }\n  }, [content]);\n  \n  // Split by newlines and handle empty lines properly\n  const lines = React.useMemo(() => {\n    const allLines = rendered.split('\\n');\n    // Limit lines to prevent performance issues with very large outputs\n    const MAX_LINES = 500;\n    if (allLines.length > MAX_LINES) {\n      // console.warn(`[MarkdownRenderer] Truncating output from ${allLines.length} to ${MAX_LINES} lines`);\n      return [...allLines.slice(0, MAX_LINES - 1), `... (${allLines.length - MAX_LINES} more lines)`];\n    }\n    return allLines;\n  }, [rendered]);\n  \n  // // Add debug info for large content\n  // React.useEffect(() => {\n  //   if (content.length > 1000) {\n  //     console.log(`[MarkdownRenderer] Rendering large content: ${content.length} chars, ${lines.length} lines`);\n  //   }\n  // }, [content.length, lines.length]);\n  \n  return (\n    <Box flexDirection=\"column\" width=\"100%\">\n      {lines.map((line, index) => {\n        const isLastLine = index === lines.length - 1;\n        // Handle empty lines by rendering a space\n        if (line === '') {\n          return <Text key={index}> </Text>;\n        }\n        return (\n          <Text key={index} wrap=\"wrap\">\n            {line}\n            {isLastLine && streamingCursor && <Text color=\"cyan\">█</Text>}\n          </Text>\n        );\n      })}\n    </Box>\n  );\n}, (prevProps, nextProps) => {\n  // Only re-render if content or cursor state changes\n  return prevProps.content === nextProps.content && \n         prevProps.streamingCursor === nextProps.streamingCursor;\n});","import React, { useMemo } from 'react';\nimport { Box, Text } from 'ink';\n\ninterface VirtualScrollProps {\n  children: React.ReactElement[];\n  maxHeight: number;\n  estimatedItemHeight?: number;\n  getItemHeight?: (index: number) => number;\n}\n\nexport const VirtualScroll: React.FC<VirtualScrollProps> = ({ \n  children, \n  maxHeight,\n  estimatedItemHeight = 3,\n  getItemHeight\n}) => {\n  // Calculate which items to show\n  const visibleItems = useMemo(() => {\n    if (!children || children.length === 0) return [];\n    \n    // Start from the end (most recent messages)\n    const items: React.ReactElement[] = [];\n    let currentHeight = 0;\n    \n    // Work backwards from the most recent message\n    for (let i = children.length - 1; i >= 0; i--) {\n      // Use custom height function if provided, otherwise use estimate\n      const itemHeight = getItemHeight ? getItemHeight(i) : estimatedItemHeight;\n      \n      if (currentHeight + itemHeight > maxHeight - 2) { // Leave some buffer\n        // We've filled the viewport, stop adding items\n        break;\n      }\n      \n      items.unshift(children[i]); // Add to beginning to maintain order\n      currentHeight += itemHeight;\n    }\n    \n    return items;\n  }, [children, maxHeight, estimatedItemHeight, getItemHeight]);\n  \n  // Show indicator if there are hidden messages\n  const hiddenCount = children.length - visibleItems.length;\n  \n  return (\n    <Box flexDirection=\"column\" height={maxHeight} overflow=\"hidden\" flexShrink={0}>\n      {hiddenCount > 0 && (\n        <Box marginBottom={1} flexShrink={0}>\n          <Text color=\"gray\" dimColor>↑ {hiddenCount} earlier message{hiddenCount > 1 ? 's' : ''}</Text>\n        </Box>\n      )}\n      <Box flexDirection=\"column\" flexGrow={1} overflow=\"hidden\" justifyContent=\"flex-end\">\n        {visibleItems}\n      </Box>\n    </Box>\n  );\n};","import React, { useCallback } from \"react\";\nimport {Box, Text, useStdout} from \"ink\";\nimport {useSnapshot} from \"valtio\";\nimport {store} from \"../../store\";\nimport {messageRegistry as MessageRegistryType, MessageRegistryMessage} from \"../../registry/messages\";\nimport {executionRegistry as ExecutionRegistryType, ToolExecution} from \"../../registry/execution\";\nimport {ToolRegistry} from \"../../registry/types\";\nimport {MarkdownRenderer} from \"../utils/markdown-renderer\";\nimport {VirtualScroll} from \"./VirtualScroll\";\nimport Gradient from 'ink-gradient';\nimport BigText from 'ink-big-text';\n\n/**\n * Format tool execution display - shows tool name and primary argument\n */\nfunction formatToolExecution(toolName: string, args: Record<string, unknown>): React.ReactElement {\n    // Get the primary argument based on tool name\n    let primaryArg: string | undefined;\n\n    switch (toolName) {\n        case 'bash':\n            primaryArg = args.command as string;\n            break;\n        case 'read_file':\n        case 'write_file':\n        case 'list':\n            primaryArg = args.path as string || args.file_path as string;\n            break;\n        case 'search':\n            primaryArg = args.query as string;\n            break;\n        case 'pwd':\n            // No args for pwd\n            break;\n        default:\n            // Try to find the first string argument\n            const firstArg = Object.values(args).find(v => typeof v === 'string');\n            if (firstArg) {\n                primaryArg = firstArg as string;\n            }\n    }\n\n    if (primaryArg) {\n        return (\n            <>\n                <Text underline color=\"white\">{toolName}</Text>\n                <Text color=\"gray\"> ~{'>'} </Text>\n                <Text color=\"cyan\">{primaryArg}</Text>\n            </>\n        );\n    }\n\n    return <Text underline color=\"white\">{toolName}</Text>;\n}\n\ninterface ChatHistoryProps {\n    messageRegistry: typeof MessageRegistryType;\n    executionRegistry: typeof ExecutionRegistryType;\n    toolRegistry: ToolRegistry;\n    isConfirmationActive?: boolean;\n}\n\n// Helper to determine if we should add extra spacing before this message\nconst shouldAddExtraSpacing = (entry: MessageRegistryMessage, previousEntry?: MessageRegistryMessage): boolean => {\n    if (!previousEntry) return false;\n    \n    // Add space between tool execution and assistant response\n    if (previousEntry.role === 'tool' && entry.role === 'assistant') {\n        return true;\n    }\n    \n    // Add space between assistant message with tools and next message\n    if (previousEntry.role === 'assistant' && previousEntry.toolCalls && entry.role === 'tool') {\n        return true;\n    }\n    \n    return false;\n};\n\nconst ChatEntry = ({\n                       entry,\n                       index,\n                       execution,\n                       toolRegistry,\n                       previousEntry\n                   }: {\n    entry: MessageRegistryMessage;\n    index: number;\n    execution?: ToolExecution;\n    toolRegistry: ToolRegistry;\n    previousEntry?: MessageRegistryMessage;\n}) => {\n    const extraSpacing = shouldAddExtraSpacing(entry, previousEntry);\n\n    switch (entry.role) {\n        case \"user\":\n            return (\n                <Box key={index} flexDirection=\"column\" marginTop={extraSpacing ? 2 : 1} flexShrink={0}>\n                    <Box>\n                        <Text color=\"gray\">\n                            {\">\"} {entry.content}\n                        </Text>\n                    </Box>\n                </Box>\n            );\n\n        case \"assistant\":\n            // Only hide tool-only messages that have no content and aren't streaming\n            if (entry.toolCalls && entry.toolCalls.length > 0 &&\n                !entry.content?.trim() &&\n                !entry.metadata?.isStreaming) {\n                return null;\n            }\n\n            return (\n                <Box key={index} flexDirection=\"column\" marginTop={extraSpacing ? 3 : 2} marginBottom={1} flexShrink={0}>\n                    <Box flexDirection=\"row\" alignItems=\"flex-start\">\n                        <Text color=\"white\">⏺ </Text>\n                        <Box flexDirection=\"column\" flexGrow={1}>\n                            {entry.content && entry.content.trim() ? (\n                                <MarkdownRenderer\n                                    content={entry.content.trim()}\n                                    streamingCursor={entry.metadata?.isStreaming === true}\n                                />\n                            ) : (\n                                entry.metadata?.isStreaming && <Text color=\"cyan\">█</Text>\n                            )}\n                        </Box>\n                    </Box>\n                </Box>\n            );\n\n        case \"tool\":\n            // Always render based on execution data, not the message content\n            if (!execution) {\n                // If no execution found, show a placeholder\n                return (\n                    <Box key={index} flexDirection=\"column\" marginTop={extraSpacing ? 2 : 1} flexShrink={0}>\n                        <Box>\n                            <Text color=\"magenta\">⏺</Text>\n                            <Text> Tool execution pending...</Text>\n                        </Box>\n                    </Box>\n                );\n            }\n\n            const isExecuting = execution.status === \"executing\";\n            const result = execution.result;\n\n            // Try to get the tool definition and its custom renderer\n            const tool = toolRegistry.get(execution.toolName);\n\n            if (tool?.definition?.renderResult) {\n                // Use the custom renderer\n                const customRender = tool.definition.renderResult({\n                    toolName: execution.toolName,\n                    arguments: execution.arguments,\n                    result: result,\n                    isExecuting: isExecuting\n                });\n\n                if (customRender) {\n                    return (\n                        <Box key={index} flexDirection=\"column\" marginTop={extraSpacing ? 2 : 1} marginBottom={1} flexShrink={0}>\n                            <Box>\n                                <Text color=\"magenta\">⏺</Text>\n                                <Text> </Text>\n                                {formatToolExecution(execution.toolName, execution.arguments)}\n                            </Box>\n                            <Box flexDirection=\"column\">\n                                {customRender}\n                            </Box>\n                        </Box>\n                    );\n                }\n            }\n\n            // Default rendering for tools without custom renderer\n            return (\n                <Box key={index} flexDirection=\"column\" marginTop={extraSpacing ? 2 : 1} marginBottom={1} flexShrink={0}>\n                    <Box>\n                        <Text color=\"magenta\">⏺</Text>\n                        <Text> </Text>\n                        {formatToolExecution(execution.toolName, execution.arguments)}\n                    </Box>\n                    <Box marginLeft={2} flexDirection=\"column\">\n                        {isExecuting ? (\n                            <Text color=\"cyan\">⎿ Executing...</Text>\n                        ) : result ? (\n                            result.success ? (\n                                result.output ? (\n                                    <Text color=\"gray\">⎿ {result.output}</Text>\n                                ) : (\n                                    <Text color=\"green\">⎿ Completed</Text>\n                                )\n                            ) : (\n                                <Text color=\"red\">⎿ Error: {result.error}</Text>\n                            )\n                        ) : null}\n                    </Box>\n                </Box>\n            );\n\n        default:\n            return null;\n    }\n};\n\nexport function ChatHistory({\n                                messageRegistry,\n                                executionRegistry,\n                                toolRegistry,\n                                isConfirmationActive = false,\n                            }: ChatHistoryProps) {\n    // Don't memoize ChatHistory - let Valtio handle reactivity\n    const snap = useSnapshot(store);\n    // Cast to correct type - Valtio's snapshot makes arrays readonly\n    const messages = snap.messages as MessageRegistryMessage[];\n    \n    // Get terminal dimensions\n    const {stdout} = useStdout();\n    const terminalHeight = stdout?.rows || 30;\n    // Account for: input (4) + status bar (2) + loading (2) + margins (4) = 12\n    // No header now since logo is part of scrollable content\n    const maxHeight = Math.max(5, terminalHeight - 12);\n\n    // Filter out executing tool messages when in confirmation mode\n    const filteredMessages = isConfirmationActive\n        ? messages.filter(msg => {\n            if (msg.role !== \"tool\" || !msg.toolCallId) return true;\n            const execution = executionRegistry.get(msg.toolCallId);\n            return execution?.status !== \"executing\";\n        })\n        : messages;\n    \n    // Map messages to chat entries\n    const chatEntries = filteredMessages.map((entry, index) => {\n        // Use executionRegistry.get to properly map tool call ID to execution\n        const execution = entry.toolCallId\n            ? executionRegistry.get(entry.toolCallId)\n            : undefined;\n        \n        const previousEntry = index > 0 ? filteredMessages[index - 1] : undefined;\n\n        return (\n            <ChatEntry\n                key={`${entry.id}-${execution?.status || 'pending'}-${execution?.result ? 'done' : 'running'}`}\n                entry={entry}\n                index={index}\n                execution={execution}\n                toolRegistry={toolRegistry}\n                previousEntry={previousEntry}\n            />\n        );\n    });\n\n    // Create a height estimation function based on message content\n    const getItemHeight = useCallback((index: number): number => {\n        const entry = filteredMessages[index];\n        if (!entry) return 4;\n        \n        let baseHeight = 3; // Base height with margins\n        \n        switch (entry.role) {\n            case 'user':\n                // User messages are typically single line\n                baseHeight = 3;\n                break;\n                \n            case 'assistant':\n                // Assistant messages can be much longer\n                if (entry.content) {\n                    const lines = entry.content.split('\\n').length;\n                    baseHeight = Math.min(lines + 4, 25); // Cap at 25 lines\n                } else {\n                    baseHeight = 3;\n                }\n                break;\n                \n            case 'tool':\n                // Tool messages vary based on execution\n                const execution = entry.toolCallId ? executionRegistry.get(entry.toolCallId) : undefined;\n                if (execution?.result?.output) {\n                    // Tool with output - estimate based on output length\n                    const outputLines = String(execution.result.output).split('\\n').length;\n                    baseHeight = Math.min(outputLines + 5, 20); // Header + output + margins\n                } else {\n                    baseHeight = 4; // Just header and status\n                }\n                break;\n        }\n        \n        return baseHeight;\n    }, [filteredMessages, executionRegistry]);\n\n    // Show logo only when there are no messages\n    if (messages.length === 0) {\n        return (\n            <Box flexDirection=\"column\" height={maxHeight} paddingX={2}>\n                <Box paddingX={2} flexShrink={0} height={8}>\n                    <Box justifyContent=\"center\" marginBottom={1}>\n                        <Gradient name=\"passion\">\n                            <BigText text=\"CLANK\" font=\"3d\" />\n                        </Gradient>\n                    </Box>\n                    <Box flexDirection=\"column\" marginBottom={0}>\n                        <Text dimColor>\n                            Type your request in natural language. Type '/exit' or press Ctrl+C to quit.\n                        </Text>\n                    </Box>\n                </Box>\n            </Box>\n        );\n    }\n\n    // Use virtual scrolling if enabled, otherwise render all messages\n    if (snap.virtualScrollingEnabled) {\n        return (\n            <VirtualScroll \n                maxHeight={maxHeight}\n                estimatedItemHeight={4}\n                getItemHeight={getItemHeight}\n            >\n                {chatEntries}\n            </VirtualScroll>\n        );\n    } else {\n        // Render all messages without virtual scrolling\n        return (\n            <Box flexDirection=\"column\" overflow=\"hidden\" paddingX={0}>\n                {chatEntries}\n            </Box>\n        );\n    }\n}","import React from \"react\";\nimport {Box, Text} from \"ink\";\nimport {useSnapshot} from \"valtio\";\nimport {store} from \"../../../store\";\n\n/**\n * ChatInput component - displays the current input with a cursor\n * Uses Valtio store directly - no props needed\n */\nexport const ChatInput: React.FC = React.memo(() => {\n    // Get state values - Valtio handles reactivity automatically\n    const snap = useSnapshot(store);\n    const inputValue = snap.inputValue;\n    const isProcessing = snap.isProcessing;\n    const isStreaming = snap.isStreaming;\n    return (\n        <Box \n            borderStyle=\"single\" \n            borderColor=\"gray\" \n            borderTop={true}\n            borderLeft={false}\n            borderRight={false}\n            borderBottom={false}\n            paddingX={2} \n            paddingY={0}\n            marginTop={1}\n            marginBottom={1}\n            width=\"100%\"\n        >\n            <Text color=\"gray\">❯ </Text>\n            <Text>\n                {inputValue}\n                {!isProcessing && !isStreaming && <Text color=\"white\">█</Text>}\n            </Text>\n        </Box>\n    );\n})\n","import React from 'react';\nimport {Box, Text} from 'ink';\nimport {useSnapshot} from 'valtio';\nimport {store} from '../../../store';\n\n/**\n * StatusBar component - shows auto-edit status and exit info at the bottom\n */\nexport const StatusBar: React.FC = React.memo(() => {\n    const snap = useSnapshot(store);\n    const autoEditEnabled = snap.autoEditEnabled;\n    const dbpEnabled = snap.dangerousBypassPermission;\n\n    return (\n        <Box width=\"100%\" justifyContent=\"space-between\">\n            {/* Left side - exit instruction */}\n            <Text color=\"gray\">Ctrl+C to exit</Text>\n            \n            {/* Right side - indicators */}\n            <Box>\n                {/* Only show auto-edit if it's enabled AND DBP is not on */}\n                {autoEditEnabled && !dbpEnabled && (\n                    <Text color=\"cyan\">\n                        ▶ auto-edit: on\n                    </Text>\n                )}\n                {/* Show DBP as a badge */}\n                {dbpEnabled && (\n                    <Text backgroundColor=\"red\" color=\"white\" bold> BYPASS </Text>\n                )}\n            </Box>\n        </Box>\n    );\n});","import React, {useState, useEffect} from \"react\";\nimport {Box, Text, useStdout} from \"ink\";\nimport {useSnapshot} from \"valtio\";\nimport {store} from \"../../store\";\n\n\n/**\n * ChatProgress component - shows animated dots pattern responsive to token counts\n */\nexport const ChatProgress: React.FC<{ elapsedSeconds: number }> = React.memo(({elapsedSeconds}) => {\n    // Get state using Valtio's useSnapshot\n    const snap = useSnapshot(store);\n\n    // Check if any tools are executing from executions slice\n    const hasExecutingTools = Array.from(snap.executions.values()).some(\n        (execution) => execution.status === \"executing\"\n    );\n\n    // Determine if indicator should be active\n    const isActive = snap.isProcessing || snap.isStreaming || hasExecutingTools;\n\n    const [progressFrame, setProgressFrame] = useState(0);\n    const [idleFrame, setIdleFrame] = useState(0);\n    const {stdout} = useStdout();\n\n    // Terminal width for progress bar calculation\n    const terminalWidth = stdout.columns || 80;\n    // Calculate available width\n    const loadingTextWidth = 25; // spinner + loading text\n    const marginWidth = 4; // margin between loading and progress\n    const tokenDisplayWidth = (snap.inputTokenCount > 0 || snap.outputTokenCount > 0) ? 25 : 0; // space for token count\n    const bracketsWidth = 2; // [ and ]\n\n    const availableWidth = terminalWidth - loadingTextWidth - marginWidth - tokenDisplayWidth - bracketsWidth - 5;\n    const maxBarWidth = Math.max(40, availableWidth);\n\n    // Animate progress based on token count\n    useEffect(() => {\n        if (!isActive) {\n            setProgressFrame(0);\n            return;\n        }\n\n        // Adjust animation speed based on total token count\n        const totalTokens = snap.inputTokenCount + snap.outputTokenCount;\n        const baseSpeed = 50;\n        const tokenFactor = Math.max(1, Math.log10(totalTokens + 1));\n        const animationSpeed = baseSpeed / tokenFactor;\n\n        const progressInterval = setInterval(() => {\n            setProgressFrame((prev) => (prev + 1) % 720);\n        }, animationSpeed);\n\n        return () => clearInterval(progressInterval);\n    }, [isActive, snap.inputTokenCount, snap.outputTokenCount]);\n\n    // Idle animation for processing state\n    useEffect(() => {\n        if (!isActive) {\n            setIdleFrame(0);\n            return;\n        }\n\n        const idleInterval = setInterval(() => {\n            setIdleFrame((prev) => (prev + 1) % 360);\n        }, 30);\n\n        return () => clearInterval(idleInterval);\n    }, [isActive]);\n\n    if (!isActive) return null;\n\n    // Create animated dots pattern with single left-to-right flow\n    const createDotsPattern = () => {\n        const dots = [];\n        const dotCount = Math.min(maxBarWidth, 80);\n\n        // Create different patterns based on token flow\n        const inputTokens = snap.inputTokenCount;\n        const outputTokens = snap.outputTokenCount;\n        const totalTokens = inputTokens + outputTokens;\n\n        // Base idle animation\n        const idleWave = Math.sin(idleFrame * 0.02) * 0.5 + 0.5;\n\n        for (let i = 0; i < dotCount; i++) {\n            const position = i / dotCount;\n\n            // Create single wave effect flowing left to right\n            let intensity = 0;\n            let color = 'gray';\n\n            if (totalTokens > 0) {\n                // Single wave moving left to right\n                const wavePosition = (progressFrame * 0.02) % 1.0; // Wave position from 0 to 1\n                const distanceFromWave = Math.abs(position - wavePosition);\n                \n                // Create a wave with width\n                const waveWidth = 0.3;\n                if (distanceFromWave < waveWidth) {\n                    intensity = 1.0 - (distanceFromWave / waveWidth);\n                    // Color based on token type dominance\n                    if (outputTokens > inputTokens) {\n                        color = 'cyan';\n                    } else {\n                        color = 'green';\n                    }\n                }\n            } else {\n                // Idle animation when no tokens\n                intensity = idleWave * (1 - Math.abs(position - 0.5) * 2) * 0.6;\n                color = 'gray';\n            }\n\n            // Different dot characters based on intensity\n            let dotChar = '·';\n            if (intensity > 0.8) {\n                dotChar = '●';\n            } else if (intensity > 0.6) {\n                dotChar = '•';\n            } else if (intensity > 0.4) {\n                dotChar = '◦';\n            } else if (intensity > 0.2) {\n                dotChar = '∙';\n            }\n\n            dots.push({\n                char: dotChar,\n                color: color,\n                dim: intensity < 0.3\n            });\n        }\n\n        return dots;\n    };\n\n    const dots = createDotsPattern();\n\n    // Format elapsed time as MM:SS\n    const formatElapsedTime = (seconds: number): string => {\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return `${mins}:${secs.toString().padStart(2, '0')}`;\n    };\n\n    return (\n        <Box width=\"100%\">\n            <Text color=\"gray\">[</Text>\n            {dots.map((dot, i) => (\n                <Text key={i} color={dot.color} dimColor={dot.dim}>\n                    {dot.char}\n                </Text>\n            ))}\n            <Text color=\"gray\">]</Text>\n            {(snap.inputTokenCount > 0 || snap.outputTokenCount > 0) && (\n                <>\n                    <Text color=\"gray\"> • </Text>\n                    {snap.inputTokenCount > 0 && (\n                        <>\n                            <Text color=\"green\" dimColor>↑{snap.inputTokenCount}</Text>\n                            {snap.outputTokenCount > 0 && <Text color=\"gray\"> </Text>}\n                        </>\n                    )}\n                    {snap.outputTokenCount > 0 && (\n                        <Text color=\"cyan\" dimColor>↓{snap.outputTokenCount}</Text>\n                    )}\n                </>\n            )}\n            {elapsedSeconds > 0 && (\n                <>\n                    <Text color=\"gray\"> • </Text>\n                    <Text color=\"gray\" dimColor>\n                        {formatElapsedTime(elapsedSeconds)}\n                    </Text>\n                </>\n            )}\n        </Box>\n    );\n});","import React, { useState, useEffect, useMemo } from 'react';\nimport { Box, Text } from 'ink';\nimport { useSnapshot } from 'valtio';\nimport { store } from '../../../store';\nimport { ChatProgress } from '../chat-indicator';\n\nconst loadingTexts = [\n  \"Thinking.......\",\n  \"Computing......\",\n  \"Analyzing......\",\n  \"Processing.....\",\n  \"Calculating....\",\n  \"Interfacing....\",\n  \"Optimizing.....\",\n  \"Synthesizing...\",\n  \"Decrypting.....\",\n  \"Calibrating....\",\n  \"Bootstrapping..\",\n  \"Synchronizing..\",\n  \"Compiling......\",\n  \"Downloading....\",\n];\n\nconst spinnerFrames = [\"⣷\", \"⣯\", \"⣟\", \"⡿\", \"⢿\", \"⣻\", \"⣽\", \"⣾\"];\n\n/**\n * LoadingAndStatus component - shows loading indicator and progress bar\n * Positioned above the chat input\n */\nexport const LoadingAndStatus: React.FC = React.memo(() => {\n  const snap = useSnapshot(store);\n  \n  // Memoize execution check to prevent re-computation\n  const hasExecutingTools = useMemo(() => \n    Array.from(snap.executions.values()).some(\n      (execution) => execution.status === \"executing\"\n    ), [snap.executions]\n  );\n  \n  // Determine if loading indicator should be active\n  const isActive = snap.isProcessing || snap.isStreaming || hasExecutingTools;\n  \n  const [spinnerFrame, setSpinnerFrame] = useState(0);\n  const [loadingTextIndex, setLoadingTextIndex] = useState(0);\n  const [elapsedSeconds, setElapsedSeconds] = useState(0);\n  const [startTime, setStartTime] = useState<number | null>(null);\n\n  // Change loading text periodically\n  useEffect(() => {\n    if (!isActive) {\n      setLoadingTextIndex(Math.floor(Math.random() * loadingTexts.length));\n      return;\n    }\n\n    const textInterval = setInterval(() => {\n      setLoadingTextIndex((prev) => (prev + 1) % loadingTexts.length);\n    }, 3000);\n\n    return () => clearInterval(textInterval);\n  }, [isActive]);\n\n  // Animate spinner\n  useEffect(() => {\n    if (!isActive) {\n      setSpinnerFrame(0);\n      return;\n    }\n\n    const spinnerInterval = setInterval(() => {\n      setSpinnerFrame((prev) => (prev + 1) % spinnerFrames.length);\n    }, 100);\n\n    return () => clearInterval(spinnerInterval);\n  }, [isActive]);\n\n  // Track elapsed time\n  useEffect(() => {\n    if (!isActive) {\n      // Reset when inactive\n      setElapsedSeconds(0);\n      setStartTime(null);\n      return;\n    }\n\n    // Set start time when becoming active\n    if (!startTime) {\n      setStartTime(Date.now());\n    }\n\n    // Update elapsed time every second\n    const timerInterval = setInterval(() => {\n      if (startTime) {\n        setElapsedSeconds(Math.floor((Date.now() - startTime) / 1000));\n      }\n    }, 1000);\n\n    return () => clearInterval(timerInterval);\n  }, [isActive, startTime]);\n\n  const currentLoadingText = loadingTexts[loadingTextIndex];\n  \n  return (\n    <Box width=\"100%\" marginTop={1}>\n      {isActive && (\n        <Box width=\"100%\" flexDirection=\"row\" justifyContent=\"space-between\">\n          <Box flexDirection=\"row\" flexGrow={1}>\n            <Box flexShrink={0}>\n              <Text color=\"cyan\">{spinnerFrames[spinnerFrame]} </Text>\n              <Text color=\"gray\">{currentLoadingText}</Text>\n            </Box>\n            <Box marginLeft={4} flexGrow={1}>\n              <ChatProgress elapsedSeconds={elapsedSeconds} />\n            </Box>\n          </Box>\n        </Box>\n      )}\n    </Box>\n  );\n});","import React from \"react\";\nimport {Box, Text} from \"ink\";\nimport {useSnapshot} from \"valtio\";\nimport {store} from \"../../store\";\n\n/**\n * ModelSelection component - shows model selection UI\n * Uses Zustand store directly - no props needed\n */\nexport const ModelSelection: React.FC = () => {\n    // Get state directly from store\n    const snap = useSnapshot(store);\n    const showModelSelection = snap.showModelSelection;\n    const selectedModelIndex = snap.selectedModelIndex;\n    const availableModels = snap.availableModels;\n    const currentModel = snap.model || availableModels[0];\n\n    if (!showModelSelection) return null;\n\n    return (\n        <Box marginTop={1} flexDirection=\"column\">\n            <Box marginBottom={1}>\n                <Text color=\"cyan\">Select Grok Model (current: {currentModel}):</Text>\n            </Box>\n            {availableModels.map((model, index) => (\n                <Box key={index} paddingLeft={1}>\n                    <Text\n                        color={index === selectedModelIndex ? \"black\" : \"white\"}\n                        backgroundColor={index === selectedModelIndex ? \"cyan\" : undefined}\n                    >\n                        {model}\n                    </Text>\n                </Box>\n            ))}\n            <Box marginTop={1}>\n                <Text color=\"gray\" dimColor>\n                    ↑↓ navigate • Enter/Tab select • Esc cancel\n                </Text>\n            </Box>\n        </Box>\n    );\n};","import {useCallback, MutableRefObject, useRef} from 'react';\nimport {actions, store} from '../../store';\nimport {useSnapshot} from 'valtio';\nimport {GrokAgent} from '../../clanker/agent';\nimport {messageRegistry as MessageRegistryType, MessageRegistryMessage} from '../../registry/messages';\nimport {executionRegistry as ExecutionRegistryType} from '../../registry/execution';\nimport {debug} from '../../utils/debug-logger';\nimport {TokenCounter} from '../../utils/token-counter';\n\ninterface UseMessageInputProps {\n    agent: GrokAgent;\n    messageRegistry: typeof MessageRegistryType;\n    executionRegistry: typeof ExecutionRegistryType;\n    processingStartTime: MutableRefObject<number>;\n}\n\nexport const useMessageInput = ({\n                                    agent,\n                                    messageRegistry,\n                                    executionRegistry,\n                                    processingStartTime,\n                                }: UseMessageInputProps) => {\n    // Use actions.setProcessing directly\n    // Use actions.setStreaming directly\n    // Use actions.updateTokenCount directly\n    // Use actions.setInputValue directly\n    \n    // Get store state for auto-edit\n    const snap = useSnapshot(store);\n    \n    // Ref for content buffer\n    const contentBufferRef = useRef<{ [messageId: string]: string }>({});\n\n    const sendMessage = useCallback(\n        async (content: string) => {\n            if (!content.trim() || !agent) return;\n\n            const userMessage = {\n                role: \"user\" as const,\n                content: content.trim(),\n            };\n            messageRegistry.addMessage(userMessage);\n\n            // Count input tokens (just the user's message for now)\n            const tokenCounter = new TokenCounter(snap.model || 'grok-3-mini');\n            tokenCounter.countTokens(userMessage.content);\n            tokenCounter.dispose();\n\n            actions.setInputValue(\"\");\n            actions.setProcessing(true);\n            processingStartTime.current = Date.now();\n            actions.updateTokenCount(0);\n            actions.updateOutputTokenCount(0); // Reset output tokens for new message\n\n            // Declare these outside try block for access in finally\n            let currentAssistantMessage: MessageRegistryMessage | null = null;\n\n            try {\n                const messages = messageRegistry.toGrokMessages();\n\n                // Build system prompt with autonomy instructions\n                let systemPrompt = '';\n                \n                // Add autonomy instruction if auto-edit is enabled\n                if (snap.autoEditEnabled) {\n                    systemPrompt += '\\n\\nIMPORTANT: Auto-edit mode is enabled. Work autonomously without asking for confirmation when making file edits. Proceed directly with implementing solutions and making necessary changes.';\n                }\n                \n                // Add todo-related autonomy instruction\n                // Since we can't easily check for pending todos from here, we'll add a general instruction\n                systemPrompt += '\\n\\nWhen you have pending tasks in your todo list, work through them autonomously and systematically. Focus on completing tasks without repeatedly asking for confirmation or clarification unless absolutely necessary.';\n                \n                // Add summarize tool usage instruction\n                systemPrompt += '\\n\\nIMPORTANT: Use the summarize tool proactively in these situations:\\n' +\n                    '- When analyzing long files or documentation, summarize key points before proceeding\\n' +\n                    '- After completing multiple related tasks, summarize what was accomplished\\n' +\n                    '- When encountering verbose output or logs, summarize the essential information\\n' +\n                    '- Before presenting findings from research or file exploration, summarize the key insights\\n' +\n                    '- When dealing with complex codebases, summarize the structure and relationships\\n' +\n                    'The summarize tool helps maintain clarity and ensures important information is highlighted efficiently.';\n\n                // Count total input tokens including all context\n                const contextTokenCounter = new TokenCounter(snap.model || 'grok-3-mini');\n                // Count message tokens\n                const messageTokens = contextTokenCounter.countMessageTokens(messages as any);\n                // Count system prompt tokens if present\n                const systemPromptTokens = systemPrompt ? contextTokenCounter.countTokens(systemPrompt) : 0;\n                // Total input tokens\n                const totalInputTokens = messageTokens + systemPromptTokens;\n                actions.updateInputTokenCount(totalInputTokens);\n                contextTokenCounter.dispose();\n                debug.log(`[useMessageInput] Total input tokens: ${totalInputTokens} (messages: ${messageTokens}, system: ${systemPromptTokens})`);\n\n                actions.setStreaming(true);\n                actions.setProcessing(false);\n                debug.log('[useMessageInput] Starting to stream response...');\n\n                const response = await agent.chat(messages, systemPrompt || undefined, true);\n\n                let hasToolCalls = false;\n\n                if (typeof response === 'string') {\n                    messageRegistry.addMessage({\n                        role: \"assistant\",\n                        content: response,\n                    });\n                } else {\n                    for await (const chunk of response) {\n                        switch (chunk.type) {\n                            case 'content':\n                                if (chunk.content) {\n                                    if (!currentAssistantMessage || hasToolCalls) {\n                                        debug.log('[useMessageInput] Creating new assistant message');\n                                        // Create message with first chunk of content immediately\n                                        currentAssistantMessage = messageRegistry.addMessage({\n                                            role: \"assistant\",\n                                            content: chunk.content, // Start with first chunk\n                                            metadata: {isStreaming: true},\n                                        });\n                                        hasToolCalls = false; // Reset for new message\n                                        \n                                        // Initialize buffer with this content\n                                        contentBufferRef.current[currentAssistantMessage.id] = chunk.content;\n                                        debug.log(`[useMessageInput] Created message with initial content: ${chunk.content.substring(0, 50)}...`);\n                                        continue; // Skip the buffering logic below since we already added content\n                                    }\n\n                                    // Buffer content and throttle updates\n                                    const messageId = currentAssistantMessage.id;\n                                    \n                                    // Initialize buffer if needed\n                                    if (!contentBufferRef.current[messageId]) {\n                                        contentBufferRef.current[messageId] = messageRegistry.getMessages().find(m => m.id === messageId)?.content || '';\n                                        \n                                        // First chunk - update immediately for instant feedback\n                                        contentBufferRef.current[messageId] += chunk.content;\n                                        messageRegistry.updateMessage(messageId, {\n                                            content: contentBufferRef.current[messageId]\n                                        });\n                                        debug.log(`[useMessageInput] First chunk displayed immediately for message ${messageId}`);\n                                    } else {\n                                        // Subsequent chunks - update immediately\n                                        contentBufferRef.current[messageId] += chunk.content;\n                                        messageRegistry.updateMessage(messageId, {\n                                            content: contentBufferRef.current[messageId]\n                                        });\n                                    }\n                                }\n                                break;\n\n                            case 'tool_calls':\n                                if (chunk.toolCalls) {\n                                    hasToolCalls = true;\n\n                                    if (currentAssistantMessage) {\n                                        messageRegistry.updateMessage(currentAssistantMessage.id, {\n                                            toolCalls: chunk.toolCalls,\n                                            metadata: {...currentAssistantMessage.metadata, isStreaming: false},\n                                        });\n                                    }\n\n                                    for (const toolCall of chunk.toolCalls) {\n                                        messageRegistry.addMessage({\n                                            role: \"tool\",\n                                            content: `Calling ${toolCall.function.name}...`,\n                                            toolCallId: toolCall.id,\n                                        });\n\n                                        // Track execution start\n                                        let args: Record<string, unknown> = {};\n                                        try {\n                                            args = JSON.parse(toolCall.function.arguments);\n                                        } catch (error) {\n                                            // If parsing fails, use empty args for tracking\n                                            debug.error(`Failed to parse tool arguments for tracking: ${error}`);\n                                        }\n                                        executionRegistry.start(\n                                            toolCall.id,\n                                            toolCall.function.name,\n                                            args\n                                        );\n                                    }\n                                }\n                                break;\n\n                            case 'tool_result':\n                                if (chunk.toolCall && chunk.toolResult) {\n                                    // Track execution completion\n                                    executionRegistry.complete(\n                                        chunk.toolCall.id,\n                                        chunk.toolResult\n                                    );\n\n                                    const toolMessage = messageRegistry.getMessages().find(\n                                        m => m.toolCallId === chunk.toolCall?.id\n                                    );\n\n                                    if (toolMessage) {\n                                        messageRegistry.updateMessage(toolMessage.id, {\n                                            content: chunk.toolResult.success\n                                                ? `✓ ${chunk.toolCall.function.name} completed`\n                                                : `✗ ${chunk.toolCall.function.name} failed: ${chunk.toolResult.error}`,\n                                        });\n                                    }\n                                    \n                                    // Reset currentAssistantMessage so the next content creates a new message\n                                    currentAssistantMessage = null;\n                                }\n                                break;\n\n                            case 'token_count':\n                                if (chunk.tokenCount !== undefined) {\n                                    actions.updateTokenCount(chunk.tokenCount);\n                                    if (currentAssistantMessage) {\n                                        // Get fresh message data to ensure we have latest metadata\n                                        const currentMsg = messageRegistry.getMessages().find(m => m.id === currentAssistantMessage.id);\n                                        if (currentMsg) {\n                                            messageRegistry.updateMessage(currentAssistantMessage.id, {\n                                                metadata: {\n                                                    ...currentMsg.metadata,\n                                                    tokenCount: chunk.tokenCount\n                                                },\n                                            });\n                                        }\n                                    }\n                                }\n                                break;\n\n                            case 'done':\n                                if (currentAssistantMessage) {\n                                    const messageId = currentAssistantMessage.id;\n                                    \n                                    // No need to flush since we're updating immediately\n                                    \n                                    const finalContent = contentBufferRef.current[messageId];\n                                    const currentMsg = messageRegistry.getMessages().find(m => m.id === messageId);\n                                    \n                                    if (finalContent) {\n                                        messageRegistry.updateMessage(messageId, {\n                                            content: finalContent,\n                                            metadata: {\n                                                ...(currentMsg?.metadata || {}),\n                                                isStreaming: false,\n                                                processingTime: Date.now() - processingStartTime.current,\n                                            },\n                                        });\n                                    } else {\n                                        messageRegistry.updateMessage(messageId, {\n                                            metadata: {\n                                                ...(currentMsg?.metadata || {}),\n                                                isStreaming: false,\n                                                processingTime: Date.now() - processingStartTime.current,\n                                            },\n                                        });\n                                    }\n                                    \n                                    // Clean up buffers\n                                    delete contentBufferRef.current[messageId];\n                                }\n                                \n                                // Ensure streaming flags are cleared immediately\n                                actions.setStreaming(false);\n                                actions.setProcessing(false);\n                                debug.log('[useMessageInput] Stream complete, clearing processing flags');\n                                \n                                // Exit the async generator loop\n                                return;\n                        }\n                    }\n                }\n            } catch (error) {\n                messageRegistry.addMessage({\n                    role: \"system\",\n                    content: `Error: ${error instanceof Error ? error.message : String(error)}`,\n                });\n            } finally {\n                actions.setProcessing(false);\n                actions.setStreaming(false);\n                processingStartTime.current = 0;\n                \n                // Clear buffer ref\n                contentBufferRef.current = {};\n                \n                // Check for and clean up any stuck executions\n                // This helps ensure the loading indicator disappears\n                const activeExecutions = Array.from(store.executions.values()).filter(e => e.status === 'executing');\n                if (activeExecutions.length > 0) {\n                    debug.log(`[useMessageInput] Found ${activeExecutions.length} stuck executions, clearing...`);\n                    activeExecutions.forEach(exec => {\n                        actions.completeExecution(exec.id, { success: true, output: \"Execution completed\" });\n                    });\n                }\n            }\n        },\n        [agent, messageRegistry, executionRegistry, processingStartTime]\n    );\n\n    return {\n        sendMessage,\n    };\n};","import { GrokAgent } from \"../clanker/agent\";\nimport { MessageRegistryMessage } from \"../registry/messages\";\nimport { ConfirmationService } from \"./confirmation-service\";\nimport React from \"react\";\n\n// Type alias for backward compatibility\ntype ChatEntry = MessageRegistryMessage;\n\nexport interface Command {\n  name: string;\n  description: string;\n  usage?: string;\n  execute?: (options: CommandExecuteOptions) => Promise<void> | void;\n}\n\nexport interface CommandExecuteOptions {\n  args: string;\n  agent: GrokAgent;\n  chatHistory: ChatEntry[];\n  setChatHistory: React.Dispatch<React.SetStateAction<ChatEntry[]>>;\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n  setShowModelSelection?: React.Dispatch<React.SetStateAction<boolean>>;\n  setAutoEditEnabled?: React.Dispatch<React.SetStateAction<boolean>>;\n  confirmationService: ConfirmationService;\n}\n\nexport function getDefaultCommands(): Command[] {\n  return [\n    {\n      name: \"help\",\n      description: \"Show available commands\",\n      execute: ({ setChatHistory }) => {\n        const helpMessage = `Available commands:\n/help - Show this help message\n/clear - Clear chat history\n/model - Change AI model\n/save - Save chat history to file\n/load - Load chat history from file\n/auto - Toggle auto-edit mode\n/exit - Exit the application\n/tools - List available tools\n/stats - Show tool usage statistics`;\n\n        setChatHistory((prev) => [\n          ...prev,\n          {\n            id: `system-${Date.now()}`,\n            role: \"system\",\n            content: helpMessage,\n            timestamp: new Date(),\n          } as MessageRegistryMessage,\n        ]);\n      },\n    },\n    {\n      name: \"clear\",\n      description: \"Clear chat history\",\n      execute: ({ setChatHistory }) => {\n        setChatHistory([]);\n      },\n    },\n    {\n      name: \"model\",\n      description: \"Change AI model\",\n      execute: ({ setShowModelSelection }) => {\n        if (setShowModelSelection) {\n          setShowModelSelection(true);\n        }\n      },\n    },\n    {\n      name: \"save\",\n      description: \"Save chat history to file\",\n      usage: \"/save [filename]\",\n      execute: async ({ args, chatHistory, setChatHistory }) => {\n        const filename = args || `chat-${Date.now()}.json`;\n        try {\n          const fs = await import(\"fs/promises\");\n          await fs.writeFile(\n            filename,\n            JSON.stringify(chatHistory, null, 2),\n            \"utf-8\"\n          );\n          setChatHistory((prev) => [\n            ...prev,\n            {\n              id: `system-${Date.now()}`,\n              role: \"system\",\n              content: `Chat history saved to ${filename}`,\n              timestamp: new Date(),\n            } as MessageRegistryMessage,\n          ]);\n        } catch (error) {\n          setChatHistory((prev) => [\n            ...prev,\n            {\n              id: `system-${Date.now()}`,\n              role: \"system\",\n              content: `Error saving chat: ${error instanceof Error ? error.message : String(error)}`,\n              timestamp: new Date(),\n            } as MessageRegistryMessage,\n          ]);\n        }\n      },\n    },\n    {\n      name: \"load\",\n      description: \"Load chat history from file\",\n      usage: \"/load <filename>\",\n      execute: async ({ args, setChatHistory }) => {\n        if (!args) {\n          setChatHistory((prev) => [\n            ...prev,\n            {\n              id: `system-${Date.now()}`,\n              role: \"system\",\n              content: \"Please provide a filename: /load <filename>\",\n              timestamp: new Date(),\n            } as MessageRegistryMessage,\n          ]);\n          return;\n        }\n        \n        try {\n          const fs = await import(\"fs/promises\");\n          const data = await fs.readFile(args, \"utf-8\");\n          const loadedHistory = JSON.parse(data) as ChatEntry[];\n          setChatHistory(loadedHistory);\n        } catch (error) {\n          setChatHistory((prev) => [\n            ...prev,\n            {\n              id: `system-${Date.now()}`,\n              role: \"system\",\n              content: `Error loading chat: ${error instanceof Error ? error.message : String(error)}`,\n              timestamp: new Date(),\n            } as MessageRegistryMessage,\n          ]);\n        }\n      },\n    },\n    {\n      name: \"auto\",\n      description: \"Toggle auto-edit mode\",\n      execute: ({ setAutoEditEnabled, setChatHistory }) => {\n        if (setAutoEditEnabled) {\n          setAutoEditEnabled((prev) => {\n            const newValue = !prev;\n            setChatHistory((history) => [\n              ...history,\n              {\n                id: `system-${Date.now()}`,\n                role: \"system\",\n                content: `Auto-edit mode ${newValue ? \"enabled\" : \"disabled\"}`,\n                timestamp: new Date(),\n              } as MessageRegistryMessage,\n            ]);\n            return newValue;\n          });\n        }\n      },\n    },\n    {\n      name: \"exit\",\n      description: \"Exit the application\",\n      execute: () => {\n        process.exit(0);\n      },\n    },\n    {\n      name: \"tools\",\n      description: \"List available tools\",\n      execute: ({ agent, setChatHistory }) => {\n        const registry = agent.getRegistry();\n        const tools = registry.list();\n        const toolsList = tools\n          .map((tool) => `• ${tool.name} (${tool.id}) - ${tool.description}`)\n          .join(\"\\n\");\n        \n        setChatHistory((prev) => [\n          ...prev,\n          {\n            id: `system-${Date.now()}`,\n            role: \"system\",\n            content: `Available tools (${tools.length}):\\n${toolsList}`,\n            timestamp: new Date(),\n          } as MessageRegistryMessage,\n        ]);\n      },\n    },\n    {\n      name: \"stats\",\n      description: \"Show tool usage statistics\",\n      execute: ({ agent, setChatHistory }) => {\n        const stats = agent.getToolStats();\n        let statsMessage = \"Tool usage statistics:\\n\";\n        \n        const entries = Object.entries(stats);\n        if (entries.length === 0) {\n          statsMessage += \"No tools have been used yet.\";\n        } else {\n          entries.forEach(([toolId, toolStats]) => {\n            if (toolStats.executionCount > 0) {\n              statsMessage += `• ${toolId}: ${toolStats.executionCount} calls\\n`;\n            }\n          });\n        }\n        \n        setChatHistory((prev) => [\n          ...prev,\n          {\n            id: `system-${Date.now()}`,\n            role: \"system\",\n            content: statsMessage,\n            timestamp: new Date(),\n          } as MessageRegistryMessage,\n        ]);\n      },\n    },\n  ];\n}","import { useCallback, useEffect } from 'react';\nimport { useSnapshot } from 'valtio';\nimport { store, actions } from '../../store';\nimport { GrokAgent } from '../../clanker/agent';\nimport { messageRegistry as MessageRegistryType, MessageRegistryMessage } from '../../registry/messages';\nimport { getDefaultCommands } from '../../utils/commands';\nimport { ConfirmationService } from '../../utils/confirmation-service';\n\ninterface UseCommandInputProps {\n  agent: GrokAgent;\n  messageRegistry: typeof MessageRegistryType;\n}\n\nconst COMMAND_PREFIX = \"/\";\n\nexport function useCommandInput({ agent, messageRegistry }: UseCommandInputProps) {\n  const confirmationService = ConfirmationService.getInstance();\n  const commands = getDefaultCommands();\n  \n  const snap = useSnapshot(store);\n  const inputValue = snap.inputValue;\n  \n  // Use store for command suggestions state\n  const showCommandSuggestions = snap.showCommandSuggestions;\n  const selectedCommandIndex = snap.selectedCommandIndex;\n  \n  const setShowCommandSuggestions = (show: boolean) => {\n    store.showCommandSuggestions = show;\n  };\n  \n  const setSelectedCommandIndex = (index: number) => {\n    store.selectedCommandIndex = index;\n  };\n  \n  const commandSuggestions = inputValue.startsWith(COMMAND_PREFIX)\n    ? commands\n        .filter((cmd) =>\n          cmd.name.toLowerCase().startsWith(inputValue.slice(1).toLowerCase())\n        )\n        .map((cmd) => `${COMMAND_PREFIX}${cmd.name} - ${cmd.description}`)\n    : [];\n\n  useEffect(() => {\n    const shouldShow = inputValue.startsWith(COMMAND_PREFIX) && inputValue.length > 1 && commandSuggestions.length > 0;\n    setShowCommandSuggestions(shouldShow);\n    \n    // Also update the command suggestions in the store\n    store.commandSuggestions = commandSuggestions;\n  }, [inputValue, commandSuggestions.length, commandSuggestions]);\n\n  const handleCommand = useCallback(\n    async (command: string) => {\n      const parts = command.slice(1).split(\" \");\n      const cmdName = parts[0].toLowerCase();\n      const args = parts.slice(1).join(\" \");\n\n      const cmd = commands.find((c) => c.name.toLowerCase() === cmdName);\n      if (!cmd) {\n        messageRegistry.addMessage({\n          role: \"system\",\n          content: `Unknown command: ${command}`,\n        });\n        return;\n      }\n\n      if (cmd.execute) {\n        await cmd.execute({\n          args,\n          agent,\n          chatHistory: messageRegistry.getMessages(),\n          setChatHistory: (fn) => {\n            if (typeof fn === 'function') {\n              const currentMessages = messageRegistry.getMessages();\n              const newHistory = fn(currentMessages);\n              messageRegistry.clearMessages();\n              newHistory.forEach((msg: MessageRegistryMessage) => {\n                // If the message already has an ID (it's from existing history), keep it\n                // Otherwise, addMessage will generate a new ID\n                if (msg.id && currentMessages.some(m => m.id === msg.id)) {\n                  // It's an existing message, preserve it\n                  const { id, ...msgWithoutId } = msg;\n                  messageRegistry.addMessage(msgWithoutId);\n                } else {\n                  // It's a new message, add without ID\n                  const { id, ...msgWithoutId } = msg;\n                  messageRegistry.addMessage(msgWithoutId);\n                }\n              });\n            } else if (Array.isArray(fn)) {\n              // Handle direct array assignment (like setChatHistory([]))\n              messageRegistry.clearMessages();\n              fn.forEach((msg: MessageRegistryMessage) => {\n                const { id, ...msgWithoutId } = msg;\n                messageRegistry.addMessage(msgWithoutId);\n              });\n            }\n          },\n          setInput: actions.setInputValue,\n          setShowModelSelection: actions.toggleModelSelector,\n          setAutoEditEnabled: actions.setAutoEdit,\n          confirmationService,\n        });\n      }\n    },\n    [agent, messageRegistry, confirmationService, commands]\n  );\n  \n  const selectCommandSuggestion = useCallback(() => {\n    if (showCommandSuggestions && commandSuggestions.length > 0) {\n      const selectedCommand = commandSuggestions[selectedCommandIndex];\n      const cmdName = selectedCommand.split(\" - \")[0];\n      actions.setInputValue(cmdName);\n      setShowCommandSuggestions(false);\n      setSelectedCommandIndex(0);\n    }\n  }, [showCommandSuggestions, commandSuggestions, selectedCommandIndex]);\n  \n  const navigateCommandSuggestions = useCallback((direction: 'up' | 'down') => {\n    if (!showCommandSuggestions) return;\n    \n    if (direction === 'up') {\n      setSelectedCommandIndex(\n        selectedCommandIndex > 0\n          ? selectedCommandIndex - 1\n          : commandSuggestions.length - 1\n      );\n    } else {\n      setSelectedCommandIndex(\n        selectedCommandIndex < commandSuggestions.length - 1\n          ? selectedCommandIndex + 1\n          : 0\n      );\n    }\n  }, [showCommandSuggestions, selectedCommandIndex, commandSuggestions.length]);\n  \n  const cancelCommandSuggestions = useCallback(() => {\n    if (showCommandSuggestions) {\n      setShowCommandSuggestions(false);\n      setSelectedCommandIndex(0);\n    }\n  }, [showCommandSuggestions]);\n\n  return {\n    showCommandSuggestions,\n    selectedCommandIndex,\n    commandSuggestions,\n    handleCommand,\n    selectCommandSuggestion,\n    navigateCommandSuggestions,\n    cancelCommandSuggestions,\n    isCommand: inputValue.startsWith(COMMAND_PREFIX),\n  };\n}","import { useState, useCallback } from 'react';\nimport { useSnapshot } from 'valtio';\nimport { store, actions } from '../../store';\nimport { messageRegistry as MessageRegistryType } from '../../registry/messages';\n\ninterface UseInputHistoryProps {\n  messageRegistry: typeof MessageRegistryType;\n}\n\nexport function useInputHistory({ messageRegistry }: UseInputHistoryProps) {\n  const snap = useSnapshot(store);\n  const inputValue = snap.inputValue;\n  // Use actions.setInputValue directly\n  // Use actions.addToHistory directly\n  \n  const [historyIndex, setHistoryIndex] = useState<number | null>(null);\n  const [currentInput, setCurrentInput] = useState(\"\");\n  \n  const navigateHistory = useCallback((direction: 'up' | 'down') => {\n    const userMessages = messageRegistry.getMessagesByRole(\"user\");\n    \n    if (direction === 'up') {\n      if (userMessages.length > 0) {\n        if (historyIndex === null) {\n          setCurrentInput(inputValue);\n          setHistoryIndex(userMessages.length - 1);\n          actions.setInputValue(userMessages[userMessages.length - 1].content);\n        } else if (historyIndex > 0) {\n          setHistoryIndex(historyIndex - 1);\n          actions.setInputValue(userMessages[historyIndex - 1].content);\n        }\n      }\n    } else { // down\n      if (historyIndex !== null) {\n        if (historyIndex < userMessages.length - 1) {\n          setHistoryIndex(historyIndex + 1);\n          actions.setInputValue(userMessages[historyIndex + 1].content);\n        } else {\n          setHistoryIndex(null);\n          actions.setInputValue(currentInput);\n        }\n      }\n    }\n  }, [messageRegistry, inputValue, historyIndex, currentInput]);\n  \n  const resetHistory = useCallback(() => {\n    setHistoryIndex(null);\n    setCurrentInput(\"\");\n  }, []);\n  \n  const saveToHistory = useCallback((input: string) => {\n    if (input.trim()) {\n      actions.addToHistory(input);\n    }\n    resetHistory();\n  }, [resetHistory]);\n\n  return {\n    navigateHistory,\n    resetHistory,\n    saveToHistory,\n    isNavigatingHistory: historyIndex !== null,\n  };\n}","import {useCallback} from 'react';\nimport {useSnapshot} from 'valtio';\nimport {store, actions} from '../../store';\nimport {GrokAgent} from '../../clanker/agent';\nimport {messageRegistry as MessageRegistryType} from '../../registry/messages';\n\ninterface UseModelSelectionProps {\n    agent: GrokAgent;\n    messageRegistry: typeof MessageRegistryType;\n}\n\nexport function useModelSelection({agent, messageRegistry}: UseModelSelectionProps) {\n    const snap = useSnapshot(store);\n    const showModelSelection = snap.showModelSelection;\n    const selectedModelIndex = snap.selectedModelIndex;\n    const availableModels = snap.availableModels;\n    // Use actions.setModel directly\n\n    const setShowModelSelection = (show: boolean) => {\n        store.showModelSelection = show;\n    };\n\n    const setSelectedModelIndex = (index: number) => {\n        store.selectedModelIndex = index;\n    };\n\n    const selectModel = useCallback(() => {\n        const selectedModel = availableModels[selectedModelIndex];\n        agent.getClient().setModel(selectedModel);\n        actions.setModel(selectedModel);\n\n        messageRegistry.addMessage({\n            role: \"system\",\n            content: `Model changed to ${selectedModel}`,\n        });\n\n        setShowModelSelection(false);\n        setSelectedModelIndex(0);\n    }, [agent, messageRegistry, selectedModelIndex, availableModels]);\n\n    const navigateModelSelection = useCallback((direction: 'up' | 'down') => {\n        if (!showModelSelection) return;\n\n        if (direction === 'up') {\n            setSelectedModelIndex(\n                selectedModelIndex > 0\n                    ? selectedModelIndex - 1\n                    : availableModels.length - 1\n            );\n        } else {\n            setSelectedModelIndex(\n                selectedModelIndex < availableModels.length - 1\n                    ? selectedModelIndex + 1\n                    : 0\n            );\n        }\n    }, [showModelSelection, selectedModelIndex, availableModels.length]);\n\n    const cancelModelSelection = useCallback(() => {\n        if (showModelSelection) {\n            setShowModelSelection(false);\n            setSelectedModelIndex(0);\n        }\n    }, [showModelSelection]);\n\n    return {\n        showModelSelection,\n        selectedModelIndex,\n        availableModels,\n        selectModel,\n        navigateModelSelection,\n        cancelModelSelection,\n    };\n}","import {useSnapshot} from 'valtio';\nimport {store, actions} from '../store';\nimport {useMessageInput} from './input/useMessageInput';\nimport {useCommandInput} from './input/useCommandInput';\nimport {useInputHistory} from './input/useInputHistory';\nimport {useModelSelection} from './ui/useModelSelection';\nimport {GrokAgent} from '../clanker/agent';\nimport {messageRegistry} from '../registry/messages';\nimport {executionRegistry} from '../registry/execution';\nimport {ConfirmationOptions} from '../utils/confirmation-service';\nimport {MutableRefObject, useCallback} from \"react\";\n\ninterface UseInputHandlerProps {\n    agent: GrokAgent;\n    messageRegistry: typeof messageRegistry;\n    executionRegistry: typeof executionRegistry;\n    processingStartTime: MutableRefObject<number>;\n    confirmationOptions: ConfirmationOptions | null;\n}\n\n/**\n * Main orchestrator hook that combines all input handling functionality\n * This is a thin wrapper that delegates to specialized hooks\n */\nexport const useInputHandler = ({\n                                    agent,\n                                    messageRegistry,\n                                    executionRegistry,\n                                    processingStartTime,\n                                }: UseInputHandlerProps) => {\n    const snap = useSnapshot(store);\n    const inputValue = snap.inputValue;\n    // Use actions.setInputValue directly\n    const autoEditEnabled = snap.autoEditEnabled;\n\n    // Message handling\n    const {sendMessage} = useMessageInput({\n        agent,\n        messageRegistry,\n        executionRegistry,\n        processingStartTime,\n    });\n\n    // Command handling\n    const {\n        showCommandSuggestions,\n        selectedCommandIndex,\n        commandSuggestions,\n        handleCommand,\n        selectCommandSuggestion,\n        navigateCommandSuggestions,\n        cancelCommandSuggestions,\n        isCommand,\n    } = useCommandInput({agent, messageRegistry});\n\n    // History navigation\n    const {\n        navigateHistory,\n        saveToHistory,\n    } = useInputHistory({messageRegistry});\n\n    // Model selection\n    const {\n        showModelSelection,\n        selectedModelIndex,\n        availableModels,\n        selectModel,\n        navigateModelSelection,\n        cancelModelSelection,\n    } = useModelSelection({agent, messageRegistry});\n\n    // Main enter handler\n    const handleEnter = useCallback(async () => {\n        if (showCommandSuggestions) {\n            selectCommandSuggestion();\n        } else if (showModelSelection) {\n            selectModel();\n        } else if (inputValue.trim()) {\n            if (isCommand) {\n                await handleCommand(inputValue);\n            } else {\n                await sendMessage(inputValue);\n            }\n            saveToHistory(inputValue);\n        }\n    }, [\n        showCommandSuggestions,\n        showModelSelection,\n        inputValue,\n        isCommand,\n        selectCommandSuggestion,\n        selectModel,\n        handleCommand,\n        sendMessage,\n        saveToHistory,\n    ]);\n\n    // Main escape handler\n    const handleEscape = useCallback(() => {\n        if (showCommandSuggestions) {\n            cancelCommandSuggestions();\n        } else if (showModelSelection) {\n            cancelModelSelection();\n        } else {\n            actions.setInputValue(\"\");\n        }\n    }, [\n        showCommandSuggestions,\n        showModelSelection,\n        cancelCommandSuggestions,\n        cancelModelSelection,\n    ]);\n\n    // Main up arrow handler\n    const handleUpArrow = useCallback(() => {\n        if (showCommandSuggestions) {\n            navigateCommandSuggestions('up');\n        } else if (showModelSelection) {\n            navigateModelSelection('up');\n        } else {\n            navigateHistory('up');\n        }\n    }, [\n        showCommandSuggestions,\n        showModelSelection,\n        navigateCommandSuggestions,\n        navigateModelSelection,\n        navigateHistory,\n    ]);\n\n    // Main down arrow handler\n    const handleDownArrow = useCallback(() => {\n        if (showCommandSuggestions) {\n            navigateCommandSuggestions('down');\n        } else if (showModelSelection) {\n            navigateModelSelection('down');\n        } else {\n            navigateHistory('down');\n        }\n    }, [\n        showCommandSuggestions,\n        showModelSelection,\n        navigateCommandSuggestions,\n        navigateModelSelection,\n        navigateHistory,\n    ]);\n\n    return {\n        input: inputValue,\n        showCommandSuggestions,\n        selectedCommandIndex,\n        showModelSelection,\n        selectedModelIndex,\n        commandSuggestions,\n        availableModels,\n        autoEditEnabled,\n        handleEnter,\n        handleEscape,\n        handleUpArrow,\n        handleDownArrow,\n    };\n};","import {useEffect, useCallback} from 'react';\nimport {actions} from '../store';\nimport {ConfirmationService, ConfirmationOptions} from '../utils/confirmation-service';\nimport {StageType} from '../ui/stage/types';\n\n/**\n * Hook to handle confirmation dialogs with the confirmation service\n */\nexport const useConfirmationHandler = () => {\n    const confirmationService = ConfirmationService.getInstance();\n    // Use actions.requestConfirmation directly\n    // Use actions.respondToConfirmation directly\n    // Use actions.setProcessing directly\n    // Use actions.setStreaming directly\n    // Use actions.updateProcessingTime directly\n\n    useEffect(() => {\n        const handleConfirmationRequest = async (options: ConfirmationOptions) => {\n            // Push the tool confirmation stage\n            actions.pushStage({\n                id: 'tool-confirmation',\n                type: StageType.TOOL_CONFIRMATION,\n                props: {\n                    options,\n                    onConfirm: (result: { confirmed: boolean; dontAskAgain?: boolean }) => {\n                        confirmationService.confirmOperation(result.confirmed, result.dontAskAgain);\n                    },\n                    onReject: (result: { confirmed: boolean; feedback?: string; dontAskAgain?: boolean }) => {\n                        confirmationService.rejectOperation(result.feedback);\n                    }\n                }\n            });\n        };\n\n        confirmationService.on(\"confirmation-requested\", handleConfirmationRequest);\n\n        return () => {\n            confirmationService.off(\"confirmation-requested\", handleConfirmationRequest);\n        };\n    }, [confirmationService]);\n\n    const handleConfirmation = useCallback((dontAskAgain?: boolean) => {\n        actions.respondToConfirmation({confirmed: true, dontAskAgain});\n    }, []);\n\n    const handleRejection = useCallback((feedback?: string) => {\n        actions.respondToConfirmation({confirmed: false, feedback});\n        actions.setProcessing(false);\n        actions.setStreaming(false);\n        actions.updateProcessingTime(0);\n    }, []);\n\n    return {\n        handleConfirmation,\n        handleRejection,\n    };\n};","import { useEffect, useRef } from 'react';\nimport { useSnapshot } from 'valtio';\nimport { store, actions } from '../store';\n\n/**\n * Hook to track and update processing time\n */\nexport function useProcessingTimer() {\n  const snap = useSnapshot(store);\n  const isProcessing = snap.isProcessing;\n  const isStreaming = snap.isStreaming;\n  const processingStartTime = useRef<number>(0);\n  \n  useEffect(() => {\n    let interval: ReturnType<typeof setInterval>;\n    if (isProcessing || isStreaming) {\n      interval = setInterval(() => {\n        if (processingStartTime.current > 0) {\n          actions.updateProcessingTime(Date.now() - processingStartTime.current);\n        }\n      }, 100);\n    }\n    return () => clearInterval(interval);\n  }, [isProcessing, isStreaming]);\n  \n  return {\n    processingStartTime,\n  };\n}","import { GrokMessage, GrokToolCall } from \"../clanker/client\";\nimport { store, actions } from \"../store\";\n\nexport interface MessageRegistryMessage {\n    id: string;\n    role: \"user\" | \"assistant\" | \"tool\" | \"system\";\n    content: string;\n    timestamp: Date;\n    toolCalls?: GrokToolCall[];\n    toolCallId?: string;\n    metadata?: {\n        isStreaming?: boolean;\n        tokenCount?: number;\n        processingTime?: number;\n    };\n}\n\nexport interface MessageRegistryEvent {\n    type: \"added\" | \"updated\" | \"removed\" | \"cleared\";\n    message?: MessageRegistryMessage;\n    messages?: MessageRegistryMessage[];\n}\n\n/**\n * Message registry is now just a facade over the Valtio store\n * All methods directly manipulate the store\n */\nexport const messageRegistry = {\n    addMessage(message: Omit<MessageRegistryMessage, \"id\" | \"timestamp\">): MessageRegistryMessage {\n        actions.addMessage(message);\n        return store.messages[store.messages.length - 1];\n    },\n\n    updateMessage(id: string, updates: Partial<MessageRegistryMessage>): void {\n        actions.updateMessage(id, updates);\n    },\n\n    removeMessage(id: string): void {\n        const index = store.messages.findIndex((m) => m.id === id);\n        if (index === -1) return;\n        \n        store.messages.splice(index, 1);\n        store.messageCount = store.messages.length;\n    },\n\n    clearMessages(): void {\n        actions.clearMessages();\n    },\n\n    getMessages(): MessageRegistryMessage[] {\n        return [...store.messages];\n    },\n\n    getMessage(id: string): MessageRegistryMessage | undefined {\n        return store.messages.find(m => m.id === id);\n    },\n\n    getMessagesByRole(role: MessageRegistryMessage[\"role\"]): MessageRegistryMessage[] {\n        return store.messages.filter((m) => m.role === role);\n    },\n\n    getLastMessage(): MessageRegistryMessage | undefined {\n        return store.messages[store.messages.length - 1];\n    },\n\n    getLastMessageByRole(role: MessageRegistryMessage[\"role\"]): MessageRegistryMessage | undefined {\n        for (let i = store.messages.length - 1; i >= 0; i--) {\n            if (store.messages[i].role === role) {\n                return store.messages[i];\n            }\n        }\n        return undefined;\n    },\n\n    findMessageWithToolCall(toolCallId: string): MessageRegistryMessage | undefined {\n        return store.messages.find((m) =>\n            m.toolCalls?.some((tc) => tc.id === toolCallId)\n        );\n    },\n\n    toGrokMessages(): GrokMessage[] {\n        return store.messages.map((msg) => {\n            const grokMsg: Record<string, unknown> = {\n                role: msg.role,\n                content: msg.content,\n            };\n\n            if (msg.toolCalls && msg.toolCalls.length > 0) {\n                grokMsg.tool_calls = msg.toolCalls;\n            }\n\n            if (msg.role === \"tool\" && msg.toolCallId) {\n                grokMsg.tool_call_id = msg.toolCallId;\n            }\n\n            return grokMsg as unknown as GrokMessage;\n        });\n    },\n\n    getStats(): {\n        totalMessages: number;\n        messagesByRole: Record<MessageRegistryMessage[\"role\"], number>;\n        averageTokenCount: number;\n        totalTokenCount: number;\n    } {\n        const stats = {\n            totalMessages: store.messages.length,\n            messagesByRole: {\n                user: 0,\n                assistant: 0,\n                tool: 0,\n                system: 0,\n            } as Record<MessageRegistryMessage[\"role\"], number>,\n            averageTokenCount: 0,\n            totalTokenCount: 0,\n        };\n\n        let tokenSum = 0;\n        let tokenCount = 0;\n\n        for (const msg of store.messages) {\n            stats.messagesByRole[msg.role]++;\n            if (msg.metadata?.tokenCount) {\n                tokenSum += msg.metadata.tokenCount;\n                tokenCount++;\n            }\n        }\n\n        stats.totalTokenCount = tokenSum;\n        stats.averageTokenCount = tokenCount > 0 ? tokenSum / tokenCount : 0;\n\n        return stats;\n    },\n\n    // Streaming methods\n    startStreaming(messageId: string): void {\n        actions.startStreaming(messageId);\n    },\n\n    appendToMessage(messageId: string, content: string): void {\n        actions.appendToMessage(messageId, content);\n    },\n\n    finishStreaming(messageId: string, metadata?: MessageRegistryMessage['metadata']): void {\n        actions.finishStreaming(messageId, metadata);\n    },\n\n    addToolCalls(messageId: string, toolCalls: GrokToolCall[]): void {\n        actions.addToolCalls(messageId, toolCalls);\n    }\n};\n\n// For backward compatibility - just return the global registry object\nexport function createMessageRegistry(): typeof messageRegistry {\n    return messageRegistry;\n}\n\n// Re-export for backward compatibility\nexport const createRegistry = createMessageRegistry;\nexport const Messages = messageRegistry;","/**\n * Tool execution tracking for UI display\n */\n\nimport { store, actions } from \"../store\";\nimport { ToolResult } from \"../types\";\n\nexport interface ToolExecution {\n    id: string;\n    toolName: string;\n    arguments: Record<string, unknown>;\n    status: \"executing\" | \"completed\" | \"failed\";\n    result?: ToolResult;\n    startTime: Date;\n    endTime?: Date;\n}\n\nexport interface ExecutionEvent {\n    type: \"started\" | \"completed\" | \"failed\";\n    execution: ToolExecution;\n}\n\n/**\n * Execution registry is now just a facade over the Valtio store\n * All methods directly manipulate the store\n */\nexport const executionRegistry = {\n    start(id: string, toolName: string, args: Record<string, unknown>): void {\n        // The store generates its own ID, so we need to track the mapping\n        const executionId = actions.addExecution({\n            toolName,\n            arguments: args,\n        });\n        // Store the mapping from tool call ID to execution ID\n        (store as any).toolCallToExecutionMap = (store as any).toolCallToExecutionMap || new Map();\n        (store as any).toolCallToExecutionMap.set(id, executionId);\n    },\n\n    complete(id: string, result: ToolResult): void {\n        // Get the actual execution ID from our mapping\n        const toolCallMap = (store as any).toolCallToExecutionMap as Map<string, string> | undefined;\n        const executionId = toolCallMap?.get(id) || id;\n        \n        if (result.success) {\n            actions.completeExecution(executionId, result);\n        } else {\n            actions.failExecution(executionId, result.error || 'Unknown error');\n        }\n        \n        // Don't clean up the mapping - we need it for later lookups\n        // The mapping will persist for the session\n    },\n\n    get(id: string): ToolExecution | undefined {\n        // Check if this is a tool call ID that needs mapping\n        const toolCallMap = (store as any).toolCallToExecutionMap as Map<string, string> | undefined;\n        const executionId = toolCallMap?.get(id) || id;\n        return actions.getExecution(executionId);\n    },\n\n    getHistory(): ToolExecution[] {\n        return Array.from(store.executions.values());\n    },\n\n    clear(): void {\n        actions.clearExecutions();\n    }\n};\n\n// For backward compatibility - just return the global registry object\nexport function createExecutionRegistry(): typeof executionRegistry {\n    return executionRegistry;\n}\n\n// Re-export for backward compatibility\nexport const ExecutionRegistry = executionRegistry;","import { createRegistry as createMessageRegistry } from '../registry/messages';\nimport { createExecutionRegistry } from '../registry/execution';\n\n/**\n * Hook to get global registries\n * Since registries are now just facades over Valtio store,\n * we don't need state or lifecycle management\n */\nexport function useRegistries() {\n  // These are just global singletons now\n  const messageRegistry = createMessageRegistry();\n  const executionRegistry = createExecutionRegistry();\n  \n  return {\n    messageRegistry,\n    executionRegistry,\n  };\n}","import React, {useCallback, useEffect, useRef} from \"react\";\nimport {Box, useInput} from \"ink\";\nimport {useSnapshot} from \"valtio\";\nimport {GrokAgent} from \"../../clanker/agent\";\nimport {ChatLayout} from \"../components/chat/ChatLayout\";\nimport {CommandSuggestions} from \"../components/command-suggestions\";\nimport {ChatHistory} from \"../components/chat-history\";\nimport {ChatInput} from \"../components/chat/ChatInput\";\nimport {StatusBar} from \"../components/chat/StatusBar\";\nimport {LoadingAndStatus} from \"../components/chat/LoadingAndStatus\";\nimport {ModelSelection} from \"../components/model-selection\";\nimport {ConfirmationService} from \"../../utils/confirmation-service\";\nimport {useInputHandler} from \"../../hooks/useInputHandler\";\nimport {useConfirmationHandler} from \"../../hooks/useConfirmationHandler\";\nimport {useProcessingTimer} from \"../../hooks/useProcessingTimer\";\nimport {useRegistries} from \"../../hooks/useRegistries\";\nimport {store, actions} from \"../../store\";\nimport {StageType} from \"../stage/types\";\n\ninterface ChatContainerProps {\n    agent: GrokAgent;\n}\n\n/**\n * Main chat container component\n * Manages the overall chat interface and state\n */\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function ChatContainer({agent}: ChatContainerProps) {\n    // Use Valtio's useSnapshot as intended\n    const snap = useSnapshot(store);\n\n    // Get registries\n    const {messageRegistry, executionRegistry} = useRegistries();\n    const toolRegistry = agent.getRegistry();\n    const {handleConfirmation, handleRejection} = useConfirmationHandler();\n\n    // Timer for processing duration\n    const processingStartTime = useRef<number>(Date.now());\n    useProcessingTimer();\n\n    // Input handler state\n    const {\n        showCommandSuggestions,\n        showModelSelection,\n        handleEnter,\n        handleEscape,\n        handleUpArrow,\n        handleDownArrow,\n    } = useInputHandler({\n        agent,\n        messageRegistry,\n        executionRegistry,\n        processingStartTime,\n        confirmationOptions: snap.confirmationOptions,\n    });\n\n    // Confirmation service\n    const confirmationService = ConfirmationService.getInstance();\n\n    // Handle Ctrl+C\n    const handleCtrlC = useCallback(() => {\n        // Show exit confirmation modal\n        actions.pushStage({ id: 'exit-confirmation', type: StageType.EXIT_CONFIRMATION });\n    }, []);\n\n    // Toggle auto-edit\n    const toggleAutoEdit = useCallback(() => {\n        const newAutoEditState = !snap.autoEditEnabled;\n        actions.setAutoEdit(newAutoEditState);\n        // Don't set session flag anymore - auto-edit only affects file operations\n    }, [snap.autoEditEnabled]);\n\n\n    // Handle keyboard input directly here\n    useInput((inputChar: string, key: { [key: string]: boolean }) => {\n        // Skip all input if confirmation is active\n        if (snap.confirmationOptions) return;\n\n        // Check for Ctrl+C (ETX character, code 3)\n        if (inputChar.charCodeAt(0) === 3 || (key.ctrl && inputChar === 'c')) {\n            handleCtrlC();\n            return;\n        }\n\n\n        // Shift+Tab: Toggle auto-edit\n        if (key.shift && key.tab) {\n            toggleAutoEdit();\n            return;\n        }\n\n        // Enter key\n        if (key.return) {\n            handleEnter();\n            return;\n        }\n\n        // Escape key\n        if (key.escape) {\n            handleEscape();\n            return;\n        }\n\n        // Arrow keys\n        if (key.upArrow) {\n            handleUpArrow();\n            return;\n        }\n\n        if (key.downArrow) {\n            handleDownArrow();\n            return;\n        }\n\n        // Backspace/Delete\n        if (key.backspace || key.delete) {\n            actions.setInputValue(snap.inputValue.slice(0, -1));\n            return;\n        }\n\n        // Regular character input\n        if (!key.ctrl && !key.meta && inputChar) {\n            // Check for / command at start of input\n            if (inputChar === '/' && snap.inputValue === '') {\n                actions.pushStage({ id: 'command-palette', type: StageType.COMMAND_PALETTE });\n                return;\n            }\n            actions.setInputValue(snap.inputValue + inputChar);\n        }\n    });\n\n    // Command execution is now handled in CommandPaletteScreen\n\n    return (\n        <ChatLayout>\n            <Box flexDirection=\"column\" height=\"100%\" overflow=\"hidden\">\n                <Box flexDirection=\"column\" flexGrow={1} overflow=\"hidden\">\n                    <Box paddingX={2} flexShrink={0}>\n                        {showCommandSuggestions && <CommandSuggestions/>}\n                        {showModelSelection && <ModelSelection/>}\n                    </Box>\n                    <Box paddingX={2} flexGrow={1} overflow=\"hidden\" height=\"100%\">\n                        <ChatHistory messageRegistry={messageRegistry} executionRegistry={executionRegistry}\n                                     toolRegistry={toolRegistry}/>\n                    </Box>\n                </Box>\n                <Box flexDirection=\"column\" flexShrink={0}>\n                    <Box paddingX={2}>\n                        <LoadingAndStatus/>\n                    </Box>\n                    <ChatInput/>\n                    <Box paddingX={2}>\n                        <StatusBar/>\n                    </Box>\n                </Box>\n            </Box>\n        </ChatLayout>\n    );\n}","import React, {useState, useEffect, useRef} from 'react';\nimport {Box, Text, useFocus, useInput} from 'ink';\n\nexport interface InputProps {\n    value: string;\n    onChange: (value: string) => void;\n    placeholder?: string;\n    label?: string;\n    width?: number;\n    password?: boolean;\n    error?: boolean;\n    errorMessage?: string;\n    onFocus?: () => void;\n    onBlur?: () => void;\n    autoFocus?: boolean;\n    readOnly?: boolean;\n}\n\nexport const Input: React.FC<InputProps> = ({\n                                                value,\n                                                onChange,\n                                                placeholder = '',\n                                                label,\n                                                width,\n                                                password = false,\n                                                error = false,\n                                                errorMessage,\n                                                onFocus,\n                                                onBlur,\n                                                autoFocus = false,\n                                                readOnly = false\n                                            }) => {\n    const {isFocused} = useFocus({autoFocus});\n    const [cursorPosition, setCursorPosition] = useState(value.length);\n    const [showCursor, setShowCursor] = useState(true);\n    const [showPlaceholder, setShowPlaceholder] = useState(true);\n\n    // Handle focus events\n    useEffect(() => {\n        if (isFocused) {\n            onFocus?.();\n            setShowPlaceholder(false); // Show placeholder when focused\n        } else {\n            onBlur?.();\n            if (!value) {\n                setShowPlaceholder(true); // Show placeholder when not focused and no value\n            }\n        }\n    }, [isFocused, onFocus, onBlur]);\n\n    // Cursor and placeholder blink effect\n    useEffect(() => {\n        if (isFocused) {\n            const interval = setInterval(() => {\n                setShowCursor(prev => !prev);\n                // Only blink placeholder when there's no value\n                if (!value) {\n                    setShowPlaceholder(prev => !prev);\n                }\n            }, 500);\n            return () => clearInterval(interval);\n        } else {\n            setShowCursor(false);\n            setShowPlaceholder(true);\n        }\n    }, [isFocused, value]);\n\n    // Handle keyboard input\n    useInput((input, key) => {\n        if (!isFocused) return;\n\n        if (key.leftArrow) {\n            setCursorPosition(Math.max(0, cursorPosition - 1));\n        } else if (key.rightArrow) {\n            setCursorPosition(Math.min(value.length, cursorPosition + 1));\n        } else if (!readOnly && (key.backspace || key.delete)) {\n            if (cursorPosition > 0) {\n                const newValue = value.slice(0, cursorPosition - 1) + value.slice(cursorPosition);\n                onChange(newValue);\n                setCursorPosition(cursorPosition - 1);\n            }\n        } else if (!readOnly && input && !key.ctrl && !key.meta) {\n            const newValue = value.slice(0, cursorPosition) + input + value.slice(cursorPosition);\n            onChange(newValue);\n            setCursorPosition(cursorPosition + input.length);\n        }\n    });\n\n    // Update cursor position when value changes externally\n    useEffect(() => {\n        setCursorPosition(value.length);\n    }, [value]);\n\n    // Render the display value with cursor\n    const renderValue = () => {\n        const displayValue = password ? '•'.repeat(value.length) : value;\n\n        // Show placeholder when no value\n        if (!displayValue && !isFocused) {\n            return <Text color=\"gray\">{placeholder}</Text>;\n        }\n\n        if (!displayValue && isFocused) {\n            // Blinking placeholder with cursor\n            return (\n                <>\n                    {showPlaceholder && <Text color=\"gray\">{placeholder}</Text>}\n                    {showCursor && !showPlaceholder && <Text inverse> </Text>}\n                </>\n            );\n        }\n\n        // Show value with cursor when focused\n        if (isFocused && showCursor) {\n            const beforeCursor = displayValue.slice(0, cursorPosition);\n            const afterCursor = displayValue.slice(cursorPosition);\n\n            return (\n                <>\n                    {beforeCursor}\n                    <Text inverse> </Text>\n                    {afterCursor}\n                </>\n            );\n        }\n\n        return displayValue;\n    };\n\n    // Determine border color\n    const borderColor = error ? 'red' : (isFocused ? 'cyan' : 'gray');\n\n    return (\n        <Box flexDirection=\"column\" width=\"100%\">\n            {label && (\n                <Box>\n                    <Text color={error ? 'red' : undefined}>{label}</Text>\n                </Box>\n            )}\n            <Box\n                borderStyle=\"single\"\n                borderColor={borderColor}\n                width=\"100%\"\n                paddingX={1}\n                flexDirection=\"row\"\n            >\n                {isFocused && <Text color=\"cyan\">❯ </Text>}\n                {!isFocused && <Text> </Text>}\n                <Text>\n                    {renderValue()}\n                </Text>\n            </Box>\n            {error && errorMessage && (\n                <Box marginTop={1}>\n                    <Text color=\"red\" italic>{errorMessage}</Text>\n                </Box>\n            )}\n        </Box>\n    );\n};","import React, { useState, useEffect } from 'react';\nimport { Box, Text, useFocus, useInput } from 'ink';\n\nexport interface ButtonProps {\n    label: string;\n    onPress: () => void;\n    variant?: 'primary' | 'secondary' | 'danger';\n    disabled?: boolean;\n    width?: number;\n    autoFocus?: boolean;\n    filled?: boolean;\n}\n\nexport const Button: React.FC<ButtonProps> = ({\n    label,\n    onPress,\n    variant = 'primary',\n    disabled = false,\n    width,\n    autoFocus = false,\n    filled = false\n}) => {\n    const { isFocused } = useFocus({ autoFocus, isActive: !disabled });\n    const [isPressed, setIsPressed] = useState(false);\n\n    // Handle keyboard input\n    useInput((input, key) => {\n        if (!isFocused || disabled) return;\n\n        // Only space activates button when focused (Enter is handled by Form for submission)\n        if (input === ' ') {\n            setIsPressed(true);\n            setTimeout(() => {\n                setIsPressed(false);\n                onPress();\n            }, 150);\n        }\n    });\n\n    // Determine colors based on state and variant\n    const getColors = () => {\n        if (disabled) {\n            return {\n                borderColor: 'gray',\n                textColor: 'gray',\n                bgColor: undefined\n            };\n        }\n\n        if (isPressed) {\n            return {\n                borderColor: 'white',\n                textColor: 'black',\n                bgColor: 'white'\n            };\n        }\n\n        // Handle filled button styling\n        if (filled) {\n            const filledColors = {\n                primary: {\n                    borderColor: isFocused ? 'cyan' : 'white',\n                    textColor: isFocused ? 'black' : 'white',\n                    bgColor: isFocused ? 'cyan' : undefined\n                },\n                secondary: {\n                    borderColor: isFocused ? 'cyan' : 'gray',\n                    textColor: isFocused ? 'black' : 'gray',\n                    bgColor: isFocused ? 'cyan' : undefined\n                },\n                danger: {\n                    borderColor: isFocused ? 'red' : 'white',\n                    textColor: isFocused ? 'white' : 'white',\n                    bgColor: isFocused ? 'red' : undefined\n                }\n            };\n            return filledColors[variant];\n        }\n\n        const variantColors = {\n            primary: {\n                borderColor: isFocused ? 'cyan' : 'blue',\n                textColor: isFocused ? 'cyan' : 'blue',\n                bgColor: undefined\n            },\n            secondary: {\n                borderColor: isFocused ? 'magenta' : 'gray',\n                textColor: isFocused ? 'magenta' : 'white',\n                bgColor: undefined\n            },\n            danger: {\n                borderColor: isFocused ? 'red' : 'red',\n                textColor: isFocused ? 'redBright' : 'red',\n                bgColor: undefined\n            }\n        };\n\n        return variantColors[variant];\n    };\n\n    const { borderColor, textColor, bgColor } = getColors();\n\n    const buttonContent = filled && bgColor ? (\n        // Filled button - apply background to entire box\n        <Box\n            borderStyle=\"round\"\n            borderColor={borderColor}\n            width={width || undefined}\n            minWidth={label.length + 6}\n        >\n            <Text\n                color={textColor}\n                backgroundColor={bgColor}\n                bold={isFocused && !disabled}\n            >\n                {`  ${label}  `}\n            </Text>\n        </Box>\n    ) : (\n        // Regular button - padding without background\n        <Box\n            borderStyle=\"round\"\n            borderColor={borderColor}\n            paddingX={2}\n            paddingY={0}\n            width={width || undefined}\n            minWidth={label.length + 6}\n        >\n            <Text\n                color={textColor}\n                backgroundColor={bgColor}\n                bold={isFocused && !disabled}\n            >\n                {label}\n            </Text>\n        </Box>\n    );\n\n    // Add focus indicator\n    if (isFocused && !disabled) {\n        return (\n            <Box>\n                <Text color={borderColor}>▶ </Text>\n                {buttonContent}\n            </Box>\n        );\n    }\n\n    return (\n        <Box>\n            <Text>  </Text>\n            {buttonContent}\n        </Box>\n    );\n};","import React, { useState, useEffect } from 'react';\nimport { Box, Text, useInput } from 'ink';\nimport { SelectOption } from './Select';\n\nexport interface SelectDropdownProps {\n    options: SelectOption[];\n    selectedValue?: string;\n    onSelect: (value: string) => void;\n    onClose: () => void;\n    maxHeight?: number;\n    width?: number | string;\n}\n\nexport const SelectDropdown: React.FC<SelectDropdownProps> = ({\n    options,\n    selectedValue,\n    onSelect,\n    onClose,\n    maxHeight = 10,\n    width\n}) => {\n    const [highlightedIndex, setHighlightedIndex] = useState(() => {\n        const index = options.findIndex(opt => opt.value === selectedValue);\n        return index >= 0 ? index : 0;\n    });\n\n    // Handle keyboard input\n    useInput((input, key) => {\n        if (key.escape) {\n            onClose();\n            return;\n        }\n\n        if (key.upArrow || input === 'k') {\n            setHighlightedIndex(prev => (prev > 0 ? prev - 1 : options.length - 1));\n        } else if (key.downArrow || input === 'j') {\n            setHighlightedIndex(prev => (prev < options.length - 1 ? prev + 1 : 0));\n        } else if (key.return || input === ' ') {\n            onSelect(options[highlightedIndex].value);\n            onClose();\n        }\n    });\n\n    // Ensure highlighted item is visible\n    const visibleStart = Math.max(0, highlightedIndex - Math.floor(maxHeight / 2));\n    const visibleEnd = Math.min(options.length, visibleStart + maxHeight);\n    const visibleOptions = options.slice(visibleStart, visibleEnd);\n\n    return (\n        <Box\n            flexDirection=\"column\"\n            borderStyle=\"single\"\n            borderColor=\"cyan\"\n            paddingX={1}\n            paddingY={0}\n            width=\"100%\"\n        >\n            {visibleStart > 0 && (\n                <Text dimColor>↑ {visibleStart} more...</Text>\n            )}\n            \n            {visibleOptions.map((option, index) => {\n                const actualIndex = visibleStart + index;\n                const isHighlighted = actualIndex === highlightedIndex;\n                const isSelected = option.value === selectedValue;\n\n                return (\n                    <Box key={option.value} paddingX={0} width=\"100%\">\n                        <Text\n                            color={isHighlighted ? 'black' : isSelected ? 'cyan' : undefined}\n                            backgroundColor={isHighlighted ? 'cyan' : undefined}\n                            bold={isSelected}\n                            wrap=\"truncate\"\n                        >\n                            {isHighlighted ? '❯ ' : '  '}\n                            {option.label}\n                            {isSelected && !isHighlighted ? ' ✓' : ''}\n                        </Text>\n                    </Box>\n                );\n            })}\n            \n            {visibleEnd < options.length && (\n                <Text dimColor>↓ {options.length - visibleEnd} more...</Text>\n            )}\n        </Box>\n    );\n};","import React, { useState, useEffect } from 'react';\nimport { Box, Text, useFocus, useInput } from 'ink';\nimport { SelectDropdown } from './SelectDropdown';\n\nexport interface SelectOption {\n    label: string;\n    value: string;\n}\n\nexport interface SelectProps {\n    options: SelectOption[];\n    value?: string;\n    onChange?: (value: string) => void;\n    label?: string;\n    width?: number;\n    error?: boolean;\n    errorMessage?: string;\n    autoFocus?: boolean;\n    onFocus?: () => void;\n    onBlur?: () => void;\n    onDropdownOpen?: (open: boolean) => void;\n    vimMode?: 'normal' | 'insert';\n    onAutocompleteAccept?: () => void;\n    onVimModeChange?: (mode: 'normal' | 'insert') => void;\n    onSearchQueryChange?: (hasQuery: boolean) => void;\n}\n\nexport const Select: React.FC<SelectProps> = ({\n    options,\n    value,\n    onChange,\n    label,\n    width,\n    error = false,\n    errorMessage,\n    autoFocus = false,\n    onFocus,\n    onBlur,\n    onDropdownOpen,\n    vimMode = 'normal',\n    onAutocompleteAccept,\n    onVimModeChange,\n    onSearchQueryChange\n}) => {\n    const { isFocused } = useFocus({ autoFocus });\n    const [selectedIndex, setSelectedIndex] = useState(0);\n    const [showDropdown, setShowDropdown] = useState(false);\n    const [searchQuery, setSearchQuery] = useState('');\n    \n    // Update dropdown state in parent\n    useEffect(() => {\n        onDropdownOpen?.(showDropdown);\n    }, [showDropdown, onDropdownOpen]);\n    \n    // Update search query state in parent\n    useEffect(() => {\n        onSearchQueryChange?.(searchQuery.length > 0);\n    }, [searchQuery, onSearchQueryChange]);\n    \n    // Sync selected index with value\n    useEffect(() => {\n        if (value) {\n            const index = options.findIndex(opt => opt.value === value);\n            if (index >= 0) {\n                setSelectedIndex(index);\n            }\n        }\n    }, [value, options]);\n    \n    // Handle focus events\n    useEffect(() => {\n        if (isFocused) {\n            onFocus?.();\n        } else {\n            onBlur?.();\n            // Clear search when focus is lost\n            setSearchQuery('');\n        }\n    }, [isFocused, onFocus, onBlur]);\n    \n    // Find autocomplete match\n    const getAutocompleteMatch = () => {\n        if (!searchQuery) return null;\n        return options.find(opt => \n            opt.label.toLowerCase().startsWith(searchQuery.toLowerCase())\n        );\n    };\n\n    // Handle keyboard input\n    useInput((input, key) => {\n        if (!isFocused || options.length === 0) return;\n        \n        // Don't handle navigation keys if dropdown is open\n        if (showDropdown) return;\n        \n        if (input === ' ' && vimMode === 'normal') {\n            // Open dropdown on Space in normal mode\n            setShowDropdown(true);\n        } else if (key.tab && searchQuery && vimMode === 'insert') {\n            // Tab accepts autocomplete in insert mode when there's a search query\n            const match = getAutocompleteMatch();\n            if (match) {\n                const matchIndex = options.findIndex(opt => opt.value === match.value);\n                setSelectedIndex(matchIndex);\n                onChange?.(match.value);\n                setSearchQuery('');\n                onAutocompleteAccept?.(); // Block the next Tab navigation\n                onVimModeChange?.('normal'); // Switch back to normal mode\n                return; // Prevent further processing\n            }\n        } else if (vimMode === 'insert') {\n            // Handle typing in insert mode\n            if (key.backspace || key.delete) {\n                setSearchQuery(prev => prev.slice(0, -1));\n            } else if (input && !key.ctrl && !key.meta && input !== ' ') {\n                setSearchQuery(prev => prev + input);\n            }\n        }\n        // Left and right arrows are now handled by the Form for navigation\n    }, { isActive: true }); // Make this input handler higher priority\n    \n    const currentOption = options[selectedIndex] || options[0];\n    const borderColor = error ? 'red' : (isFocused ? 'cyan' : 'gray');\n    \n    // Handle dropdown selection\n    const handleDropdownSelect = (selectedValue: string) => {\n        const index = options.findIndex(opt => opt.value === selectedValue);\n        if (index >= 0) {\n            setSelectedIndex(index);\n            onChange?.(selectedValue);\n        }\n    };\n    \n    // Show dropdown overlay if open\n    if (showDropdown && isFocused) {\n        return (\n            <Box flexDirection=\"column\" width=\"100%\">\n                {label && (\n                    <Box>\n                        <Text color={error ? 'red' : undefined}>{label}</Text>\n                    </Box>\n                )}\n                <SelectDropdown\n                    options={options}\n                    selectedValue={currentOption?.value}\n                    onSelect={handleDropdownSelect}\n                    onClose={() => setShowDropdown(false)}\n                    width={width}\n                />\n            </Box>\n        );\n    }\n    \n    return (\n        <Box flexDirection=\"column\" width=\"100%\">\n            {label && (\n                <Box>\n                    <Text color={error ? 'red' : undefined}>{label}</Text>\n                </Box>\n            )}\n            <Box\n                borderStyle=\"single\"\n                borderColor={borderColor}\n                width=\"100%\"\n                paddingX={1}\n                flexDirection=\"row\"\n                alignItems=\"center\"\n            >\n                {isFocused && <Text color=\"cyan\">❯ </Text>}\n                {!isFocused && <Text>  </Text>}\n                <Box flexGrow={1} justifyContent=\"space-between\" flexDirection=\"row\">\n                    {searchQuery && vimMode === 'insert' ? (\n                        <Box>\n                            <Text>{searchQuery}</Text>\n                            {(() => {\n                                const match = getAutocompleteMatch();\n                                if (match && match.label.toLowerCase().startsWith(searchQuery.toLowerCase())) {\n                                    const suggestion = match.label.slice(searchQuery.length);\n                                    return <Text dimColor>{suggestion}</Text>;\n                                }\n                                return null;\n                            })()}\n                        </Box>\n                    ) : (\n                        <Text>{currentOption?.label || ''}</Text>\n                    )}\n                    <Box flexGrow={1} />\n                </Box>\n            </Box>\n            {error && errorMessage && (\n                <Box marginTop={1}>\n                    <Text color=\"red\" italic>{errorMessage}</Text>\n                </Box>\n            )}\n        </Box>\n    );\n};","import React from 'react';\nimport { Box, Text, useFocus, useInput } from 'ink';\n\nexport interface ToggleProps {\n    value?: boolean;\n    onChange?: (value: boolean) => void;\n    label?: string;\n    disabled?: boolean;\n    autoFocus?: boolean;\n    onFocus?: () => void;\n    onBlur?: () => void;\n}\n\nexport const Toggle: React.FC<ToggleProps> = ({\n    value = false,\n    onChange,\n    label,\n    disabled = false,\n    autoFocus = false\n}) => {\n    const { isFocused } = useFocus({ \n        autoFocus, \n        isActive: !disabled\n    });\n\n    // Handle keyboard input\n    useInput((input, key) => {\n        if (!isFocused || disabled) return;\n\n        // Space toggles the value\n        if (input === ' ' || key.return) {\n            onChange?.(!value);\n        }\n    });\n\n    const borderColor = isFocused ? 'cyan' : 'gray';\n    const textColor = disabled ? 'gray' : (isFocused ? 'cyan' : 'white');\n\n    return (\n        <Box flexDirection=\"column\" width=\"100%\">\n            {label && (\n                <Box>\n                    <Text color={disabled ? 'gray' : undefined}>{label}</Text>\n                </Box>\n            )}\n            <Box\n                borderStyle=\"round\"\n                borderColor={borderColor}\n                paddingX={1}\n                width={10}\n                justifyContent=\"center\"\n            >\n                <Text color={textColor} bold={isFocused}>\n                    {value ? '[✓]' : '[ ]'}\n                </Text>\n            </Box>\n        </Box>\n    );\n};","import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';\nimport { Box, Text, useInput } from 'ink';\n\ninterface FormField {\n    id: string;\n    type: 'input' | 'button' | 'checkbox' | 'select' | 'toggle';\n    row: number;\n    column: number;\n    required?: boolean;\n    validation?: (value: any) => string | undefined;\n}\n\ninterface FormContextValue {\n    fields: FormField[];\n    values: Record<string, any>;\n    errors: Record<string, string>;\n    focusedFieldId: string | null;\n    registerField: (field: FormField) => void;\n    unregisterField: (id: string) => void;\n    setValue: (id: string, value: any) => void;\n    setError: (id: string, error: string | undefined) => void;\n    focusField: (id: string) => void;\n    submitForm: () => void;\n    isSubmitting: boolean;\n    dropdownOpen: boolean;\n    setDropdownOpen: (open: boolean) => void;\n    vimMode: 'normal' | 'insert';\n    setVimMode: (mode: 'normal' | 'insert') => void;\n    blockNextTab: () => void;\n    shouldBlockTab: boolean;\n    setHasSearchQuery: (hasQuery: boolean) => void;\n    clearForm: () => void;\n}\n\nconst FormContext = createContext<FormContextValue | undefined>(undefined);\n\nexport const useForm = () => {\n    const context = useContext(FormContext);\n    if (!context) {\n        throw new Error('useForm must be used within a Form component');\n    }\n    return context;\n};\n\nexport interface FormProps {\n    onSubmit: (values: Record<string, any>) => void | Promise<void>;\n    initialValues?: Record<string, any>;\n    children: ReactNode;\n    layout?: 'vertical' | 'horizontal';\n}\n\nexport const Form: React.FC<FormProps> = ({\n    onSubmit,\n    initialValues = {},\n    children,\n    layout = 'vertical'\n}) => {\n    const [fields, setFields] = useState<FormField[]>([]);\n    const [values, setValues] = useState<Record<string, any>>(initialValues);\n    const [errors, setErrors] = useState<Record<string, string>>({});\n    const [focusedFieldId, setFocusedFieldId] = useState<string | null>(null);\n    const [isSubmitting, setIsSubmitting] = useState(false);\n    const [dropdownOpen, setDropdownOpen] = useState(false);\n    const [vimMode, setVimMode] = useState<'normal' | 'insert'>('normal');\n    const [shouldBlockTab, setShouldBlockTab] = useState(false);\n    const [hasSearchQuery, setHasSearchQuery] = useState(false);\n\n    // Register/unregister fields\n    const registerField = useCallback((field: FormField) => {\n        setFields(prev => {\n            // Remove existing field with same id and add the new one\n            const filtered = prev.filter(f => f.id !== field.id);\n            return [...filtered, field].sort((a, b) => {\n                if (a.row !== b.row) return a.row - b.row;\n                return a.column - b.column;\n            });\n        });\n    }, []);\n\n    const unregisterField = useCallback((id: string) => {\n        setFields(prev => prev.filter(f => f.id !== id));\n    }, []);\n\n    // Value and error management\n    const setValue = useCallback((id: string, value: any) => {\n        setValues(prev => ({ ...prev, [id]: value }));\n        // Clear error when value changes\n        setErrors(prev => {\n            const newErrors = { ...prev };\n            delete newErrors[id];\n            return newErrors;\n        });\n    }, []);\n\n    const setError = useCallback((id: string, error: string | undefined) => {\n        if (error) {\n            setErrors(prev => ({ ...prev, [id]: error }));\n        } else {\n            setErrors(prev => {\n                const newErrors = { ...prev };\n                delete newErrors[id];\n                return newErrors;\n            });\n        }\n    }, []);\n\n    // Focus management\n    const focusField = useCallback((id: string) => {\n        setFocusedFieldId(id);\n    }, []);\n\n    // Find next/previous field for navigation\n    const getNextField = (currentId: string, direction: 'next' | 'prev' | 'up' | 'down' | 'left' | 'right') => {\n        const sortedFields = [...fields].sort((a, b) => {\n            if (a.row !== b.row) return a.row - b.row;\n            return a.column - b.column;\n        });\n\n        const currentIndex = sortedFields.findIndex(f => f.id === currentId);\n        if (currentIndex === -1) return null;\n\n        const currentField = sortedFields[currentIndex];\n\n        switch (direction) {\n            case 'next': {\n                const nextIndex = (currentIndex + 1) % sortedFields.length;\n                return sortedFields[nextIndex];\n            }\n            case 'prev': {\n                const prevIndex = currentIndex === 0 ? sortedFields.length - 1 : currentIndex - 1;\n                return sortedFields[prevIndex];\n            }\n            case 'up': {\n                // Find fields in the previous row\n                const prevRowFields = sortedFields.filter(f => f.row === currentField.row - 1);\n                if (prevRowFields.length === 0) {\n                    // No previous row, wrap to last row\n                    const lastRow = Math.max(...sortedFields.map(f => f.row));\n                    const lastRowFields = sortedFields.filter(f => f.row === lastRow);\n                    // Find closest column\n                    return lastRowFields.sort((a, b) => \n                        Math.abs(a.column - currentField.column) - Math.abs(b.column - currentField.column)\n                    )[0] || null;\n                }\n                // Find field with closest column\n                return prevRowFields.sort((a, b) => \n                    Math.abs(a.column - currentField.column) - Math.abs(b.column - currentField.column)\n                )[0] || null;\n            }\n            case 'down': {\n                // Find fields in the next row\n                const nextRowFields = sortedFields.filter(f => f.row === currentField.row + 1);\n                if (nextRowFields.length === 0) {\n                    // No next row, wrap to first row\n                    const firstRowFields = sortedFields.filter(f => f.row === 0);\n                    // Find closest column\n                    return firstRowFields.sort((a, b) => \n                        Math.abs(a.column - currentField.column) - Math.abs(b.column - currentField.column)\n                    )[0] || null;\n                }\n                // Find field with closest column\n                return nextRowFields.sort((a, b) => \n                    Math.abs(a.column - currentField.column) - Math.abs(b.column - currentField.column)\n                )[0] || null;\n            }\n            case 'left': {\n                // Find all fields in same row\n                const sameRowFields = sortedFields.filter(f => f.row === currentField.row);\n                if (sameRowFields.length <= 1) return null; // Only current field in row\n                \n                // Find previous field in same row\n                const currentIndexInRow = sameRowFields.findIndex(f => f.id === currentId);\n                const prevIndex = currentIndexInRow === 0 ? sameRowFields.length - 1 : currentIndexInRow - 1;\n                return sameRowFields[prevIndex];\n            }\n            case 'right': {\n                // Find all fields in same row\n                const sameRowFields = sortedFields.filter(f => f.row === currentField.row);\n                if (sameRowFields.length <= 1) return null; // Only current field in row\n                \n                // Find next field in same row\n                const currentIndexInRow = sameRowFields.findIndex(f => f.id === currentId);\n                const nextIndex = (currentIndexInRow + 1) % sameRowFields.length;\n                return sameRowFields[nextIndex];\n            }\n            default:\n                return null;\n        }\n    };\n\n    // Function to block next tab\n    const blockNextTab = useCallback(() => {\n        setShouldBlockTab(true);\n        // Clear the block after a longer delay to ensure it catches the Tab\n        setTimeout(() => setShouldBlockTab(false), 250);\n    }, []);\n\n    // Handle keyboard navigation with high priority\n    useInput((input, key) => {\n        // Handle Tab blocking\n        if (key.tab && shouldBlockTab) {\n            setShouldBlockTab(false);\n            return; // Consume the Tab key\n        }\n        \n        // Prevent Tab navigation entirely in vim mode\n        if (key.tab && !key.shift) {\n            return; // Consume all Tab keys\n        }\n\n        // Handle ESC to go back to normal mode from anywhere\n        if (key.escape) {\n            setVimMode('normal');\n            return;\n        }\n\n        if (!focusedFieldId) {\n            // Don't handle input if no field is focused\n            return;\n        }\n\n        // If dropdown is open, don't handle navigation keys\n        if (dropdownOpen) {\n            return;\n        }\n\n        // Handle vim mode switching\n        if (vimMode === 'normal') {\n            if (input === 'i') {\n                setVimMode('insert');\n                return;\n            }\n            \n            // Navigation only works in normal mode\n            if (key.upArrow || input === 'k') {\n                const nextField = getNextField(focusedFieldId, 'up');\n                if (nextField) {\n                    setFocusedFieldId(nextField.id);\n                }\n            } else if (key.downArrow || input === 'j') {\n                const nextField = getNextField(focusedFieldId, 'down');\n                if (nextField) {\n                    setFocusedFieldId(nextField.id);\n                }\n            } else if (key.leftArrow || input === 'h') {\n                const nextField = getNextField(focusedFieldId, 'left');\n                if (nextField) {\n                    setFocusedFieldId(nextField.id);\n                }\n            } else if (key.rightArrow || input === 'l') {\n                const nextField = getNextField(focusedFieldId, 'right');\n                if (nextField) {\n                    setFocusedFieldId(nextField.id);\n                }\n            }\n        }\n\n        // Enter key always submits the form\n        if (key.return) {\n            submitForm();\n            return;\n        }\n    }, { isActive: true }); // High priority to intercept Tab before Ink's focus system\n\n    // Form submission\n    const submitForm = useCallback(async () => {\n        // Validate all fields\n        const newErrors: Record<string, string> = {};\n        let hasErrors = false;\n\n        for (const field of fields) {\n            if (field.required && !values[field.id]) {\n                newErrors[field.id] = 'This field is required';\n                hasErrors = true;\n            } else if (field.validation) {\n                const error = field.validation(values[field.id]);\n                if (error) {\n                    newErrors[field.id] = error;\n                    hasErrors = true;\n                }\n            }\n        }\n\n        setErrors(newErrors);\n\n        if (hasErrors) {\n            // Focus first error field\n            const firstErrorField = fields.find(f => newErrors[f.id]);\n            if (firstErrorField) {\n                setFocusedFieldId(firstErrorField.id);\n            }\n            return;\n        }\n\n        setIsSubmitting(true);\n        try {\n            await onSubmit(values);\n        } finally {\n            setIsSubmitting(false);\n        }\n    }, [fields, values, onSubmit]);\n    \n    // Clear form\n    const clearForm = useCallback(() => {\n        setValues(initialValues);\n        setErrors({});\n        setHasSearchQuery(false);\n        // Reset to first field\n        if (fields.length > 0) {\n            setFocusedFieldId(fields[0].id);\n        }\n    }, [initialValues, fields]);\n\n    // Set initial focus\n    useEffect(() => {\n        if (!focusedFieldId && fields.length > 0) {\n            // Fields are already sorted in registerField\n            setFocusedFieldId(fields[0].id);\n        }\n    }, [fields.length]); // Only depend on length to avoid re-focusing\n\n    const contextValue: FormContextValue = {\n        fields,\n        values,\n        errors,\n        focusedFieldId,\n        registerField,\n        unregisterField,\n        setValue,\n        setError,\n        focusField,\n        submitForm,\n        isSubmitting,\n        dropdownOpen,\n        setDropdownOpen,\n        vimMode,\n        setVimMode,\n        blockNextTab,\n        shouldBlockTab,\n        setHasSearchQuery,\n        clearForm\n    };\n\n    // Determine which tip to show\n    const focusedField = fields.find(f => f.id === focusedFieldId);\n    const isSelectFocused = focusedField?.type === 'select';\n    const isInputFocused = focusedField?.type === 'input';\n    const isButtonFocused = focusedField?.type === 'button';\n    \n    let contextualTip = '';\n    if (dropdownOpen) {\n        contextualTip = '↑↓/jk Nav • Space/Enter Select • ESC Cancel';\n    } else if (isSelectFocused && vimMode === 'insert' && hasSearchQuery) {\n        contextualTip = 'Type to search • Tab: complete';\n    } else if (isSelectFocused && vimMode === 'normal') {\n        contextualTip = 'Space: dropdown';\n    } else if (isInputFocused && vimMode === 'normal') {\n        contextualTip = 'i: insert mode';\n    } else if (isButtonFocused) {\n        contextualTip = 'Space/Enter: select';\n    } else {\n        contextualTip = '↑↓←→/hjkl: move • Enter: save';\n    }\n\n    return (\n        <FormContext.Provider value={contextValue}>\n            <Box flexDirection=\"column\" width=\"100%\">\n                {/* Top corners - tip on right, vim mode on left */}\n                <Box flexDirection=\"row\" justifyContent=\"space-between\" marginBottom={-1}>\n                    {/* Vim mode indicator outside top left */}\n                    <Box \n                        borderStyle=\"round\"\n                        borderColor=\"gray\"\n                        paddingX={1}\n                        marginLeft={2}\n                    >\n                        <Text dimColor>mode: {vimMode}</Text>\n                    </Box>\n                    \n                    {/* Contextual tip box outside top right */}\n                    <Box \n                        borderStyle=\"round\"\n                        borderColor=\"gray\"\n                        paddingX={1}\n                        marginRight={2}\n                    >\n                        <Text dimColor>{contextualTip}</Text>\n                    </Box>\n                </Box>\n                \n                <Box \n                    borderStyle=\"round\"\n                    borderColor=\"gray\"\n                    paddingX={2}\n                    paddingY={1}\n                    flexDirection=\"column\"\n                >\n                    {children}\n                </Box>\n            </Box>\n        </FormContext.Provider>\n    );\n};","import React, { useEffect } from 'react';\nimport { Input, InputProps } from './Input';\nimport { useForm } from './Form';\n\nexport interface FormInputProps extends Omit<InputProps, 'value' | 'onChange' | 'error' | 'errorMessage' | 'autoFocus'> {\n    name: string;\n    row?: number;\n    column?: number;\n    required?: boolean;\n    validation?: (value: string) => string | undefined;\n}\n\nexport const FormInput: React.FC<FormInputProps> = ({\n    name,\n    row = 0,\n    column = 0,\n    required = false,\n    validation,\n    ...inputProps\n}) => {\n    const { \n        registerField, \n        unregisterField, \n        setValue, \n        values, \n        errors, \n        focusedFieldId,\n        vimMode\n    } = useForm();\n\n    useEffect(() => {\n        registerField({\n            id: name,\n            type: 'input',\n            row,\n            column,\n            required,\n            validation\n        });\n\n        return () => {\n            unregisterField(name);\n        };\n    }, [name, row, column, required, validation, registerField, unregisterField]);\n\n    const handleChange = (value: string) => {\n        setValue(name, value);\n    };\n\n    return (\n        <Input\n            {...inputProps}\n            value={values[name] || ''}\n            onChange={handleChange}\n            error={!!errors[name]}\n            errorMessage={errors[name]}\n            autoFocus={focusedFieldId === name}\n            readOnly={vimMode === 'normal'}\n        />\n    );\n};","import React, { useEffect } from 'react';\nimport { Button, ButtonProps } from './Button';\nimport { useForm } from './Form';\n\nexport interface FormButtonProps extends Omit<ButtonProps, 'onPress' | 'autoFocus'> {\n    name: string;\n    row?: number;\n    column?: number;\n    type?: 'submit' | 'button';\n    onPress?: () => void;\n}\n\nexport const FormButton: React.FC<FormButtonProps> = ({\n    name,\n    row = 0,\n    column = 0,\n    type = 'button',\n    onPress,\n    ...buttonProps\n}) => {\n    const { \n        registerField, \n        unregisterField, \n        focusedFieldId,\n        submitForm,\n        isSubmitting\n    } = useForm();\n\n    useEffect(() => {\n        registerField({\n            id: name,\n            type: 'button',\n            row,\n            column\n        });\n\n        return () => {\n            unregisterField(name);\n        };\n    }, [name, row, column, registerField, unregisterField]);\n\n    const handlePress = () => {\n        if (type === 'submit') {\n            submitForm();\n        } else if (onPress) {\n            onPress();\n        }\n    };\n\n    return (\n        <Button\n            {...buttonProps}\n\n            onPress={handlePress}\n            autoFocus={focusedFieldId === name}\n            disabled={buttonProps.disabled || (type === 'submit' && isSubmitting)}\n        />\n    );\n};","import React, { useEffect } from 'react';\nimport { Select, SelectProps, SelectOption } from './Select';\nimport { useForm } from './Form';\n\nexport interface FormSelectProps extends Omit<SelectProps, 'value' | 'onChange' | 'error' | 'errorMessage' | 'autoFocus'> {\n    name: string;\n    row?: number;\n    column?: number;\n    required?: boolean;\n    validation?: (value: string) => string | undefined;\n    onChange?: (value: string) => void;\n}\n\nexport const FormSelect: React.FC<FormSelectProps> = ({\n    name,\n    row = 0,\n    column = 0,\n    required = false,\n    validation,\n    options,\n    ...selectProps\n}) => {\n    const { \n        registerField, \n        unregisterField, \n        setValue, \n        values, \n        errors, \n        focusedFieldId,\n        setDropdownOpen,\n        vimMode,\n        blockNextTab,\n        setVimMode,\n        setHasSearchQuery\n    } = useForm();\n\n    // Register field on mount\n    useEffect(() => {\n        registerField({\n            id: name,\n            type: 'select',\n            row,\n            column,\n            required,\n            validation\n        });\n\n        return () => {\n            unregisterField(name);\n        };\n    }, [name, row, column, required, validation, registerField, unregisterField]);\n    \n    // Set initial value only once when component mounts and options are available\n    const hasInitialized = React.useRef(false);\n    useEffect(() => {\n        if (!hasInitialized.current && values[name] === undefined && options.length > 0) {\n            hasInitialized.current = true;\n            setValue(name, options[0].value);\n        }\n    }, [name, options, setValue]); // Don't include values to avoid loops\n\n    const handleChange = (value: string) => {\n        setValue(name, value);\n        // Call custom onChange if provided\n        selectProps.onChange?.(value);\n    };\n\n    return (\n        <Select\n            {...selectProps}\n            options={options}\n            value={values[name] || options[0]?.value}\n            onChange={handleChange}\n            error={!!errors[name]}\n            errorMessage={errors[name]}\n            autoFocus={focusedFieldId === name}\n            onDropdownOpen={setDropdownOpen}\n            vimMode={vimMode}\n            onAutocompleteAccept={blockNextTab}\n            onVimModeChange={setVimMode}\n            onSearchQueryChange={(hasQuery) => {\n                if (focusedFieldId === name) {\n                    setHasSearchQuery(hasQuery);\n                }\n            }}\n        />\n    );\n};","import React, { useEffect } from 'react';\nimport { Toggle, ToggleProps } from './Toggle';\nimport { useForm } from './Form';\n\nexport interface FormToggleProps extends Omit<ToggleProps, 'value' | 'onChange' | 'autoFocus'> {\n    name: string;\n    row?: number;\n    column?: number;\n}\n\nexport const FormToggle: React.FC<FormToggleProps> = ({\n    name,\n    row = 0,\n    column = 0,\n    ...toggleProps\n}) => {\n    const { \n        registerField, \n        unregisterField, \n        setValue, \n        values, \n        focusedFieldId\n    } = useForm();\n\n    useEffect(() => {\n        registerField({\n            id: name,\n            type: 'toggle',\n            row,\n            column\n        });\n\n        return () => {\n            unregisterField(name);\n        };\n    }, [name, row, column, registerField, unregisterField]);\n\n    const handleChange = (value: boolean) => {\n        setValue(name, value);\n    };\n\n    return (\n        <Toggle\n            {...toggleProps}\n            value={values[name] || false}\n            onChange={handleChange}\n            autoFocus={focusedFieldId === name}\n        />\n    );\n};","import React, { ReactNode, useState, useEffect } from 'react';\nimport { Box } from 'ink';\n\nexport type ColumnWidth = number | `${number}%` | 'auto' | 'flex';\n\nexport interface FormRowProps {\n    children: ReactNode;\n    gap?: number;\n    breakpoint?: number;\n    columns?: ColumnWidth[];\n}\n\nexport const FormRow: React.FC<FormRowProps> = ({ \n    children, \n    gap = 2,\n    breakpoint = 80,\n    columns\n}) => {\n    const [terminalWidth, setTerminalWidth] = useState(process.stdout.columns || 80);\n    \n    // Update terminal width on resize\n    useEffect(() => {\n        const handleResize = () => {\n            setTerminalWidth(process.stdout.columns || 80);\n        };\n        \n        process.stdout.on('resize', handleResize);\n        return () => {\n            process.stdout.off('resize', handleResize);\n        };\n    }, []);\n    \n    // Convert children to array\n    const childArray = React.Children.toArray(children);\n    const childCount = childArray.length;\n    \n    // Determine if we should stack\n    const shouldStack = terminalWidth < breakpoint || (childCount > 2 && !columns);\n    \n    if (shouldStack) {\n        return (\n            <Box flexDirection=\"column\" gap={gap} marginBottom={1} width=\"100%\">\n                {children}\n            </Box>\n        );\n    }\n    \n    // Calculate widths for horizontal layout\n    const calculateWidth = (index: number): number | undefined => {\n        // Account for form padding (4) and borders (2) and gaps\n        // Form has paddingX={2} on each side = 4\n        // Form border = 2\n        // Additional margin = 4\n        const formOverhead = 10;\n        const availableWidth = terminalWidth - formOverhead;\n        const totalGaps = gap * (childCount - 1);\n        const contentWidth = availableWidth - totalGaps;\n        \n        if (columns && columns[index]) {\n            const colWidth = columns[index];\n            \n            if (typeof colWidth === 'number') {\n                return colWidth;\n            } else if (typeof colWidth === 'string' && colWidth.endsWith('%')) {\n                const percentage = parseInt(colWidth) / 100;\n                return Math.floor(contentWidth * percentage);\n            } else if (colWidth === 'flex' || colWidth === 'auto') {\n                // For flex/auto, distribute remaining space equally\n                const fixedWidths = columns.reduce<number>((acc, col) => {\n                    if (typeof col === 'number') return acc + col;\n                    if (typeof col === 'string' && col.endsWith('%')) {\n                        return acc + Math.floor(contentWidth * (parseInt(col) / 100));\n                    }\n                    return acc;\n                }, 0);\n                \n                const flexCount = columns.filter(col => col === 'flex' || col === 'auto').length;\n                return Math.floor((contentWidth - fixedWidths) / flexCount);\n            }\n        }\n        \n        // Default: equal distribution\n        return Math.floor(contentWidth / childCount);\n    };\n    \n    return (\n        <Box \n            flexDirection=\"row\" \n            gap={gap}\n            marginBottom={1}\n            width=\"100%\"\n        >\n            {childArray.map((child, index) => (\n                <Box key={index} width={calculateWidth(index)}>\n                    {child}\n                </Box>\n            ))}\n        </Box>\n    );\n};","import React, { ReactNode } from 'react';\nimport { Box } from 'ink';\n\nexport interface FormGridProps {\n    children: ReactNode;\n    gap?: number;\n}\n\nexport const FormGrid: React.FC<FormGridProps> = ({ children, gap = 2 }) => {\n    const childArray = React.Children.toArray(children);\n    \n    return (\n        <Box flexDirection=\"row\" gap={gap} marginBottom={1}>\n            {childArray.map((child, index) => (\n                <Box key={index} flexGrow={1}>\n                    {child}\n                </Box>\n            ))}\n        </Box>\n    );\n};","import React from 'react';\nimport { FormSelect, FormSelectProps } from './FormSelect';\nimport { useForm } from './Form';\nimport { Provider, ProviderModels } from '../../../utils/settings-manager';\n\nexport interface ProviderSelectProps extends FormSelectProps {\n    onProviderChange?: (provider: Provider) => void;\n}\n\nexport const ProviderSelect: React.FC<ProviderSelectProps> = ({\n    onProviderChange,\n    ...props\n}) => {\n    const { setValue } = useForm();\n\n    const handleChange = (value: string) => {\n        const provider = value as Provider;\n        \n        // Update the model to the default for this provider\n        const providerConfig = ProviderModels[provider];\n        if (providerConfig && providerConfig.defaultModel) {\n            setValue('model', providerConfig.defaultModel);\n        }\n        \n        // Call the parent's change handler\n        if (onProviderChange) {\n            onProviderChange(provider);\n        }\n    };\n\n    return (\n        <FormSelect\n            {...props}\n            onChange={handleChange}\n        />\n    );\n};","import React from 'react';\nimport { FormButton, FormButtonProps } from './FormButton';\nimport { useForm } from './Form';\n\nexport interface ClearFormButtonProps extends Omit<FormButtonProps, 'onPress' | 'type'> {\n    onClear?: () => void;\n}\n\nexport const ClearFormButton: React.FC<ClearFormButtonProps> = ({\n    onClear,\n    ...props\n}) => {\n    const { clearForm } = useForm();\n    \n    const handlePress = () => {\n        clearForm();\n        onClear?.();\n    };\n    \n    return (\n        <FormButton\n            {...props}\n            onPress={handlePress}\n            type=\"button\"\n        />\n    );\n};","import React from 'react';\nimport { Box, Text } from 'ink';\nimport { useForm } from './Form';\n\nexport const VimModeIndicator: React.FC = () => {\n    const { vimMode } = useForm();\n    \n    return (\n        <Box \n            borderStyle=\"round\"\n            borderColor={vimMode === 'insert' ? 'green' : 'yellow'}\n            paddingX={1}\n        >\n            <Text \n                color={vimMode === 'insert' ? 'green' : 'yellow'}\n                bold\n            >\n                {vimMode === 'insert' ? 'INSERT' : 'NORMAL'}\n            </Text>\n        </Box>\n    );\n};","import React from 'react';\nimport { Box } from 'ink';\nimport { Button } from './Button';\nimport { useForm } from './Form';\n\nexport interface FormActionButtonsProps {\n    onSave?: () => void;\n    onClear?: () => void;\n}\n\nexport const FormActionButtons: React.FC<FormActionButtonsProps> = ({\n    onSave,\n    onClear\n}) => {\n    const { submitForm, clearForm } = useForm();\n    \n    const handleSave = () => {\n        submitForm();\n        onSave?.();\n    };\n    \n    const handleClear = () => {\n        clearForm();\n        onClear?.();\n    };\n    \n    return (\n        <Box flexDirection=\"row\" gap={2}>\n            <Button\n                label=\"Clear Form\"\n                onPress={handleClear}\n                variant=\"secondary\"\n            />\n            <Button\n                label=\"Save Settings\"\n                onPress={handleSave}\n                variant=\"primary\"\n            />\n        </Box>\n    );\n};","export { Input, type InputProps } from './Input';\nexport { Button, type ButtonProps } from './Button';\nexport { Select, type SelectProps, type SelectOption } from './Select';\nexport { Toggle, type ToggleProps } from './Toggle';\nexport { Form, useForm, type FormProps } from './Form';\nexport { FormInput, type FormInputProps } from './FormInput';\nexport { FormButton, type FormButtonProps } from './FormButton';\nexport { FormSelect, type FormSelectProps } from './FormSelect';\nexport { FormToggle, type FormToggleProps } from './FormToggle';\nexport { FormRow, type FormRowProps, type ColumnWidth } from './FormRow';\nexport { FormGrid, type FormGridProps } from './FormGrid';\nexport { ProviderSelect, type ProviderSelectProps } from './ProviderSelect';\nexport { ClearFormButton, type ClearFormButtonProps } from './ClearFormButton';\nexport { VimModeIndicator } from './VimModeIndicator';\nexport { FormActionButtons, type FormActionButtonsProps } from './FormActionButtons';","import { CommandDefinition, CommandRegistry } from './types';\n\nexport class CommandRegistryImpl implements CommandRegistry {\n    private commands = new Map<string, CommandDefinition>();\n\n    register(command: CommandDefinition): void {\n        if (this.commands.has(command.name)) {\n            console.warn(`Command \"${command.name}\" is already registered, skipping`);\n            return;\n        }\n        this.commands.set(command.name, command);\n    }\n\n    unregister(name: string): void {\n        this.commands.delete(name);\n    }\n\n    get(name: string): CommandDefinition | undefined {\n        return this.commands.get(name);\n    }\n\n    list(): CommandDefinition[] {\n        return Array.from(this.commands.values());\n    }\n\n    listByCategory(): Record<string, CommandDefinition[]> {\n        const categories: Record<string, CommandDefinition[]> = {};\n        \n        for (const command of this.commands.values()) {\n            const category = command.category || 'General';\n            if (!categories[category]) {\n                categories[category] = [];\n            }\n            categories[category].push(command);\n        }\n        \n        // Sort commands within each category\n        for (const category in categories) {\n            categories[category].sort((a, b) => a.name.localeCompare(b.name));\n        }\n        \n        return categories;\n    }\n}\n\n// Global singleton instance\nlet globalRegistry: CommandRegistryImpl | null = null;\n\nexport function getCommandRegistry(): CommandRegistryImpl {\n    if (!globalRegistry) {\n        globalRegistry = new CommandRegistryImpl();\n    }\n    return globalRegistry;\n}\n\n// Helper function to register commands\nexport function registerCommand(command: CommandDefinition): void {\n    getCommandRegistry().register(command);\n}\n\n// Helper decorator for registering commands\nexport function command(definition: Omit<CommandDefinition, 'exec'>) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        const exec = descriptor.value;\n        registerCommand({\n            ...definition,\n            exec\n        });\n        return descriptor;\n    };\n}","import React, { useMemo } from 'react';\nimport { Box, Text } from 'ink';\nimport { \n    Form, \n    FormSelect, \n    FormInput, \n    FormToggle, \n    FormButton, \n    SelectOption,\n    useForm \n} from '../components/form';\nimport { getCommandRegistry } from '../../commands/registry';\nimport { ArgumentDefinition } from '../../commands/types';\nimport { actions, store } from '../../store';\nimport { useSnapshot } from 'valtio';\nimport { StageType } from '../stage/types';\n\nexport const CommandPaletteScreen: React.FC = () => {\n    const registry = getCommandRegistry();\n    const snap = useSnapshot(store);\n    \n    // Get command options for the select\n    const commandOptions: SelectOption[] = useMemo(() => \n        registry.list().map(cmd => ({\n            value: cmd.name,\n            label: `${cmd.name} - ${cmd.description}`\n        })),\n        []\n    );\n    \n    // Escape key is handled by the form system, not here\n    \n    const handleSubmit = async (values: Record<string, any>) => {\n        const selectedCommand = values.command;\n        if (!selectedCommand) return;\n        \n        const commandDef = registry.get(selectedCommand);\n        if (!commandDef) return;\n        \n        // Extract command arguments from form values\n        const args: Record<string, any> = {};\n        if (commandDef.arguments) {\n            for (const arg of commandDef.arguments) {\n                if (values[arg.name] !== undefined) {\n                    args[arg.name] = values[arg.name];\n                }\n            }\n        }\n        \n        // Clear the \"/\" from input if it's there\n        if (snap.inputValue === '/') {\n            actions.setInputValue('');\n        }\n        \n        // Execute command first (it might need to know we're in command palette)\n        commandDef.exec(args);\n        \n        // Only pop if the command didn't replace the stage\n        const currentStage = actions.getCurrentStage();\n        if (currentStage.type === StageType.COMMAND_PALETTE) {\n            actions.popStage();\n        }\n    };\n    \n    const handleCancel = () => {\n        // Clear the \"/\" from input when canceling\n        if (snap.inputValue === '/') {\n            actions.setInputValue('');\n        }\n        actions.popStage();\n    };\n    \n    // Initial values\n    const initialValues: Record<string, any> = {\n        command: commandOptions[0]?.value || ''\n    };\n    \n    return (\n        <Box\n            width=\"100%\"\n            height=\"100%\"\n            flexDirection=\"column\"\n            justifyContent=\"center\"\n            alignItems=\"center\"\n        >\n            <Box\n                borderStyle=\"round\"\n                borderColor=\"cyan\"\n                paddingX={2}\n                paddingY={1}\n                width={60}\n                flexDirection=\"column\"\n            >\n                <Box marginBottom={1} justifyContent=\"center\">\n                    <Text bold color=\"cyan\">Command Palette</Text>\n                </Box>\n                \n                <Form \n                    onSubmit={handleSubmit} \n                    initialValues={initialValues}\n                >\n                    <CommandFormContent \n                        commandOptions={commandOptions}\n                        onCancel={handleCancel}\n                    />\n                </Form>\n            </Box>\n        </Box>\n    );\n};\n\n// Separate component to access form context\nconst CommandFormContent: React.FC<{\n    commandOptions: SelectOption[];\n    onCancel: () => void;\n}> = ({ commandOptions, onCancel }) => {\n    const registry = getCommandRegistry();\n    const [selectedCommand, setSelectedCommand] = React.useState(commandOptions[0]?.value || '');\n    const { setValue } = useForm();\n    \n    const commandDef = useMemo(() => \n        selectedCommand ? registry.get(selectedCommand) : null,\n        [selectedCommand, registry]\n    );\n    \n    // Load settings values when settings command is selected\n    React.useEffect(() => {\n        if (selectedCommand === 'settings') {\n            // Load current settings from store\n            const currentSettings = {\n                model: store.model,\n                theme: store.theme,\n                autoEditEnabled: store.autoEditEnabled,\n                vsCodeOpenEnabled: store.vsCodeOpenEnabled,\n                dangerousBypassPermission: store.dangerousBypassPermission,\n                virtualScrollingEnabled: store.virtualScrollingEnabled\n            };\n            \n            // Set form values\n            Object.entries(currentSettings).forEach(([key, value]) => {\n                setValue(key, value);\n            });\n        }\n    }, [selectedCommand, setValue]);\n    \n    const renderArgument = (arg: ArgumentDefinition, index: number) => {\n        const row = index + 1; // First row is for command selection\n        \n        switch (arg.type) {\n            case 'string':\n                return (\n                    <FormInput\n                        key={arg.name}\n                        name={arg.name}\n                        label={arg.description || arg.name}\n                        placeholder={arg.placeholder}\n                        required={arg.required}\n                        validation={arg.validation}\n                        row={row}\n                        column={0}\n                    />\n                );\n                \n            case 'boolean':\n                return (\n                    <FormToggle\n                        key={arg.name}\n                        name={arg.name}\n                        label={arg.description || arg.name}\n                        row={row}\n                        column={0}\n                    />\n                );\n                \n            case 'enum':\n                return (\n                    <FormSelect\n                        key={arg.name}\n                        name={arg.name}\n                        label={arg.description || arg.name}\n                        options={arg.options || []}\n                        required={arg.required}\n                        row={row}\n                        column={0}\n                    />\n                );\n                \n            default:\n                return null;\n        }\n    };\n    \n    return (\n        <>\n            <FormSelect\n                name=\"command\"\n                label=\"Command\"\n                options={commandOptions}\n                row={0}\n                column={0}\n                onChange={setSelectedCommand}\n            />\n            \n            {commandDef?.arguments?.map((arg, index) => renderArgument(arg, index))}\n            \n            <Box \n                flexDirection=\"row\" \n                gap={2} \n                marginTop={2}\n                justifyContent=\"flex-end\"\n            >\n                <FormButton\n                    name=\"cancel\"\n                    label=\"Cancel\"\n                    onPress={onCancel}\n                    variant=\"secondary\"\n                    row={commandDef?.arguments?.length ? commandDef.arguments.length + 1 : 1}\n                    column={0}\n                />\n                <FormButton\n                    name=\"execute\"\n                    label=\"Execute\"\n                    type=\"submit\"\n                    variant=\"primary\"\n                    filled\n                    row={commandDef?.arguments?.length ? commandDef.arguments.length + 1 : 1}\n                    column={1}\n                />\n            </Box>\n        </>\n    );\n};","import React, {useState, useEffect} from 'react';\nimport {Box, Text} from 'ink';\nimport {Form, FormInput, FormButton, FormSelect, FormToggle, ProviderSelect, ClearFormButton} from '../components/form';\nimport {SettingsManager, Settings, ProviderModels, Provider} from '../../utils/settings-manager';\n\n// Compact Clank logo component with color cycling\nconst CompactClankLogo: React.FC = () => {\n    const [colorIndex, setColorIndex] = useState(0);\n    const colors = ['red', 'yellow', 'green', 'cyan', 'blue', 'magenta'];\n\n    useEffect(() => {\n        const interval = setInterval(() => {\n            setColorIndex((prev) => (prev + 1) % colors.length);\n        }, 300);\n        return () => clearInterval(interval);\n    }, []);\n\n    return (\n        <Box\n            borderStyle=\"round\"\n            borderColor={colors[colorIndex]}\n            paddingX={2}\n            marginBottom={2}\n        >\n            <Text color={colors[colorIndex]}>\n                {'██████╗██╗      █████╗ ███╗   ██╗██╗  ██╗\\n'}\n                {'██╔════╝██║     ██╔══██╗████╗  ██║██║ ██╔╝\\n'}\n                {'██║     ██║     ███████║██╔██╗ ██║█████╔╝ \\n'}\n                {'██║     ██║     ██╔══██║██║╚██╗██║██╔═██╗ \\n'}\n                {'╚██████╗███████╗██║  ██║██║ ╚████║██║  ██╗\\n'}\n                {' ╚═════╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝'}\n            </Text>\n        </Box>\n    );\n};\n\n\ninterface SettingsScreenProps {\n    onComplete: (settings: Settings) => void;\n    onCancel?: () => void;\n}\n\nexport const SettingsScreen: React.FC<SettingsScreenProps> = ({onComplete, onCancel}) => {\n    const settingsManager = SettingsManager.getInstance();\n    const [initialValues, setInitialValues] = useState<Partial<Settings>>({});\n    const [selectedProvider, setSelectedProvider] = useState<Provider>('grok');\n\n    useEffect(() => {\n        const {settings} = settingsManager.loadSettings();\n        setInitialValues(settings);\n        if (settings.provider) {\n            setSelectedProvider(settings.provider as Provider);\n        }\n    }, []);\n\n    // Escape key is handled by the form system, not here\n\n    const handleSubmit = async (values: Record<string, any>): Promise<void> => {\n        try {\n            // Ensure all required fields are present\n            const settings: Settings = {\n                apiKey: values.apiKey,\n                provider: values.provider || selectedProvider,\n                model: values.model || ProviderModels[selectedProvider].defaultModel,\n                theme: values.theme || 'auto',\n                autoEditEnabled: values.autoEditEnabled || false,\n                vsCodeOpenEnabled: values.vsCodeOpenEnabled || false,\n                dangerousBypassPermission: values.dangerousBypassPermission || false,\n                virtualScrollingEnabled: values.virtualScrollingEnabled !== undefined ? values.virtualScrollingEnabled : true,\n                confirmationSettings: values.confirmationSettings || {\n                    alwaysEdit: false,\n                    alwaysBash: false,\n                    alwaysSearch: false\n                },\n                ...(selectedProvider === 'custom' && values.customBaseURL ? {customBaseURL: values.customBaseURL} : {})\n            };\n\n            console.log('Saving settings:', {...settings, apiKey: '***'});\n            settingsManager.saveSettings(settings);\n            onComplete(settings);\n        } catch (error) {\n            console.error('Failed to save settings:', error);\n        }\n    };\n\n    // Get provider options\n    const providerOptions = Object.entries(ProviderModels).map(([key, value]) => ({\n        value: key,\n        label: value.name\n    }));\n\n    // Get model options for selected provider\n    const modelOptions = [...(ProviderModels[selectedProvider]?.models || [])];\n\n    const validateApiKey = (value: string): string | undefined => {\n        if (!value || value.trim().length === 0) {\n            return 'API key is required';\n        }\n        if (value.length < 10) {\n            return 'API key seems too short';\n        }\n        return undefined;\n    };\n\n    const validateBaseURL = (value: string): string | undefined => {\n        if (!value) return undefined; // Optional field\n        try {\n            new URL(value);\n            return undefined;\n        } catch {\n            return 'Invalid URL format';\n        }\n    };\n\n    return (\n        <Box flexDirection=\"column\" paddingX={2} paddingY={1} width=\"100%\">\n            <Box justifyContent=\"center\">\n                <CompactClankLogo/>\n            </Box>\n\n            <Box justifyContent=\"center\" marginBottom={2}>\n                <Text bold color=\"cyan\">\n                    {Object.keys(initialValues).length > 0 ? 'Settings' : 'Initial Configuration'}\n                </Text>\n            </Box>\n\n            <Form onSubmit={handleSubmit} initialValues={initialValues}>\n                <FormInput\n                    name=\"apiKey\"\n                    label=\"Grok API Key\"\n                    placeholder=\"sk-...\"\n                    password\n                    required\n                    validation={validateApiKey}\n                    row={0}\n                    column={0}\n                />\n\n                <ProviderSelect\n                    name=\"provider\"\n                    label=\"Provider\"\n                    options={providerOptions}\n                    row={1}\n                    column={0}\n                    onProviderChange={setSelectedProvider}\n                />\n\n                {selectedProvider === 'custom' && (\n                    <FormInput\n                        name=\"customBaseURL\"\n                        label=\"Custom API Base URL\"\n                        placeholder=\"https://api.example.com/v1\"\n                        validation={validateBaseURL}\n                        required\n                        row={2}\n                        column={0}\n                    />\n                )}\n\n                <Box flexDirection=\"row\" gap={2}>\n                    {selectedProvider !== 'custom' && (\n                        <Box flexGrow={1} flexBasis=\"50%\">\n                            <FormSelect\n                                name=\"model\"\n                                label=\"Default Model\"\n                                options={modelOptions}\n                                row={2}\n                                column={0}\n                            />\n                        </Box>\n                    )}\n\n                    <Box flexGrow={1} flexBasis={selectedProvider === 'custom' ? \"100%\" : \"50%\"}>\n                        <FormSelect\n                            name=\"theme\"\n                            label=\"Theme\"\n                            options={[\n                                {label: 'Auto', value: 'auto'},\n                                {label: 'Light', value: 'light'},\n                                {label: 'Dark', value: 'dark'}\n                            ]}\n                            row={selectedProvider === 'custom' ? 3 : 2}\n                            column={selectedProvider === 'custom' ? 0 : 1}\n                        />\n                    </Box>\n                </Box>\n\n                {/* Toggle Settings */}\n                <Box marginTop={1} flexDirection=\"column\" gap={1}>\n                    <FormToggle\n                        name=\"autoEditEnabled\"\n                        label=\"Auto-edit (file operations only)\"\n                        row={selectedProvider === 'custom' ? 4 : 3}\n                        column={0}\n                    />\n\n                    <FormToggle\n                        name=\"vsCodeOpenEnabled\"\n                        label=\"VS Code integration\"\n                        row={selectedProvider === 'custom' ? 5 : 4}\n                        column={0}\n                    />\n\n                    <FormToggle\n                        name=\"dangerousBypassPermission\"\n                        label=\"Dangerously bypass permissions⚠\"\n                        row={selectedProvider === 'custom' ? 6 : 5}\n                        column={0}\n                    />\n\n                    <FormToggle\n                        name=\"virtualScrollingEnabled\"\n                        label=\"Virtual scrolling\"\n                        row={selectedProvider === 'custom' ? 7 : 6}\n                        column={0}\n                    />\n                </Box>\n\n                {/* Action buttons row with overlap styling */}\n                <Box marginTop={2} marginBottom={-2} flexDirection=\"row\" justifyContent=\"space-between\">\n                    <Box>\n                        {onCancel && (\n                            <FormButton\n                                name=\"cancel\"\n                                label=\"Cancel\"\n                                onPress={onCancel}\n                                variant=\"secondary\"\n                                row={selectedProvider === 'custom' ? 7 : 6}\n                                column={0}\n                            />\n                        )}\n                    </Box>\n\n                    <Box flexDirection=\"row\" gap={1}>\n                        <ClearFormButton\n                            name=\"clear\"\n                            label=\"Clear\"\n                            variant=\"secondary\"\n                            filled\n                            row={selectedProvider === 'custom' ? 4 : 3}\n                            column={1}\n                        />\n                        <FormButton\n                            name=\"save\"\n                            label=\"Save\"\n                            type=\"submit\"\n                            variant=\"primary\"\n                            filled\n                            row={selectedProvider === 'custom' ? 4 : 3}\n                            column={2}\n                        />\n                    </Box>\n                </Box>\n            </Form>\n        </Box>\n    );\n};","import React from 'react';\nimport { Box, Text, useInput } from 'ink';\nimport { actions } from '../../store';\n\nexport const HelpScreen: React.FC = () => {\n    useInput((input, key) => {\n        if (key.return) {\n            actions.popStage();\n        }\n    });\n    \n    return (\n        <Box\n            width=\"100%\"\n            height=\"100%\"\n            flexDirection=\"column\"\n            justifyContent=\"center\"\n            alignItems=\"center\"\n        >\n            <Box\n                borderStyle=\"round\"\n                borderColor=\"cyan\"\n                paddingX={2}\n                paddingY={1}\n                width={60}\n                flexDirection=\"column\"\n            >\n                <Box marginBottom={1} justifyContent=\"center\">\n                    <Text bold color=\"cyan\">Help</Text>\n                </Box>\n                \n                <Text>Commands:</Text>\n                <Text>  /clear - Clear chat history</Text>\n                <Text>  /theme - Change theme</Text>\n                <Text>  /model - Switch AI model</Text>\n                <Text>  /settings - Open settings</Text>\n                <Text>  /toggle-virtual-scroll - Toggle virtual scrolling</Text>\n                <Text>  /help - Show this help</Text>\n                \n                <Box marginTop={1}>\n                    <Text dimColor>Press Enter to close</Text>\n                </Box>\n            </Box>\n        </Box>\n    );\n};","import React, { useState } from 'react';\nimport { Box, Text, useInput } from 'ink';\nimport { ModalOptions, ModalResult } from '../stage/types';\n\ninterface ModalProps extends ModalOptions {\n    onSubmit: (result: ModalResult) => void;\n}\n\nexport const Modal: React.FC<ModalProps> = ({ title, message, options, onSubmit }) => {\n    const [selectedIndex, setSelectedIndex] = useState(0);\n    \n    useInput((input, key) => {\n        // Escape key does not close the modal - use a cancel button instead\n        \n        if (key.upArrow || input === 'k') {\n            setSelectedIndex(prev => prev > 0 ? prev - 1 : options.length - 1);\n        } else if (key.downArrow || input === 'j') {\n            setSelectedIndex(prev => (prev + 1) % options.length);\n        } else if (key.return || input === ' ') {\n            onSubmit({ \n                selected: options[selectedIndex].value, \n                cancelled: false \n            });\n        }\n    });\n    \n    return (\n        <Box\n            flexDirection=\"column\"\n            justifyContent=\"center\"\n            alignItems=\"center\"\n            height=\"100%\"\n        >\n            <Box\n                borderStyle=\"round\"\n                borderColor=\"cyan\"\n                paddingX={2}\n                paddingY={1}\n                minWidth={40}\n                flexDirection=\"column\"\n            >\n                <Box marginBottom={1} justifyContent=\"center\">\n                    <Text bold color=\"cyan\">{title}</Text>\n                </Box>\n                \n                {message && (\n                    <Box marginBottom={1}>\n                        <Text>{message}</Text>\n                    </Box>\n                )}\n                \n                <Box flexDirection=\"column\" marginTop={1}>\n                    {options.map((option, index) => {\n                        const isSelected = index === selectedIndex;\n                        const color = option.variant === 'danger' ? 'red' : \n                                     option.variant === 'primary' ? 'cyan' : \n                                     'white';\n                        \n                        return (\n                            <Box key={option.value} paddingY={0}>\n                                <Text color={isSelected ? color : 'gray'}>\n                                    {isSelected ? '▶ ' : '  '}\n                                    {option.label}\n                                </Text>\n                            </Box>\n                        );\n                    })}\n                </Box>\n                \n                <Box marginTop={1}>\n                    <Text dimColor>↑↓ Navigate • Enter/Space Select</Text>\n                </Box>\n            </Box>\n        </Box>\n    );\n};","import React from 'react';\nimport { Modal } from '../components/Modal';\nimport { ModalOptions, ModalResult } from '../stage/types';\nimport { actions } from '../../store';\n\ninterface ModalScreenProps extends ModalOptions {\n    onResult?: (result: ModalResult) => void;\n}\n\nexport const ModalScreen: React.FC<ModalScreenProps> = ({ \n    title, \n    message, \n    options,\n    onResult \n}) => {\n    const handleSubmit = (result: ModalResult) => {\n        // Call the callback if provided\n        if (onResult) {\n            onResult(result);\n        }\n        \n        // Pop the modal from the stage stack\n        actions.popStage();\n    };\n    \n    return (\n        <Modal\n            title={title}\n            message={message}\n            options={options}\n            onSubmit={handleSubmit}\n        />\n    );\n};","import React from 'react';\nimport { Modal } from '../components/Modal';\nimport { ModalOption } from '../stage/types';\nimport { actions } from '../../store';\nimport { useApp } from 'ink';\n\nexport const ExitConfirmationModal: React.FC = () => {\n    const { exit } = useApp();\n    \n    const options: ModalOption[] = [\n        { label: 'Cancel', value: 'cancel', variant: 'secondary' },\n        { label: 'Exit', value: 'exit', variant: 'danger' }\n    ];\n    \n    const handleSubmit = (result: { selected: string; cancelled: boolean }) => {\n        if (result.selected === 'exit') {\n            // Exit the application\n            exit();\n            setTimeout(() => process.exit(0), 100);\n        } else {\n            // Pop the modal and clear any input\n            actions.popStage();\n            actions.setInputValue(\"\");\n        }\n    };\n    \n    return (\n        <Modal\n            title=\"Exit Confirmation\"\n            message=\"Are you sure you want to exit?\"\n            options={options}\n            onSubmit={handleSubmit}\n        />\n    );\n};","import React from 'react';\nimport { Box, Text } from 'ink';\nimport { Form, FormInput, FormToggle, FormButton, useForm } from '../components/form';\nimport { ConfirmationOptions } from '../../utils/confirmation-service';\nimport { actions } from '../../store';\n\ninterface ToolConfirmationScreenProps {\n    options: ConfirmationOptions;\n    onConfirm: (result: { confirmed: boolean; feedback?: string; dontAskAgain?: boolean }) => void;\n    onReject: (result: { confirmed: boolean; feedback?: string; dontAskAgain?: boolean }) => void;\n}\n\n// Separate component to access form context\nconst ToolConfirmationFormContent: React.FC<{\n    options: ConfirmationOptions;\n    onCancel: () => void;\n}> = ({ options, onCancel }) => {\n    const { values } = useForm();\n    const isApproved = values.approve || false;\n    \n    // Determine the border color based on operation type\n    // const getBorderColor = () => {\n    //     const operation = options.operation.toLowerCase();\n    //     if (operation.includes('bash') || operation.includes('execute')) {\n    //         return 'red';\n    //     } else if (operation.includes('file') || operation.includes('write') || operation.includes('create')) {\n    //         return 'yellow';\n    //     } else {\n    //         return 'cyan';\n    //     }\n    // };\n    \n    return (\n        <>\n            <FormToggle\n                name=\"approve\"\n                label=\"Approve this action\"\n                row={0}\n                column={0}\n            />\n            \n            {!isApproved && (\n                <FormInput\n                    name=\"feedback\"\n                    label=\"Reason for rejection (optional)\"\n                    placeholder=\"Enter your concerns or feedback...\"\n                    row={1}\n                    column={0}\n                />\n            )}\n            \n            <FormToggle\n                name=\"dontAskAgain\"\n                label={isApproved ? \"Always allow this type of action\" : \"Never allow this type of action\"}\n                row={isApproved ? 1 : 2}\n                column={0}\n            />\n            \n            <Box \n                flexDirection=\"row\" \n                gap={2} \n                marginTop={2}\n                justifyContent=\"flex-end\"\n            >\n                <FormButton\n                    name=\"cancel\"\n                    label=\"Cancel\"\n                    onPress={onCancel}\n                    variant=\"secondary\"\n                    row={isApproved ? 2 : 3}\n                    column={0}\n                />\n                <FormButton\n                    name=\"submit\"\n                    label={isApproved ? \"Approve\" : \"Reject\"}\n                    type=\"submit\"\n                    variant={isApproved ? \"primary\" : \"danger\"}\n                    filled\n                    row={isApproved ? 2 : 3}\n                    column={1}\n                />\n            </Box>\n        </>\n    );\n};\n\nexport const ToolConfirmationScreen: React.FC<ToolConfirmationScreenProps> = ({ \n    options, \n    onConfirm, \n    onReject \n}) => {\n    const handleSubmit = (values: Record<string, any>) => {\n        if (values.approve) {\n            // User approved\n            onConfirm({\n                confirmed: true,\n                dontAskAgain: values.dontAskAgain || false\n            });\n        } else {\n            // User rejected with feedback\n            onReject({\n                confirmed: false,\n                feedback: values.feedback || '',\n                dontAskAgain: values.dontAskAgain || false\n            });\n        }\n        \n        // Close the confirmation screen\n        actions.popStage();\n    };\n    \n    const handleCancel = () => {\n        // Treat cancel as rejection without feedback\n        onReject({\n            confirmed: false,\n            feedback: 'Cancelled by user'\n        });\n        actions.popStage();\n    };\n    \n    // Determine the border color based on operation type\n    // const getBorderColor = () => {\n    //     const operation = options.operation.toLowerCase();\n    //     if (operation.includes('bash') || operation.includes('execute')) {\n    //         return 'red';\n    //     } else if (operation.includes('file') || operation.includes('write') || operation.includes('create')) {\n    //         return 'yellow';\n    //     } else {\n    //         return 'cyan';\n    //     }\n    // };\n    \n    return (\n        <Box\n            width=\"100%\"\n            height=\"100%\"\n            flexDirection=\"column\"\n            justifyContent=\"center\"\n            alignItems=\"center\"\n        >\n            <Box\n                borderStyle=\"round\"\n                borderColor=\"cyan\"\n                paddingX={2}\n                paddingY={1}\n                width={80}\n                flexDirection=\"column\"\n            >\n                <Box marginBottom={1} justifyContent=\"center\">\n                    <Text bold color=\"cyan\">\n                        Tool Confirmation Required\n                    </Text>\n                </Box>\n                \n                <Box marginBottom={1}>\n                    <Text>Operation: {options.operation}</Text>\n                    <Text>File: {options.filename}</Text>\n                </Box>\n                \n                {options.content && (\n                    <Box \n                        marginBottom={1}\n                        borderStyle=\"single\"\n                        borderColor=\"gray\"\n                        paddingX={1}\n                        paddingY={1}\n                        height={10}\n                    >\n                        <Text color=\"gray\">{options.content}</Text>\n                    </Box>\n                )}\n                \n                <Form \n                    onSubmit={handleSubmit} \n                    initialValues={{ \n                        approve: false, \n                        feedback: '',\n                        dontAskAgain: false \n                    }}\n                >\n                    <ToolConfirmationFormContent\n                        options={options}\n                        onCancel={handleCancel}\n                    />\n                </Form>\n            </Box>\n        </Box>\n    );\n};","import React, { useCallback } from 'react';\nimport { Box, useInput } from 'ink';\nimport { useSnapshot } from 'valtio';\nimport { store, actions } from '../../store';\nimport { StageType } from './types';\nimport { ChatContainer } from '../containers/ChatContainer';\nimport { CommandPaletteScreen } from '../screens/CommandPaletteScreen';\nimport { SettingsScreen } from '../screens/SettingsScreen';\nimport { HelpScreen } from '../screens/HelpScreen';\nimport { ModalScreen } from '../screens/ModalScreen';\nimport { ExitConfirmationModal } from '../screens/ExitConfirmationModal';\nimport { ToolConfirmationScreen } from '../screens/ToolConfirmationScreen';\nimport { GrokAgent } from '../../clanker/agent';\nimport { StatusBar } from '../components/chat/StatusBar';\nimport { SettingsManager } from '../../utils/settings-manager';\n\ninterface StageRouterProps {\n    agent: GrokAgent;\n}\n\nexport const StageRouter: React.FC<StageRouterProps> = ({ agent }) => {\n    const snap = useSnapshot(store);\n    const currentStage = snap.stageStack[snap.stageStack.length - 1];\n    \n    // Global Ctrl+C handler\n    const handleCtrlC = useCallback(() => {\n        // Show exit confirmation modal\n        actions.pushStage({ id: 'exit-confirmation', type: StageType.EXIT_CONFIRMATION });\n    }, []);\n    \n    // Global keyboard input handler\n    useInput((inputChar: string, key: { [key: string]: boolean }) => {\n        // Skip if we're in the chat container (it has its own handler)\n        if (currentStage.type === StageType.CHAT) return;\n        \n        // Check for Ctrl+C (ETX character, code 3)\n        if (inputChar.charCodeAt(0) === 3 || (key.ctrl && inputChar === 'c')) {\n            handleCtrlC();\n        }\n    });\n    \n    const renderStage = () => {\n        switch (currentStage.type) {\n            case StageType.CHAT:\n                return <ChatContainer agent={agent} />;\n                \n            case StageType.COMMAND_PALETTE:\n                return <CommandPaletteScreen />;\n                \n            case StageType.SETTINGS:\n                return <SettingsScreen \n                    onComplete={(settings) => {\n                        // Save settings to store\n                        actions.setModel(settings.model);\n                        actions.setTheme(settings.theme);\n                        actions.setAutoEdit(settings.autoEditEnabled);\n                        actions.setVSCodeOpen(settings.vsCodeOpenEnabled);\n                        actions.setDangerousBypassPermission(settings.dangerousBypassPermission);\n                        actions.updateConfirmationSettings(settings.confirmationSettings);\n                        \n                        // Save to file\n                        const settingsManager = SettingsManager.getInstance();\n                        settingsManager.saveSettings(settings);\n                        \n                        // Close the settings screen\n                        actions.popStage();\n                    }}\n                    onCancel={() => actions.popStage()}\n                />;\n                \n            case StageType.HELP:\n                return <HelpScreen />;\n                \n            case StageType.MODAL:\n                return <ModalScreen {...currentStage.props} />;\n                \n            case StageType.EXIT_CONFIRMATION:\n                return <ExitConfirmationModal />;\n                \n            case StageType.TOOL_CONFIRMATION:\n                return <ToolConfirmationScreen \n                    options={currentStage.props.options}\n                    onConfirm={currentStage.props.onConfirm}\n                    onReject={currentStage.props.onReject}\n                />;\n                \n            default:\n                return <ChatContainer agent={agent} />;\n        }\n    };\n    \n    return (\n        <Box width=\"100%\" height=\"100%\" flexDirection=\"column\" overflow=\"hidden\">\n            <Box flexGrow={1} overflow=\"hidden\">\n                {renderStage()}\n            </Box>\n            {/* Show status bar on all screens except chat (which has its own) */}\n            {currentStage.type !== StageType.CHAT && (\n                <Box flexShrink={0}>\n                    <StatusBar />\n                </Box>\n            )}\n        </Box>\n    );\n};","import { registerCommand } from './registry';\nimport { actions, store } from '../store';\nimport { StageType } from '../ui/stage/types';\n\nlet hasRegistered = false;\n\n// Register built-in commands\nexport function registerBuiltinCommands() {\n    if (hasRegistered) {\n        return;\n    }\n    hasRegistered = true;\n    // Clear command\n    registerCommand({\n        name: 'clear',\n        description: 'Clear the chat history',\n        category: 'Chat',\n        exec: () => {\n            actions.clearMessages();\n        }\n    });\n    \n    // Theme command\n    registerCommand({\n        name: 'theme',\n        description: 'Change the application theme',\n        category: 'Settings',\n        arguments: [\n            {\n                name: 'theme',\n                type: 'enum',\n                description: 'Theme',\n                required: true,\n                options: [\n                    { value: 'light', label: 'Light' },\n                    { value: 'dark', label: 'Dark' },\n                    { value: 'auto', label: 'Auto' }\n                ]\n            }\n        ],\n        exec: (args) => {\n            actions.setTheme(args.theme);\n        }\n    });\n    \n    // Model command\n    registerCommand({\n        name: 'model',\n        description: 'Switch AI model',\n        category: 'Settings',\n        arguments: [\n            {\n                name: 'model',\n                type: 'enum',\n                description: 'Model',\n                required: true,\n                options: [\n                    { value: 'grok-4-0709', label: 'Grok 4' },\n                    { value: 'grok-3', label: 'Grok 3' },\n                    { value: 'grok-3-mini', label: 'Grok 3 Mini' },\n                    { value: 'grok-3-fast', label: 'Grok 3 Fast' },\n                    { value: 'grok-3-mini-fast', label: 'Grok 3 Mini Fast' },\n                    { value: 'grok-2-vision-1212', label: 'Grok 2 Vision' },\n                    { value: 'grok-2-image-1212', label: 'Grok 2 Image' }\n                ]\n            }\n        ],\n        exec: (args) => {\n            actions.setModel(args.model);\n        }\n    });\n    \n    // Toggle commands\n    registerCommand({\n        name: 'toggle-auto-edit',\n        description: 'Toggle auto-edit mode (file operations only)',\n        category: 'Settings',\n        arguments: [\n            {\n                name: 'enabled',\n                type: 'boolean',\n                description: 'Enable auto-edit for file operations',\n                default: false\n            }\n        ],\n        exec: (args) => {\n            actions.setAutoEdit(args.enabled);\n            const status = args.enabled ? 'enabled' : 'disabled';\n            console.log(`Auto-edit is now ${status} for file operations`);\n        }\n    });\n    \n    registerCommand({\n        name: 'toggle-vscode',\n        description: 'Toggle VS Code integration',\n        category: 'Settings',\n        arguments: [\n            {\n                name: 'enabled',\n                type: 'boolean',\n                description: 'Enable VS Code integration',\n                default: false\n            }\n        ],\n        exec: (args) => {\n            actions.setVSCodeOpen(args.enabled);\n        }\n    });\n    \n    // Dangerous bypass permission command\n    registerCommand({\n        name: 'dbp',\n        description: 'Toggle dangerously bypass permission',\n        category: 'Settings',\n        arguments: [\n            {\n                name: 'enabled',\n                type: 'boolean',\n                description: 'Enable dangerous bypass (skips ALL confirmations)',\n                default: false\n            }\n        ],\n        exec: (args) => {\n            actions.setDangerousBypassPermission(args.enabled);\n            const status = args.enabled ? 'ENABLED' : 'DISABLED';\n            console.log(`⚠️  Dangerously Bypass Permission is now ${status}`);\n        }\n    });\n    \n    // Virtual scrolling toggle command\n    registerCommand({\n        name: 'toggle-virtual-scroll',\n        description: 'Toggle virtual scrolling for chat history',\n        category: 'Settings',\n        exec: () => {\n            const currentState = store.virtualScrollingEnabled;\n            actions.setVirtualScrolling(!currentState);\n            const status = !currentState ? 'enabled' : 'disabled';\n            console.log(`📜 Virtual scrolling is now ${status}`);\n        }\n    });\n    \n    // Search command\n    registerCommand({\n        name: 'search',\n        description: 'Search for text in files',\n        category: 'Tools',\n        arguments: [\n            {\n                name: 'query',\n                type: 'string',\n                description: 'Search query',\n                required: true,\n                placeholder: 'Enter search term...'\n            },\n            {\n                name: 'path',\n                type: 'string',\n                description: 'Path to search in',\n                default: '.',\n                placeholder: 'Path (default: current directory)'\n            },\n            {\n                name: 'caseSensitive',\n                type: 'boolean',\n                description: 'Case sensitive search',\n                default: false\n            }\n        ],\n        exec: async (args) => {\n            // This would integrate with the search tool\n            const message = `Searching for \"${args.query}\" in ${args.path}${args.caseSensitive ? ' (case sensitive)' : ''}`;\n            console.log(message);\n            // In a real implementation, this would call the search tool\n        }\n    });\n    \n    // Settings command\n    registerCommand({\n        name: 'settings',\n        description: 'Configure application settings',\n        category: 'System',\n        arguments: [\n            {\n                name: 'model',\n                type: 'enum',\n                description: 'AI Model',\n                required: false,\n                options: [\n                    { value: 'grok-4-0709', label: 'Grok 4' },\n                    { value: 'grok-3', label: 'Grok 3' },\n                    { value: 'grok-3-mini', label: 'Grok 3 Mini' },\n                    { value: 'grok-3-fast', label: 'Grok 3 Fast' },\n                    { value: 'grok-3-mini-fast', label: 'Grok 3 Mini Fast' },\n                    { value: 'grok-2-vision-1212', label: 'Grok 2 Vision' },\n                    { value: 'grok-2-image-1212', label: 'Grok 2 Image' }\n                ]\n            },\n            {\n                name: 'theme',\n                type: 'enum',\n                description: 'Theme',\n                required: false,\n                options: [\n                    { value: 'auto', label: 'Auto' },\n                    { value: 'light', label: 'Light' },\n                    { value: 'dark', label: 'Dark' }\n                ]\n            },\n            {\n                name: 'autoEditEnabled',\n                type: 'boolean',\n                description: 'Auto-edit (file operations only)',\n                default: false\n            },\n            {\n                name: 'vsCodeOpenEnabled',\n                type: 'boolean',\n                description: 'VS Code integration',\n                default: false\n            },\n            {\n                name: 'dangerousBypassPermission',\n                type: 'boolean',\n                description: 'Dangerously bypass permissions ⚠️',\n                default: false\n            },\n            {\n                name: 'virtualScrollingEnabled',\n                type: 'boolean',\n                description: 'Virtual scrolling',\n                default: true\n            }\n        ],\n        exec: async (args) => {\n            // Load current settings\n            const { SettingsManager } = await import('../utils/settings-manager');\n            const settingsManager = SettingsManager.getInstance();\n            const { settings } = settingsManager.loadSettings();\n            \n            // Merge with provided arguments\n            const updatedSettings = {\n                ...settings,\n                ...args\n            };\n            \n            // Update store\n            if (args.model !== undefined) actions.setModel(args.model);\n            if (args.theme !== undefined) actions.setTheme(args.theme);\n            if (args.autoEditEnabled !== undefined) actions.setAutoEdit(args.autoEditEnabled);\n            if (args.vsCodeOpenEnabled !== undefined) actions.setVSCodeOpen(args.vsCodeOpenEnabled);\n            if (args.dangerousBypassPermission !== undefined) actions.setDangerousBypassPermission(args.dangerousBypassPermission);\n            if (args.virtualScrollingEnabled !== undefined) actions.setVirtualScrolling(args.virtualScrollingEnabled);\n            \n            // Save to settings.json\n            if (settings.apiKey) {\n                settingsManager.saveSettings({\n                    ...settings,\n                    ...updatedSettings\n                } as any);\n                console.log('Settings updated successfully');\n            } else {\n                console.log('Settings updated (not saved - API key required)');\n            }\n        }\n    });\n    \n    // Help command\n    registerCommand({\n        name: 'help',\n        description: 'Show available commands',\n        category: 'System',\n        exec: () => {\n            // Check if we're in command palette and replace it with help\n            const currentStage = actions.getCurrentStage();\n            if (currentStage.type === StageType.COMMAND_PALETTE) {\n                actions.replaceStage({ id: 'help', type: StageType.HELP });\n            } else {\n                actions.pushStage({ id: 'help', type: StageType.HELP });\n            }\n        }\n    });\n}","import React, { useState, useEffect } from 'react';\nimport { GrokAgent } from '../../clanker/agent';\nimport { ClankerLogo } from '../components/ClankerLogo';\nimport { StageRouter } from '../stage/StageRouter';\nimport { StageType } from '../stage/types';\nimport { SettingsScreen } from '../screens/SettingsScreen';\nimport { SettingsManager, Settings, ProviderModels } from '../../utils/settings-manager';\nimport { actions } from '../../store';\nimport { registerBuiltinCommands } from '../../commands/builtin';\nimport { GrokAgent } from '../../clanker/agent';\n\ninterface AppContainerProps {\n    agent?: GrokAgent;\n    onRequestReload?: () => void;\n}\n\nexport const AppContainer: React.FC<AppContainerProps> = ({ agent: initialAgent, onRequestReload }) => {\n    const [showLogo, setShowLogo] = useState(true);\n    const [showSettings, setShowSettings] = useState(false);\n    const [agent, setAgent] = useState<GrokAgent | null>(initialAgent || null);\n    const settingsManager = SettingsManager.getInstance();\n    \n    useEffect(() => {\n        // Register built-in commands once on app startup\n        registerBuiltinCommands();\n        \n        // Load settings\n        actions.loadSettings();\n        \n        // Load tools if agent is provided\n        if (agent) {\n            agent.waitForToolsToLoad().then(() => {\n                console.log('Tools loaded successfully');\n            }).catch(error => {\n                console.error('Failed to load tools:', error);\n            });\n        }\n        \n        // Check if settings need configuration\n        if (!agent && settingsManager.needsConfiguration()) {\n            setShowSettings(true);\n            setShowLogo(false);\n        }\n    }, [agent]);\n    \n    const handleLogoComplete = () => {\n        setShowLogo(false);\n        \n        // After logo, check if we need settings\n        if (!agent) {\n            setShowSettings(true);\n        }\n    };\n    \n    const handleSettingsComplete = async (settings: Settings) => {\n        // Settings have been saved to disk by SettingsScreen\n        console.log('\\n✅ Settings saved successfully!');\n        \n        // Create the agent with proper initialization\n        try {\n            // Get the base URL from provider configuration\n            let baseURL: string | undefined;\n            if (settings.provider === 'custom') {\n                baseURL = settings.customBaseURL;\n            } else {\n                const providerConfig = ProviderModels[settings.provider || 'grok'];\n                baseURL = providerConfig.baseURL;\n            }\n            \n            // Ensure core tools are installed\n            const {CoreToolsManager} = await import('../../package-manager/core-tools');\n            const coreToolsManager = new CoreToolsManager();\n            await coreToolsManager.ensureCoreToolsInstalled();\n            \n            // Create new agent with all the proper settings\n            const newAgent = new GrokAgent({\n                apiKey: settings.apiKey,\n                baseURL,\n                model: settings.model || ProviderModels.grok.defaultModel,\n                loadDynamicTools: true\n            });\n            \n            // Wait for tools to load\n            await newAgent.waitForToolsToLoad();\n            \n            // Update the app state\n            setAgent(newAgent);\n            actions.setAgent(newAgent);\n            actions.clearMessages();\n            \n            // Update store settings\n            actions.setModel(settings.model);\n            actions.setTheme(settings.theme);\n            actions.setAutoEdit(settings.autoEditEnabled);\n            actions.setVSCodeOpen(settings.vsCodeOpenEnabled);\n            actions.setDangerousBypassPermission(settings.dangerousBypassPermission);\n            actions.updateConfirmationSettings(settings.confirmationSettings);\n            \n            // Hide settings and show logo for normal flow\n            setShowSettings(false);\n            setShowLogo(true);\n            \n            console.log('Agent initialized successfully');\n        } catch (error) {\n            console.error('Failed to initialize agent:', error);\n            // Keep showing settings on error\n        }\n    };\n    \n    const handleSettingsCancel = () => {\n        // If we have an agent, just close settings\n        if (agent) {\n            setShowSettings(false);\n        }\n        // Otherwise, we can't proceed without settings\n    };\n    \n    if (showSettings) {\n        return (\n            <SettingsScreen \n                onComplete={handleSettingsComplete}\n                onCancel={agent ? handleSettingsCancel : undefined}\n            />\n        );\n    }\n    \n    if (showLogo && agent) {\n        return <ClankerLogo agent={agent} onComplete={handleLogoComplete} />;\n    }\n    \n    if (agent) {\n        return <StageRouter agent={agent} />;\n    }\n    \n    // This shouldn't happen, but just in case\n    return <SettingsScreen onComplete={handleSettingsComplete} />;\n};","#!/usr/bin/env node\n\n// React imports removed - not needed for registry version\nimport {program} from \"commander\";\nimport * as dotenv from \"dotenv\";\nimport {GrokAgent} from \"./clanker/agent\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as os from \"os\";\nimport {ConfirmationService} from \"./utils/confirmation-service\";\nimport {setDebugMode, debug} from \"./utils/debug-logger\";\nimport {PackageManager} from \"./package-manager\";\n// Display functions no longer needed - using React components instead\n\n// Load environment variables\ndotenv.config({quiet: true});\n\n// Display functions are now handled by React components\n\n// Load API key from user settings if not in environment\nfunction loadApiKey(): string | undefined {\n    // First check environment variables - check both for backward compatibility\n    let apiKey = process.env.CLANKER_API_KEY || process.env.GROK_API_KEY;\n\n    if (!apiKey) {\n        // Try to load from user settings file\n        try {\n            const homeDir = os.homedir();\n            // Try user-settings.json first (legacy), then settings.json\n            let settingsFile = path.join(homeDir, \".clanker\", \"user-settings.json\");\n            \n            if (!fs.existsSync(settingsFile)) {\n                settingsFile = path.join(homeDir, \".clanker\", \"settings.json\");\n            }\n\n            if (fs.existsSync(settingsFile)) {\n                const settings = JSON.parse(fs.readFileSync(settingsFile, \"utf8\"));\n                apiKey = settings.apiKey;\n            }\n        } catch {\n            // Ignore errors, apiKey will remain undefined\n        }\n    }\n\n    return apiKey;\n}\n\n// Load base URL from user settings if not in environment\nfunction loadBaseURL(): string | undefined {\n    // First check environment variables - check both for backward compatibility\n    let baseURL = process.env.CLANKER_BASE_URL || process.env.GROK_BASE_URL;\n\n    if (!baseURL) {\n        // Try to load from user settings file\n        try {\n            const homeDir = os.homedir();\n            const settingsFile = path.join(homeDir, \".clanker\", \"settings.json\");\n\n            if (fs.existsSync(settingsFile)) {\n                const settings = JSON.parse(fs.readFileSync(settingsFile, \"utf8\"));\n                // Support both old baseURL and new provider system\n                if (settings.provider) {\n                    // We'll handle provider lookup when we have the full module loaded\n                    if (settings.provider === 'custom') {\n                        baseURL = settings.customBaseURL;\n                    } else {\n                        // For now, just use a default for grok\n                        baseURL = 'https://api.x.ai/v1';\n                    }\n                } else {\n                    // Fall back to old baseURL if provider not set\n                    baseURL = settings.baseURL;\n                }\n            }\n        } catch {\n            // Ignore errors, baseURL will remain undefined\n        }\n    }\n\n    return baseURL;\n}\n\n// Headless mode processing function\nasync function processPromptHeadless(\n    prompt: string,\n    apiKey: string,\n    baseURL?: string,\n    model?: string,\n    loadDynamicTools?: boolean,\n    dynamicToolsPath?: string,\n    watchTools?: boolean\n): Promise<void> {\n    try {\n        const agent = new GrokAgent({\n            apiKey,\n            baseURL,\n            model: model || process.env.GROK_MODEL || \"grok-3-latest\",\n            loadDynamicTools,\n            dynamicToolsPath,\n            watchTools\n        });\n\n        // Wait for tools to load\n        await agent.waitForToolsToLoad();\n\n        // Configure confirmation service for headless mode (auto-approve all operations)\n        const confirmationService = ConfirmationService.getInstance();\n        confirmationService.setSessionFlag(\"allOperations\", true);\n\n        debug.log(\"Processing prompt with new registry system...\\n\");\n\n        // Show loaded tools\n        const registry = agent.getRegistry();\n        const tools = registry.list();\n        debug.log(`Loaded ${tools.length} tools: ${tools.map(t => t.id).join(', ')}\\n`);\n\n        // Process the message\n        const response = await agent.chat([\n            {role: \"user\", content: prompt}\n        ], undefined, false) as string;\n\n        console.log(response);\n\n        // Show tool statistics if any tools were used\n        const stats = agent.getToolStats();\n        if (stats && Object.keys(stats).length > 0) {\n            debug.log(\"\\nTool Usage Statistics:\");\n            Object.entries(stats).forEach(([toolId, toolStats]) => {\n                if ((toolStats as { executionCount: number }).executionCount > 0) {\n                    const typedStats = toolStats as { executionCount: number; totalDuration: number };\n                    const durationInSeconds = (typedStats.totalDuration / 1000).toFixed(2);\n                    debug.log(`  - ${toolId}: ${typedStats.executionCount} calls, ${durationInSeconds}s total`);\n                }\n            });\n        }\n    } catch (error) {\n        console.error(\"❌ Error processing prompt:\", error instanceof Error ? error.message : String(error));\n        process.exit(1);\n    }\n}\n\nprogram\n    .name(\"grok-registry\")\n    .description(\n        \"Test the new dynamic tool registry system for Grok CLI\"\n    )\n    .version((() => {\n        try {\n            const packagePath = path.join(__dirname, '..', 'package.json');\n            const packageData = fs.readFileSync(packagePath, 'utf8');\n            return JSON.parse(packageData).version;\n        } catch {\n            return \"0.1.32\";\n        }\n    })())\n    .option(\"-d, --directory <dir>\", \"set working directory\", process.cwd())\n    .option(\"-k, --api-key <key>\", \"API key (or set CLANKER_API_KEY env var)\")\n    .option(\n        \"-u, --base-url <url>\",\n        \"API base URL (or set CLANKER_BASE_URL env var)\"\n    )\n    .option(\n        \"-m, --model <model>\",\n        \"AI model to use (e.g., grok-beta)\"\n    )\n    .option(\n        \"-p, --prompt <prompt>\",\n        \"process a single prompt and exit (headless mode)\"\n    )\n    .option(\n        \"--debug\",\n        \"enable debug logging\"\n    )\n    .option(\n        \"--load-dynamic-tools\",\n        \"load dynamic tools from .clanker/tools directory\"\n    )\n    .option(\n        \"--tools-path <path>\",\n        \"custom path for dynamic tools (default: .clanker/tools)\"\n    )\n    .option(\n        \"--list-tools\",\n        \"list all available tools and exit\"\n    )\n    .option(\n        \"-I, --install <tool>\",\n        \"install a tool (format: org/name or org/name@version)\"\n    )\n    .option(\n        \"-U, --uninstall <tool>\",\n        \"uninstall a tool (format: org/name)\"\n    )\n    .option(\n        \"-S, --search <query>\",\n        \"search for tools in the registry\"\n    )\n    .option(\n        \"-L, --list-installed\",\n        \"list all installed tools\"\n    )\n    .option(\n        \"--update <tool>\",\n        \"update a tool to the latest version\"\n    )\n    .option(\n        \"--clear-cache\",\n        \"clear the package manager cache\"\n    )\n    .option(\n        \"-W, --watch-tools\",\n        \"watch and reload tools from ~/.clanker/tools\"\n    )\n    .option(\n        \"--publish\",\n        \"publish your tool to the Clanker registry\"\n    )\n    .option(\n        \"--add-repo <url>\",\n        \"add a repository to search for tools\"\n    )\n    .option(\n        \"--remove-repo <url>\",\n        \"remove a repository from the search list\"\n    )\n    .option(\n        \"--list-repos\",\n        \"list all configured repositories\"\n    )\n    .action(async (options) => {\n        // Set debug mode if flag is present\n        if (options.debug) {\n            setDebugMode(true, true); // Enable file logging when debug is on\n            debug.log('Debug mode enabled');\n        }\n\n        if (options.directory) {\n            try {\n                process.chdir(options.directory);\n            } catch (error) {\n                console.error(\n                    `Error changing directory to ${options.directory}:`,\n                    error instanceof Error ? error.message : String(error)\n                );\n                process.exit(1);\n            }\n        }\n\n        try {\n            // Handle package manager commands first (they don't need API key)\n            const packageManager = new PackageManager();\n\n            if (options.install) {\n                await packageManager.install(options.install, {force: false});\n                return;\n            }\n\n            if (options.uninstall) {\n                await packageManager.uninstall(options.uninstall);\n                return;\n            }\n\n            if (options.search) {\n                await packageManager.search(options.search, {limit: 20});\n                return;\n            }\n\n            if (options.listInstalled) {\n                await packageManager.listInstalled();\n                return;\n            }\n\n            if (options.update) {\n                await packageManager.update(options.update);\n                return;\n            }\n\n            if (options.clearCache) {\n                await packageManager.clearCache();\n                return;\n            }\n            \n            // Handle publish command\n            if (options.publish) {\n                const {publishTool} = await import('./package-manager/publisher');\n                await publishTool();\n                return;\n            }\n            \n            // Handle repository management commands\n            if (options.addRepo) {\n                const {RepositoryManager} = await import('./package-manager/repository-manager');\n                const repoManager = new RepositoryManager();\n                await repoManager.addRepository(options.addRepo);\n                return;\n            }\n            \n            if (options.removeRepo) {\n                const {RepositoryManager} = await import('./package-manager/repository-manager');\n                const repoManager = new RepositoryManager();\n                await repoManager.removeRepository(options.removeRepo);\n                return;\n            }\n            \n            if (options.listRepos) {\n                const {RepositoryManager} = await import('./package-manager/repository-manager');\n                const repoManager = new RepositoryManager();\n                await repoManager.listRepositories();\n                return;\n            }\n\n            // Get API key from options, environment, or user settings\n            const apiKey = options.apiKey || loadApiKey();\n            const baseURL = options.baseUrl || loadBaseURL();\n            const model = options.model;\n\n            if (!apiKey) {\n                console.error(\n                    \"❌ Error: API key required. Set CLANKER_API_KEY environment variable, use --api-key flag, or save to ~/.clanker/user-settings.json\"\n                );\n                process.exit(1);\n            }\n\n            // Ensure core tools are installed on first run (for any mode that uses tools)\n            if (options.listTools || options.prompt || !options.publish) {\n                const {CoreToolsManager} = await import('./package-manager/core-tools');\n                const coreToolsManager = new CoreToolsManager();\n                await coreToolsManager.ensureCoreToolsInstalled();\n            }\n\n            // List tools mode\n            if (options.listTools) {\n                const agent = new GrokAgent({\n                    apiKey,\n                    baseURL,\n                    model,\n                    loadDynamicTools: options.loadDynamicTools,\n                    dynamicToolsPath: options.toolsPath,\n                    watchTools: options.watchTools\n                });\n\n                // Wait for tools to load\n                await agent.waitForToolsToLoad();\n\n                const registry = agent.getRegistry();\n                const tools = registry.list();\n\n                console.log(\"📦 Available Tools:\\n\");\n                tools.forEach(tool => {\n                    console.log(`${tool.id} - ${tool.description}`);\n                    if (tool.arguments && tool.arguments.length > 0) {\n                        console.log(\"  Arguments:\");\n                        tool.arguments.forEach(arg => {\n                            const required = arg.required ? \" (required)\" : \"\";\n                            console.log(`    - ${arg.name}: ${arg.type}${required} - ${arg.description}`);\n                        });\n                    }\n                    console.log();\n                });\n                return;\n            }\n\n            // Headless mode: process prompt and exit\n            if (options.prompt) {\n                await processPromptHeadless(\n                    options.prompt,\n                    apiKey,\n                    baseURL,\n                    model,\n                    options.loadDynamicTools,\n                    options.toolsPath,\n                    options.watchTools\n                );\n                return;\n            }\n\n            // Interactive mode: launch UI\n            const {render} = await import(\"ink\");\n            const React = await import(\"react\");\n\n            // Check if we can use raw mode\n            const isRawModeSupported = process.stdin.isTTY;\n\n            if (!isRawModeSupported) {\n                console.error(\"❌ Error: Interactive mode requires a TTY. Use --prompt flag for non-interactive usage.\");\n                process.exit(1);\n            }\n\n            // Handle SIGINT (Ctrl+C) to prevent default termination\n            // Import store actions for proper integration\n            const {actions, store} = await import(\"./store\");\n\n            process.on('SIGINT', () => {\n                // Use the store to manage exit confirmation state\n                const state = store;\n                const now = Date.now();\n\n                if (state.exitConfirmation && state.exitConfirmationTime && (now - state.exitConfirmationTime) < 3000) {\n                    // Second Ctrl+C within 3 seconds - exit\n                    process.exit(0);\n                } else {\n                    // First Ctrl+C or after timeout\n                    // Clear input when Ctrl+C is pressed\n                    if (state.inputValue.trim()) {\n                        actions.setInputValue(\"\");\n                    }\n                    actions.setExitConfirmation(true);\n                    setTimeout(() => actions.setExitConfirmation(false), 3000);\n                }\n            });\n\n            // Check if we have settings or need to show settings screen\n            const {SettingsManager, ProviderModels} = await import(\"./utils/settings-manager\");\n            const settingsManager = SettingsManager.getInstance();\n            const {settings, isValid} = settingsManager.loadSettings();\n\n            let agent: GrokAgent | undefined;\n\n            // Try to create agent if we have valid settings\n            if (isValid && settings.apiKey) {\n                try {\n                    // Get the base URL from provider configuration\n                    let configuredBaseURL: string | undefined;\n                    if (settings.provider === 'custom') {\n                        configuredBaseURL = settings.customBaseURL;\n                    } else {\n                        const providerConfig = ProviderModels[settings.provider || 'grok'];\n                        configuredBaseURL = providerConfig.baseURL;\n                    }\n\n                    agent = new GrokAgent({\n                        apiKey: settings.apiKey,\n                        baseURL: configuredBaseURL || baseURL,\n                        model: model || settings.model || ProviderModels.grok.defaultModel,\n                        loadDynamicTools: options.loadDynamicTools,\n                        dynamicToolsPath: options.toolsPath,\n                        watchTools: options.watchTools\n                    });\n                    \n                    // Wait for tools to load\n                    await agent.waitForToolsToLoad();\n                } catch (error) {\n                    console.error('Failed to create agent with saved settings:', error);\n                }\n            }\n\n            // Always render AppContainer - it will handle showing settings if needed\n            const {AppContainer} = await import(\"./ui/containers/AppContainer\");\n            const app = render(React.createElement(AppContainer, {agent}));\n\n            // Ensure we exit cleanly on unmount\n            app.waitUntilExit().then(() => {\n                process.exit(0);\n            });\n        } catch (error) {\n            console.error(\"❌ Error initializing Grok CLI:\", error instanceof Error ? error.message : String(error));\n            process.exit(1);\n        }\n    });\n\nprogram.parse();","/**\n * Main package manager for Clanker tools\n */\n\nimport { ToolInstaller } from './installer';\nimport { RegistryClient } from './registry';\nimport { PackageManagerOptions, SearchOptions } from './types';\nimport { ExperimentalToolManager } from './experimental';\n\nexport class ClankerPackageManager {\n  private installer: ToolInstaller;\n  private registry: RegistryClient;\n  private experimental: ExperimentalToolManager;\n\n  constructor(options: PackageManagerOptions = {}) {\n    this.installer = new ToolInstaller(options);\n    this.registry = new RegistryClient(options);\n    this.experimental = new ExperimentalToolManager(options);\n  }\n\n  /**\n   * Install a tool\n   */\n  async install(toolSpec: string, options?: { force?: boolean }): Promise<void> {\n    return this.installer.install(toolSpec, options);\n  }\n\n  /**\n   * Uninstall a tool\n   */\n  async uninstall(toolSpec: string): Promise<void> {\n    return this.installer.uninstall(toolSpec);\n  }\n\n  /**\n   * Search for tools\n   */\n  async search(query: string, options: SearchOptions = {}): Promise<void> {\n    try {\n      const results = await this.registry.searchTools(query);\n      \n      if (results.length === 0) {\n        console.log('No tools found matching your query.');\n        return;\n      }\n      \n      // Sort results\n      const sortedResults = [...results];\n      if (options.sortBy) {\n        sortedResults.sort((a, b) => {\n          switch (options.sortBy) {\n            case 'name':\n              return a.name.localeCompare(b.name);\n            case 'downloads':\n              return (b.downloads || 0) - (a.downloads || 0);\n            case 'stars':\n              return (b.stars || 0) - (a.stars || 0);\n            default:\n              return 0;\n          }\n        });\n      }\n      \n      // Limit results\n      const limitedResults = options.limit \n        ? sortedResults.slice(0, options.limit)\n        : sortedResults;\n      \n      console.log(`\\n🔍 Found ${results.length} tools:\\n`);\n      \n      for (const tool of limitedResults) {\n        console.log(`${tool.org}/${tool.name} (v${tool.latest})`);\n        console.log(`  ${tool.description}`);\n        if (tool.downloads || tool.stars) {\n          const stats = [];\n          if (tool.downloads) stats.push(`${tool.downloads} downloads`);\n          if (tool.stars) stats.push(`⭐ ${tool.stars}`);\n          console.log(`  ${stats.join(' · ')}`);\n        }\n        console.log();\n      }\n      \n      if (options.limit && results.length > options.limit) {\n        console.log(`... and ${results.length - options.limit} more results`);\n      }\n    } catch (error) {\n      console.error(`❌ Search failed: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n\n  /**\n   * List installed tools\n   */\n  async listInstalled(): Promise<void> {\n    try {\n      const installed = await this.installer.listInstalled();\n      \n      if (installed.length === 0) {\n        console.log('No tools installed.');\n        return;\n      }\n      \n      console.log(`\\n📦 Installed tools (${installed.length}):\\n`);\n      \n      for (const tool of installed) {\n        console.log(`${tool.org}/${tool.name}@${tool.version}`);\n        console.log(`  Installed: ${new Date(tool.installedAt).toLocaleDateString()}`);\n        console.log(`  Path: ${tool.path}`);\n        console.log();\n      }\n    } catch (error) {\n      console.error(`❌ Failed to list installed tools: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Update a tool to latest version\n   */\n  async update(toolSpec: string): Promise<void> {\n    return this.installer.update(toolSpec);\n  }\n\n  /**\n   * Clear registry cache\n   */\n  async clearCache(): Promise<void> {\n    await this.registry.clearCache();\n    console.log('✅ Cache cleared');\n  }\n  \n  /**\n   * Enable experimental mode\n   */\n  async enableExperimental(): Promise<void> {\n    await this.experimental.enable();\n    console.log('🧪 Experimental mode enabled');\n    console.log('⚠️  Warning: Experimental tools have not been fully reviewed and may be unstable');\n  }\n  \n  /**\n   * List available experimental tools\n   */\n  async listExperimental(): Promise<void> {\n    const isEnabled = await this.experimental.isEnabled();\n    if (!isEnabled) {\n      console.log('ℹ️  Experimental mode is not enabled. Use --enable-experimental to enable.');\n      return;\n    }\n    \n    try {\n      const tools = await this.experimental.listAvailable();\n      \n      if (tools.length === 0) {\n        console.log('No experimental tools available.');\n        return;\n      }\n      \n      console.log(`\\n🧪 Available experimental tools (${tools.length}):\\n`);\n      \n      // Group by source\n      const branches = tools.filter(t => t.source === 'branch');\n      const prs = tools.filter(t => t.source === 'pr');\n      \n      if (branches.length > 0) {\n        console.log('From branches:');\n        for (const tool of branches) {\n          console.log(`  ${tool.org}/${tool.name}@${tool.version}`);\n          console.log(`    Branch: ${tool.sourceRef}`);\n        }\n        console.log();\n      }\n      \n      if (prs.length > 0) {\n        console.log('From pull requests:');\n        for (const tool of prs) {\n          console.log(`  ${tool.org}/${tool.name}@pr-${tool.sourceRef}`);\n          console.log(`    PR #${tool.sourceRef}`);\n        }\n      }\n      \n      console.log('\\nℹ️  Install with: clanker --install org/tool@branch or org/tool@pr-123');\n      \n    } catch (error) {\n      console.error(`❌ Failed to list experimental tools: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Install an experimental tool\n   */\n  async installExperimental(toolSpec: string): Promise<void> {\n    const isEnabled = await this.experimental.isEnabled();\n    if (!isEnabled) {\n      console.log('ℹ️  Experimental mode is not enabled. Use --enable-experimental to enable.');\n      return;\n    }\n    \n    try {\n      await this.experimental.install(toolSpec);\n    } catch (error) {\n      console.error(`❌ Failed to install experimental tool: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n  \n  /**\n   * List installed experimental tools\n   */\n  async listInstalledExperimental(): Promise<void> {\n    try {\n      const tools = await this.experimental.listInstalled();\n      \n      if (tools.length === 0) {\n        console.log('No experimental tools installed.');\n        return;\n      }\n      \n      console.log(`\\n🧪 Installed experimental tools (${tools.length}):\\n`);\n      \n      for (const tool of tools) {\n        console.log(`${tool.org}/${tool.name}@${tool.version}`);\n        console.log(`  Source: ${tool.source === 'pr' ? `PR #${tool.sourceRef}` : `Branch ${tool.sourceRef}`}`);\n        console.log(`  Installed: ${new Date(tool.installedAt).toLocaleDateString()}`);\n        console.log();\n      }\n      \n    } catch (error) {\n      console.error(`❌ Failed to list experimental tools: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Upgrade experimental tools to stable versions\n   */\n  async upgradeExperimental(): Promise<void> {\n    try {\n      await this.experimental.upgradeToStable();\n    } catch (error) {\n      console.error(`❌ Failed to upgrade experimental tools: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n}\n\n// Export main class and types\nexport * from './types';\nexport * from './experimental';\nexport { ClankerPackageManager as PackageManager };","/**\n * Types for the Clanker tool package manager\n */\n\nexport interface ToolPackageMetadata {\n  id: string;\n  name: string;\n  description: string;\n  author: string;\n  versions: Record<string, VersionInfo>;\n  latest: string;\n  tags?: string[];\n  homepage?: string;\n  repository?: string;\n}\n\nexport interface VersionInfo {\n  date: string;\n  dependencies?: Record<string, string>;\n  minClankerVersion?: string;\n  sha256?: string;\n  size?: number;\n}\n\nexport interface InstalledTool {\n  org: string;\n  name: string;\n  version: string;\n  installedAt: string;\n  path: string;\n}\n\nexport interface ToolManifest {\n  version: string;\n  installedTools: InstalledTool[];\n  lastUpdated: string;\n}\n\nexport interface ToolRegistry {\n  version: string;\n  tools: ToolRegistryEntry[];\n  lastUpdated?: string;\n  updated?: string;\n}\n\nexport interface ToolRegistryEntry {\n  org: string;\n  name: string;\n  description: string;\n  latest?: string;\n  downloads?: number;\n  stars?: number;\n  // Additional fields from GitHub releases\n  id?: string;\n  version?: string;\n  author?: string;\n  repository?: string;\n  homepage?: string;\n  keywords?: string[];\n  created?: string;\n  updated?: string;\n}\n\nexport interface PackageManagerOptions {\n  toolsDir?: string;\n  registryUrl?: string;\n  cacheDir?: string;\n  timeout?: number;\n}\n\nexport interface InstallOptions {\n  force?: boolean;\n  skipDependencies?: boolean;\n}\n\nexport interface SearchOptions {\n  limit?: number;\n  sortBy?: 'name' | 'downloads' | 'stars' | 'updated';\n}\n\nexport type ToolIdentifier = {\n  org: string;\n  name: string;\n  version?: string;\n};\n\nexport interface DownloadProgress {\n  percent: number;\n  transferred: number;\n  total: number;\n}"],"mappings":"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","names":["config","path","init_types","fs","path","os","init_types","GrokAgent","SettingsManager","filePath","init_store","init_store","config","fs","path","fileURLToPath","__filename","builtInTools","module","fs","path","os","crypto","filePath","require","loadedModule","fileUrl","module","requireFunc","init_registry","EventEmitter","path","init_registry","fs","path","os","fs","path","init_registry","filePath","stat","fs","path","config","fs","path","crypto","init_registry","fs","path","error","fs","path","os","React","Box","React","Box","Text","init_store","React","Box","Text","MarkdownRenderer","React","Box","Text","React","Box","Text","useSnapshot","messageRegistry","executionRegistry","init_store","React","Box","Text","useSnapshot","init_store","React","Box","Text","useSnapshot","init_store","React","useState","useEffect","Box","Text","useStdout","useSnapshot","init_store","dots","React","useState","useEffect","useMemo","Box","Text","useSnapshot","init_store","React","Box","Text","useSnapshot","init_store","useCallback","useSnapshot","init_store","messageRegistry","executionRegistry","exec","fs","useCallback","useEffect","useSnapshot","messageRegistry","init_store","useState","useCallback","useSnapshot","messageRegistry","init_store","useCallback","useSnapshot","messageRegistry","init_store","useSnapshot","useCallback","init_store","messageRegistry","executionRegistry","useEffect","useCallback","init_store","init_types","useEffect","useRef","useSnapshot","init_store","init_store","init_store","messageRegistry","executionRegistry","React","useCallback","useRef","Box","useInput","useSnapshot","messageRegistry","executionRegistry","init_store","init_types","React","useState","useEffect","Box","Text","useInput","React","useState","Box","Text","useFocus","useInput","React","useState","Box","Text","useInput","React","useState","useEffect","Box","Text","useFocus","useInput","React","Box","Text","useFocus","useInput","React","useState","useEffect","useCallback","Box","Text","useInput","React","useEffect","React","useEffect","React","useEffect","React","useEffect","React","useState","useEffect","Box","React","Box","React","React","React","Box","Text","React","Box","init_registry","React","useMemo","Box","Text","useSnapshot","init_registry","init_store","init_types","React","useState","useEffect","Box","Text","React","Box","Text","useInput","init_store","React","useState","Box","Text","useInput","React","init_store","React","init_store","React","Box","Text","init_store","React","useCallback","Box","useInput","useSnapshot","init_store","init_types","SettingsManager","init_registry","init_store","init_types","React","useState","useEffect","init_store","CoreToolsManager","fs","path","os","init_registry","publishTool","RepositoryManager","CoreToolsManager","agent","React","actions","store","SettingsManager","ProviderModels","AppContainer"]}