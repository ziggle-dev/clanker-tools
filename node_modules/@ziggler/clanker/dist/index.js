#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/tsup/assets/esm_shims.js
import path from "path";
import { fileURLToPath } from "url";
var getFilename, getDirname, __dirname;
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
    getFilename = () => fileURLToPath(import.meta.url);
    getDirname = () => path.dirname(getFilename());
    __dirname = /* @__PURE__ */ getDirname();
  }
});

// src/clanker/client.ts
import OpenAI from "openai";
var GrokClient;
var init_client = __esm({
  "src/clanker/client.ts"() {
    init_esm_shims();
    GrokClient = class {
      constructor(apiKey, model, baseURL) {
        this.currentModel = "grok-3-latest";
        this.client = new OpenAI({
          apiKey,
          baseURL: baseURL || process.env.GROK_BASE_URL || "https://api.x.ai/v1",
          timeout: 36e4
        });
        if (model) {
          this.currentModel = model;
        }
      }
      setModel(model) {
        this.currentModel = model;
      }
      getCurrentModel() {
        return this.currentModel;
      }
      async chat(messages, tools, model, searchOptions) {
        try {
          const requestPayload = {
            model: model || this.currentModel,
            messages,
            temperature: 0.7,
            max_tokens: 4e3
          };
          if (tools && tools.length > 0) {
            requestPayload.tools = tools;
            requestPayload.tool_choice = "auto";
          }
          if (searchOptions?.search_parameters) {
            requestPayload.search_parameters = searchOptions.search_parameters;
          }
          const response = await this.client.chat.completions.create(
            requestPayload
          );
          return response;
        } catch (error) {
          throw new Error(`Grok API error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      async *chatStream(messages, tools, model, searchOptions) {
        try {
          const requestPayload = {
            model: model || this.currentModel,
            messages,
            temperature: 0.7,
            max_tokens: 4e3,
            stream: true
          };
          if (tools && tools.length > 0) {
            requestPayload.tools = tools;
            requestPayload.tool_choice = "auto";
          }
          if (searchOptions?.search_parameters) {
            requestPayload.search_parameters = searchOptions.search_parameters;
          }
          const stream = await this.client.chat.completions.create(
            requestPayload
          );
          let firstChunk = true;
          for await (const chunk of stream) {
            if (firstChunk) {
              firstChunk = false;
            }
            yield chunk;
          }
        } catch (error) {
          throw new Error(`Grok API error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      async search(query, searchParameters) {
        const searchMessage = {
          role: "user",
          content: query
        };
        const searchOptions = {
          search_parameters: searchParameters || { mode: "on" }
        };
        return this.chat([searchMessage], [], void 0, searchOptions);
      }
    };
  }
});

// src/registry/types.ts
var init_types = __esm({
  "src/registry/types.ts"() {
    init_esm_shims();
  }
});

// src/registry/validation.ts
function validateArguments(specs, args) {
  const errors = [];
  for (const spec of specs) {
    const value = args[spec.name];
    if (spec.required && (value === void 0 || value === null)) {
      errors.push({
        field: spec.name,
        message: `Required argument '${spec.name}' is missing`,
        expected: spec.type
      });
      continue;
    }
    if (value === void 0 || value === null) {
      continue;
    }
    const typeError = validateType(value, spec.type, spec.name);
    if (typeError) {
      errors.push(typeError);
      continue;
    }
    if (spec.enum && !spec.enum.includes(value)) {
      errors.push({
        field: spec.name,
        message: `Value must be one of: ${spec.enum.join(", ")}`,
        expected: spec.enum,
        received: value
      });
    }
    if (spec.validate) {
      const result = spec.validate(value);
      if (typeof result === "string") {
        errors.push({
          field: spec.name,
          message: result,
          received: value
        });
      } else if (result === false) {
        errors.push({
          field: spec.name,
          message: `Validation failed for '${spec.name}'`,
          received: value
        });
      }
    }
  }
  const knownArgs = new Set(specs.map((s) => s.name));
  for (const key of Object.keys(args)) {
    if (!knownArgs.has(key)) {
      errors.push({
        field: key,
        message: `Unknown argument '${key}'`
      });
    }
  }
  return {
    valid: errors.length === 0,
    errors: errors.length > 0 ? errors : void 0
  };
}
function validateType(value, expectedType, fieldName) {
  const actualType = getActualType(value);
  if (expectedType === "any") {
    return null;
  }
  if (actualType !== expectedType) {
    if (expectedType === "number" && actualType === "string" && !isNaN(Number(value))) {
      return null;
    }
    return {
      field: fieldName,
      message: `Expected ${expectedType} but got ${actualType}`,
      expected: expectedType,
      received: actualType
    };
  }
  return null;
}
function getActualType(value) {
  if (value === null || value === void 0) {
    return "any";
  }
  if (Array.isArray(value)) {
    return "array";
  }
  const type = typeof value;
  switch (type) {
    case "string":
    case "number":
    case "boolean":
      return type;
    case "object":
      return "object";
    default:
      return "any";
  }
}
var init_validation = __esm({
  "src/registry/validation.ts"() {
    init_esm_shims();
  }
});

// src/registry/composition.ts
function createComposedTool(pattern, tools, config2) {
  const toolIds = tools.map((t) => t.id);
  const name = `${pattern}_${toolIds.join("_")}`;
  const description = `${pattern} composition of: ${toolIds.join(", ")}`;
  let executor;
  switch (pattern) {
    case "pipeline":
      executor = createPipelineExecutor(tools);
      break;
    case "parallel":
      executor = createParallelExecutor(tools);
      break;
    case "conditional":
      executor = createConditionalExecutor(tools, config2);
      break;
    case "map":
      executor = createMapExecutor(tools[0], config2);
      break;
    case "reduce":
      executor = createReduceExecutor(tools[0], config2);
      break;
    default:
      throw new Error(`Unknown composition pattern: ${pattern}`);
  }
  const composedTool = {
    id: name,
    name,
    description,
    category: "composition" /* Composition */,
    composable: true,
    pattern,
    tools: toolIds,
    config: config2,
    execute: executor,
    // Inherit capabilities from all tools
    capabilities: Array.from(new Set(
      tools.flatMap((t) => t.capabilities || [])
    ))
  };
  return composedTool;
}
function createPipelineExecutor(tools) {
  return async (args, context) => {
    let currentInput = args;
    let lastResult = null;
    for (const tool of tools) {
      const result = await context.registry.execute(tool.id, currentInput);
      if (!result.success) {
        return result;
      }
      currentInput = result.data || result.output || {};
      lastResult = result;
    }
    return lastResult || { success: true };
  };
}
function createParallelExecutor(tools) {
  return async (args, context) => {
    const promises = tools.map(
      (tool) => context.registry.execute(tool.id, args)
    );
    const results = await Promise.all(promises);
    const failures = results.filter((r) => !r.success);
    if (failures.length > 0) {
      return {
        success: false,
        error: `${failures.length} tools failed: ${failures.map((f) => f.error).join(", ")}`
      };
    }
    return {
      success: true,
      data: results.map((r) => r.data || r.output)
    };
  };
}
function createConditionalExecutor(tools, config2) {
  const { condition, branches } = config2;
  return async (args, context) => {
    let branchKey;
    if (typeof condition === "function") {
      branchKey = await condition(args, context);
    } else {
      branchKey = args[condition] ? "true" : "false";
    }
    const toolIndex = branches[branchKey];
    if (toolIndex === void 0 || toolIndex >= tools.length) {
      return {
        success: false,
        error: `No tool defined for branch: ${branchKey}`
      };
    }
    const tool = tools[toolIndex];
    return context.registry.execute(tool.id, args);
  };
}
function createMapExecutor(tool, config2 = {}) {
  const concurrency = config2.concurrency || 1;
  const continueOnError = config2.continueOnError || false;
  return async (args, context) => {
    const { items, ...otherArgs } = args;
    if (!Array.isArray(items)) {
      return {
        success: false,
        error: 'Map requires "items" array in arguments'
      };
    }
    const results = [];
    const errors = [];
    if (concurrency === 1) {
      for (const item of items) {
        const itemArgs = { ...otherArgs, item };
        const result = await context.registry.execute(tool.id, itemArgs);
        if (!result.success) {
          if (!continueOnError) {
            return result;
          }
          errors.push({ item, error: result.error });
        } else {
          results.push(result.data || result.output);
        }
      }
    } else {
      const chunks = [];
      for (let i = 0; i < items.length; i += concurrency) {
        chunks.push(items.slice(i, i + concurrency));
      }
      for (const chunk of chunks) {
        const promises = chunk.map((item) => {
          const itemArgs = { ...otherArgs, item };
          return context.registry.execute(tool.id, itemArgs);
        });
        const chunkResults = await Promise.all(promises);
        chunkResults.forEach((result, index) => {
          if (!result.success) {
            if (!continueOnError) {
              return result;
            }
            errors.push({ item: chunk[index], error: result.error });
          } else {
            results.push(result.data || result.output);
          }
        });
      }
    }
    return {
      success: errors.length === 0 || continueOnError,
      data: results,
      error: errors.length > 0 ? `${errors.length} items failed` : void 0
    };
  };
}
function createReduceExecutor(tool, config2) {
  const { reducer, initialValue } = config2;
  return async (args, context) => {
    const { items, ...otherArgs } = args;
    if (!Array.isArray(items)) {
      return {
        success: false,
        error: 'Reduce requires "items" array in arguments'
      };
    }
    let accumulator = initialValue;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemArgs = { ...otherArgs, item, accumulator, index: i };
      const result = await context.registry.execute(tool.id, itemArgs);
      if (!result.success) {
        return result;
      }
      if (typeof reducer === "function") {
        accumulator = await reducer(accumulator, result.data || result.output, i);
      } else {
        accumulator = result.data || result.output;
      }
    }
    return {
      success: true,
      data: accumulator
    };
  };
}
var init_composition = __esm({
  "src/registry/composition.ts"() {
    init_esm_shims();
    init_types();
  }
});

// src/utils/debug-logger.ts
import * as fs from "fs";
import * as path2 from "path";
import * as os from "os";
function setDebugMode(enabled, fileLogging = false) {
  debugEnabled = enabled;
  logToFile = fileLogging && enabled;
  if (logToFile && !logStream) {
    initializeFileLogging();
  } else if (!logToFile && logStream) {
    closeFileLogging();
  }
}
function initializeFileLogging() {
  try {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const logDir = path2.join(os.homedir(), ".clanker", "debug", "logs");
    fs.mkdirSync(logDir, { recursive: true });
    logFilePath = path2.join(logDir, `debug_${timestamp}.log`);
    logStream = fs.createWriteStream(logFilePath, { flags: "a" });
    logToStream(`=== Debug log started at ${(/* @__PURE__ */ new Date()).toISOString()} ===
`);
    logToStream(`Log file: ${logFilePath}
`);
    logToStream(`Process: ${process.argv.join(" ")}
`);
    logToStream(`Working directory: ${process.cwd()}
`);
    logToStream(`===========================================

`);
    console.log(`[DEBUG] Logging to file: ${logFilePath}`);
  } catch (error) {
    console.error("[DEBUG] Failed to initialize file logging:", error);
    logToFile = false;
  }
}
function closeFileLogging() {
  if (logStream) {
    logToStream(`
=== Debug log ended at ${(/* @__PURE__ */ new Date()).toISOString()} ===
`);
    logStream.end();
    logStream = null;
  }
}
function logToStream(message) {
  if (logStream) {
    logStream.write(message);
  }
}
function formatArgs(args) {
  return args.map((arg) => {
    if (typeof arg === "object") {
      try {
        return JSON.stringify(arg, null, 2);
      } catch {
        return String(arg);
      }
    }
    return String(arg);
  }).join(" ");
}
var debugEnabled, logToFile, logStream, logFilePath, debug;
var init_debug_logger = __esm({
  "src/utils/debug-logger.ts"() {
    init_esm_shims();
    debugEnabled = false;
    logToFile = false;
    logStream = null;
    logFilePath = null;
    debug = {
      log: (...args) => {
        if (debugEnabled) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const message = formatArgs(args);
          console.log("[DEBUG]", ...args);
          if (logToFile && logStream) {
            logToStream(`[${timestamp}] [LOG] ${message}
`);
          }
        }
      },
      error: (...args) => {
        if (debugEnabled) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const message = formatArgs(args);
          console.error("[DEBUG ERROR]", ...args);
          if (logToFile && logStream) {
            logToStream(`[${timestamp}] [ERROR] ${message}
`);
          }
        }
      },
      warn: (...args) => {
        if (debugEnabled) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const message = formatArgs(args);
          console.warn("[DEBUG WARN]", ...args);
          if (logToFile && logStream) {
            logToStream(`[${timestamp}] [WARN] ${message}
`);
          }
        }
      },
      info: (...args) => {
        if (debugEnabled) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const message = formatArgs(args);
          console.info("[DEBUG INFO]", ...args);
          if (logToFile && logStream) {
            logToStream(`[${timestamp}] [INFO] ${message}
`);
          }
        }
      }
    };
    process.on("exit", closeFileLogging);
    process.on("SIGINT", () => {
      closeFileLogging();
      process.exit();
    });
    process.on("SIGTERM", () => {
      closeFileLogging();
      process.exit();
    });
  }
});

// src/ui/stage/types.ts
var init_types2 = __esm({
  "src/ui/stage/types.ts"() {
    init_esm_shims();
  }
});

// src/utils/settings-manager.ts
var settings_manager_exports = {};
__export(settings_manager_exports, {
  ProviderModels: () => ProviderModels,
  SettingsManager: () => SettingsManager,
  SettingsSchema: () => SettingsSchema
});
import * as fs2 from "fs";
import * as path3 from "path";
import * as os2 from "os";
import { z } from "zod";
var ProviderModels, SettingsSchema, SettingsManager;
var init_settings_manager = __esm({
  "src/utils/settings-manager.ts"() {
    init_esm_shims();
    ProviderModels = {
      grok: {
        name: "Grok",
        baseURL: "https://api.x.ai/v1",
        models: [
          { value: "grok-4-0709", label: "Grok 4" },
          { value: "grok-3", label: "Grok 3" },
          { value: "grok-3-mini", label: "Grok 3 Mini" },
          { value: "grok-3-fast", label: "Grok 3 Fast" },
          { value: "grok-3-mini-fast", label: "Grok 3 Mini Fast" },
          { value: "grok-2-vision-1212", label: "Grok 2 Vision" },
          { value: "grok-2-image-1212", label: "Grok 2 Image" }
        ],
        defaultModel: "grok-3"
      },
      openai: {
        name: "OpenAI",
        baseURL: "https://api.openai.com/v1",
        models: [
          { value: "gpt-4", label: "GPT-4" },
          { value: "gpt-4-turbo", label: "GPT-4 Turbo" },
          { value: "gpt-3.5-turbo", label: "GPT-3.5 Turbo" }
        ],
        defaultModel: "gpt-4-turbo"
      },
      custom: {
        name: "Custom",
        baseURL: "",
        models: [],
        defaultModel: ""
      }
    };
    SettingsSchema = z.object({
      apiKey: z.string().min(1, "API key is required"),
      provider: z.enum(["grok", "openai", "custom"]).default("grok"),
      customBaseURL: z.string().url().optional(),
      model: z.string().default(ProviderModels.grok.defaultModel),
      theme: z.enum(["light", "dark", "auto"]).default("auto"),
      autoEditEnabled: z.boolean().default(false),
      vsCodeOpenEnabled: z.boolean().default(false),
      dangerousBypassPermission: z.boolean().default(false),
      virtualScrollingEnabled: z.boolean().default(true),
      confirmationSettings: z.object({
        alwaysEdit: z.boolean().default(false),
        alwaysBash: z.boolean().default(false),
        alwaysSearch: z.boolean().default(false)
      }).default({}),
      // Add version to track schema changes
      version: z.number().default(1)
    });
    SettingsManager = class _SettingsManager {
      constructor() {
        this.currentVersion = 2;
        this.settingsDir = path3.join(os2.homedir(), ".clanker");
        this.settingsPath = path3.join(this.settingsDir, "settings.json");
      }
      static getInstance() {
        if (!_SettingsManager.instance) {
          _SettingsManager.instance = new _SettingsManager();
        }
        return _SettingsManager.instance;
      }
      /**
       * Ensure the settings directory exists
       */
      ensureSettingsDir() {
        if (!fs2.existsSync(this.settingsDir)) {
          fs2.mkdirSync(this.settingsDir, { recursive: true });
        }
      }
      /**
       * Load settings from file
       */
      loadSettings() {
        try {
          this.ensureSettingsDir();
          if (!fs2.existsSync(this.settingsPath)) {
            return { settings: {}, isValid: false, errors: null };
          }
          const fileContent = fs2.readFileSync(this.settingsPath, "utf-8");
          const rawSettings = JSON.parse(fileContent);
          const result = SettingsSchema.safeParse(rawSettings);
          if (result.success) {
            return { settings: result.data, isValid: true, errors: null };
          } else {
            return { settings: rawSettings, isValid: false, errors: result.error };
          }
        } catch (error) {
          console.error("Failed to load settings:", error);
          return { settings: {}, isValid: false, errors: null };
        }
      }
      /**
       * Save settings to file
       */
      saveSettings(settings) {
        try {
          this.ensureSettingsDir();
          const settingsWithVersion = { ...settings, version: this.currentVersion };
          fs2.writeFileSync(
            this.settingsPath,
            JSON.stringify(settingsWithVersion, null, 2),
            "utf-8"
          );
        } catch (error) {
          console.error("Failed to save settings:", error);
          throw error;
        }
      }
      /**
       * Check if settings need to be configured
       * Returns true if settings are missing, invalid, or have new fields
       */
      needsConfiguration() {
        const { isValid, settings } = this.loadSettings();
        if (!isValid) return true;
        const requiredFields = ["apiKey"];
        for (const field of requiredFields) {
          if (!settings[field]) {
            return true;
          }
        }
        if (!settings.version || settings.version < this.currentVersion) {
          return true;
        }
        return false;
      }
      /**
       * Get fields that need configuration
       */
      getMissingFields() {
        const { settings } = this.loadSettings();
        const schema = SettingsSchema.shape;
        const missingFields = [];
        for (const [key, value] of Object.entries(schema)) {
          if (key === "version") continue;
          if (!value.isOptional() && !settings[key]) {
            missingFields.push(key);
          }
        }
        return missingFields;
      }
      /**
       * Validate a single field
       */
      validateField(field, value) {
        try {
          const fieldSchema = SettingsSchema.shape[field];
          fieldSchema.parse(value);
          return void 0;
        } catch (error) {
          if (error instanceof z.ZodError) {
            return error.errors[0]?.message || "Invalid value";
          }
          return "Invalid value";
        }
      }
    };
  }
});

// src/store/store.ts
import { proxy } from "valtio";
import * as crypto from "crypto";
var store, actions, fileTrackerActions;
var init_store = __esm({
  "src/store/store.ts"() {
    init_esm_shims();
    init_debug_logger();
    init_types2();
    store = proxy({
      // Agent slice
      agent: null,
      isInitializing: false,
      initError: null,
      // Messages slice
      messages: [],
      messageCount: 0,
      // Executions slice
      executions: /* @__PURE__ */ new Map(),
      activeExecutions: [],
      // File tracker slice
      trackedFiles: /* @__PURE__ */ new Map(),
      // UI slice
      isProcessing: false,
      isStreaming: false,
      tokenCount: 0,
      inputTokenCount: 0,
      outputTokenCount: 0,
      processingTime: 0,
      inputValue: "",
      cursorPosition: 0,
      inputHistory: [],
      historyIndex: -1,
      showHelp: false,
      showModelSelector: false,
      exitConfirmation: false,
      exitConfirmationTime: 0,
      showCommandSuggestions: false,
      selectedCommandIndex: 0,
      commandSuggestions: [],
      showModelSelection: false,
      selectedModelIndex: 0,
      availableModels: ["grok-4-latest", "grok-3-latest", "grok-4", "grok-3", "grok-beta"],
      showCommandForm: false,
      // Stage management
      stageStack: [{ id: "main", type: "chat" /* CHAT */ }],
      // Settings slice
      autoEditEnabled: false,
      vsCodeOpenEnabled: false,
      dangerousBypassPermission: false,
      virtualScrollingEnabled: true,
      confirmationSettings: {
        alwaysEdit: false,
        alwaysBash: false,
        alwaysSearch: false
      },
      theme: "auto",
      model: "grok-beta",
      // Confirmation slice
      confirmationOptions: null,
      confirmationResolver: null
    });
    actions = {
      // Agent actions
      setAgent(agent) {
        store.agent = agent;
        store.initError = null;
      },
      async initializeAgent(options) {
        store.isInitializing = true;
        store.initError = null;
        try {
          const { GrokAgent: GrokAgent2 } = await Promise.resolve().then(() => (init_agent(), agent_exports));
          const agent = new GrokAgent2(options);
          store.agent = agent;
          store.isInitializing = false;
        } catch (error) {
          store.isInitializing = false;
          store.initError = error instanceof Error ? error.message : "Unknown error";
          throw error;
        }
      },
      clearAgent() {
        store.agent = null;
        store.initError = null;
      },
      setInitializing(isInitializing) {
        store.isInitializing = isInitializing;
      },
      setInitError(error) {
        store.initError = error;
      },
      // Message actions
      addMessage(message) {
        const id = `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const newMessage = {
          ...message,
          id,
          timestamp: /* @__PURE__ */ new Date()
        };
        store.messages.push(newMessage);
        store.messageCount = store.messages.length;
      },
      updateMessage(id, updates) {
        const index = store.messages.findIndex((msg) => msg.id === id);
        if (index !== -1) {
          Object.assign(store.messages[index], updates);
        }
      },
      clearMessages() {
        store.messages = [];
        store.messageCount = 0;
      },
      setMessages(messages) {
        store.messages = messages;
        store.messageCount = messages.length;
      },
      startStreaming(messageId) {
        const message = store.messages.find((msg) => msg.id === messageId);
        if (message) {
          if (!message.metadata) message.metadata = {};
          message.metadata.isStreaming = true;
        }
      },
      appendToMessage(messageId, content) {
        const message = store.messages.find((msg) => msg.id === messageId);
        if (message) {
          message.content += content;
        }
      },
      finishStreaming(messageId, metadata) {
        const message = store.messages.find((msg) => msg.id === messageId);
        if (message) {
          if (!message.metadata) message.metadata = {};
          Object.assign(message.metadata, metadata);
          message.metadata.isStreaming = false;
        }
      },
      addToolCalls(messageId, toolCalls) {
        const message = store.messages.find((msg) => msg.id === messageId);
        if (message) {
          message.toolCalls = toolCalls;
        }
      },
      // Execution actions
      addExecution(execution) {
        const id = `exec-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const newExecution = {
          ...execution,
          id,
          status: "executing",
          startTime: /* @__PURE__ */ new Date()
        };
        store.executions.set(id, newExecution);
        store.activeExecutions.push(id);
        return id;
      },
      updateExecution(id, updates) {
        const execution = store.executions.get(id);
        if (execution) {
          Object.assign(execution, updates);
          store.executions.set(id, execution);
        }
      },
      completeExecution(id, result) {
        const execution = store.executions.get(id);
        if (execution) {
          execution.status = "completed";
          execution.result = result;
          execution.endTime = /* @__PURE__ */ new Date();
          store.executions.set(id, execution);
          store.activeExecutions = store.activeExecutions.filter((execId) => execId !== id);
        }
      },
      failExecution(id, error) {
        const execution = store.executions.get(id);
        if (execution) {
          execution.status = "failed";
          execution.result = {
            success: false,
            error
          };
          execution.endTime = /* @__PURE__ */ new Date();
          store.executions.set(id, execution);
          store.activeExecutions = store.activeExecutions.filter((execId) => execId !== id);
        }
      },
      getExecution(id) {
        return store.executions.get(id);
      },
      clearExecutions() {
        store.executions = /* @__PURE__ */ new Map();
        store.activeExecutions = [];
      },
      // UI actions
      setProcessing(isProcessing) {
        store.isProcessing = isProcessing;
      },
      setStreaming(isStreaming) {
        store.isStreaming = isStreaming;
      },
      updateTokenCount(count) {
        store.tokenCount = count;
        store.outputTokenCount = count;
      },
      updateInputTokenCount(count) {
        store.inputTokenCount = count;
      },
      updateOutputTokenCount(count) {
        store.outputTokenCount = count;
        store.tokenCount = count;
      },
      updateProcessingTime(time) {
        store.processingTime = time;
      },
      setInputValue(value) {
        store.inputValue = value;
      },
      getInputValue() {
        return store.inputValue;
      },
      setCursorPosition(position) {
        store.cursorPosition = position;
      },
      addToHistory(input) {
        if (!input.trim()) return;
        const filtered = store.inputHistory.filter((item) => item !== input);
        const newHistory = [...filtered, input];
        store.inputHistory = newHistory.length > 100 ? newHistory.slice(-100) : newHistory;
        store.historyIndex = -1;
      },
      navigateHistory(direction) {
        if (direction === "up") {
          const newIndex = store.historyIndex === -1 ? store.inputHistory.length - 1 : Math.max(0, store.historyIndex - 1);
          if (newIndex >= 0 && newIndex < store.inputHistory.length) {
            store.historyIndex = newIndex;
            store.inputValue = store.inputHistory[newIndex];
            store.cursorPosition = store.inputHistory[newIndex].length;
          }
        } else {
          if (store.historyIndex === -1) return;
          const newIndex = store.historyIndex + 1;
          if (newIndex >= store.inputHistory.length) {
            store.historyIndex = -1;
            store.inputValue = "";
            store.cursorPosition = 0;
          } else {
            store.historyIndex = newIndex;
            store.inputValue = store.inputHistory[newIndex];
            store.cursorPosition = store.inputHistory[newIndex].length;
          }
        }
      },
      toggleHelp() {
        store.showHelp = !store.showHelp;
      },
      toggleModelSelector() {
        store.showModelSelector = !store.showModelSelector;
      },
      setExitConfirmation(show) {
        store.exitConfirmation = show;
        if (show) {
          store.exitConfirmationTime = Date.now();
        }
      },
      // Settings actions
      setAutoEdit(enabled) {
        store.autoEditEnabled = enabled;
        actions.saveSettings();
      },
      setVSCodeOpen(enabled) {
        store.vsCodeOpenEnabled = enabled;
        actions.saveSettings();
      },
      setDangerousBypassPermission(enabled) {
        store.dangerousBypassPermission = enabled;
        actions.saveSettings();
      },
      setVirtualScrolling(enabled) {
        store.virtualScrollingEnabled = enabled;
        actions.saveSettings();
      },
      updateConfirmationSettings(settings) {
        Object.assign(store.confirmationSettings, settings);
        actions.saveSettings();
      },
      setTheme(theme) {
        store.theme = theme;
        actions.saveSettings();
      },
      setModel(model) {
        store.model = model;
        actions.saveSettings();
      },
      // Command form actions
      setShowCommandForm(show) {
        store.showCommandForm = show;
      },
      // UI actions
      setShowHelp(show) {
        store.showHelp = show;
      },
      async loadSettings() {
        try {
          const { SettingsManager: SettingsManager2 } = await Promise.resolve().then(() => (init_settings_manager(), settings_manager_exports));
          const settingsManager = SettingsManager2.getInstance();
          const { settings, isValid } = settingsManager.loadSettings();
          if (isValid && settings) {
            if (settings.model) store.model = settings.model;
            if (settings.theme) store.theme = settings.theme;
            if (settings.autoEditEnabled !== void 0) store.autoEditEnabled = settings.autoEditEnabled;
            if (settings.vsCodeOpenEnabled !== void 0) store.vsCodeOpenEnabled = settings.vsCodeOpenEnabled;
            if (settings.dangerousBypassPermission !== void 0) store.dangerousBypassPermission = settings.dangerousBypassPermission;
            if (settings.virtualScrollingEnabled !== void 0) store.virtualScrollingEnabled = settings.virtualScrollingEnabled;
            if (settings.confirmationSettings) {
              Object.assign(store.confirmationSettings, settings.confirmationSettings);
            }
          }
        } catch (error) {
          debug.error("Failed to load settings:", error);
        }
      },
      async saveSettings() {
        try {
          const settingsToSave = {
            autoEditEnabled: store.autoEditEnabled,
            vsCodeOpenEnabled: store.vsCodeOpenEnabled,
            dangerousBypassPermission: store.dangerousBypassPermission,
            virtualScrollingEnabled: store.virtualScrollingEnabled,
            confirmationSettings: store.confirmationSettings,
            theme: store.theme,
            model: store.model
          };
        } catch (error) {
          debug.error("Failed to save settings:", error);
        }
      },
      // Confirmation actions
      requestConfirmation(options) {
        return new Promise((resolve) => {
          store.confirmationOptions = options;
          store.confirmationResolver = resolve;
        });
      },
      respondToConfirmation(result) {
        if (store.confirmationResolver) {
          store.confirmationResolver(result);
          store.confirmationOptions = null;
          store.confirmationResolver = null;
        }
      },
      cancelConfirmation() {
        if (store.confirmationResolver) {
          store.confirmationResolver({ confirmed: false });
          store.confirmationOptions = null;
          store.confirmationResolver = null;
        }
      },
      // File tracker actions
      updateFile(filePath2, content) {
        const hash = crypto.createHash("sha256").update(content).digest("hex");
        const lineCount = content.split("\n").length;
        store.trackedFiles.set(filePath2, {
          hash,
          lastRead: /* @__PURE__ */ new Date(),
          lineCount
        });
      },
      hasFile(filePath2) {
        return store.trackedFiles.has(filePath2);
      },
      getFileInfo(filePath2) {
        return store.trackedFiles.get(filePath2);
      },
      verifyFileHash(filePath2, content) {
        const fileInfo = store.trackedFiles.get(filePath2);
        if (!fileInfo) return false;
        const currentHash = crypto.createHash("sha256").update(content).digest("hex");
        return fileInfo.hash === currentHash;
      },
      clearFile(filePath2) {
        store.trackedFiles.delete(filePath2);
      },
      clearAllFiles() {
        store.trackedFiles.clear();
      },
      // Stage management actions
      getCurrentStage() {
        return store.stageStack[store.stageStack.length - 1];
      },
      pushStage(stage) {
        store.stageStack.push(stage);
      },
      popStage() {
        if (store.stageStack.length > 1) {
          store.stageStack.pop();
        }
      },
      replaceStage(stage) {
        if (store.stageStack.length > 0) {
          store.stageStack[store.stageStack.length - 1] = stage;
        }
      },
      clearStages() {
        store.stageStack = [{ id: "main", type: "chat" /* CHAT */ }];
      },
      getStageStack() {
        return store.stageStack;
      }
    };
    fileTrackerActions = {
      updateFile: actions.updateFile,
      hasFile: actions.hasFile,
      getFileInfo: actions.getFileInfo,
      verifyFileHash: actions.verifyFileHash,
      clearFile: actions.clearFile,
      clearAllFiles: actions.clearAllFiles
    };
  }
});

// src/store/index.ts
var store_exports = {};
__export(store_exports, {
  actions: () => actions,
  store: () => store
});
var init_store2 = __esm({
  "src/store/index.ts"() {
    init_esm_shims();
    init_store();
  }
});

// src/utils/confirmation-service.ts
import { EventEmitter } from "events";
var ConfirmationService;
var init_confirmation_service = __esm({
  "src/utils/confirmation-service.ts"() {
    init_esm_shims();
    init_store2();
    ConfirmationService = class _ConfirmationService extends EventEmitter {
      constructor() {
        super();
        this.skipConfirmationThisSession = false;
        this.pendingConfirmation = null;
        this.resolveConfirmation = null;
        // Session flags for different operation types
        this.sessionFlags = {
          fileOperations: false,
          bashCommands: false,
          allOperations: false,
          createFiles: false,
          editFiles: false
        };
      }
      static getInstance() {
        if (!_ConfirmationService.instance) {
          _ConfirmationService.instance = new _ConfirmationService();
        }
        return _ConfirmationService.instance;
      }
      async requestConfirmation(options, operationType = "file") {
        if (store.dangerousBypassPermission) {
          return { confirmed: true };
        }
        if (store.autoEditEnabled && (operationType === "file_edit" || operationType === "file_create")) {
          return { confirmed: true };
        }
        if (this.sessionFlags.allOperations || operationType === "file" && this.sessionFlags.fileOperations || operationType === "bash" && this.sessionFlags.bashCommands || operationType === "file_create" && this.sessionFlags.createFiles || operationType === "file_edit" && this.sessionFlags.editFiles) {
          return { confirmed: true };
        }
        this.pendingConfirmation = new Promise((resolve) => {
          this.resolveConfirmation = resolve;
        });
        setImmediate(() => {
          this.emit("confirmation-requested", options);
        });
        const result = await this.pendingConfirmation;
        if (result.dontAskAgain) {
          if (operationType === "file") {
            this.sessionFlags.fileOperations = true;
          } else if (operationType === "bash") {
            this.sessionFlags.bashCommands = true;
          } else if (operationType === "file_create") {
            this.sessionFlags.createFiles = true;
          } else if (operationType === "file_edit") {
            this.sessionFlags.editFiles = true;
          }
        }
        return result;
      }
      confirmOperation(confirmed, dontAskAgain) {
        if (this.resolveConfirmation) {
          this.resolveConfirmation({ confirmed, dontAskAgain });
          this.resolveConfirmation = null;
          this.pendingConfirmation = null;
        }
      }
      rejectOperation(feedback) {
        if (this.resolveConfirmation) {
          this.resolveConfirmation({ confirmed: false, feedback });
          this.resolveConfirmation = null;
          this.pendingConfirmation = null;
        }
      }
      isPending() {
        return this.pendingConfirmation !== null;
      }
      resetSession() {
        this.sessionFlags = {
          fileOperations: false,
          bashCommands: false,
          allOperations: false,
          createFiles: false,
          editFiles: false
        };
      }
      getSessionFlags() {
        return { ...this.sessionFlags };
      }
      setSessionFlag(flagType, value) {
        this.sessionFlags[flagType] = value;
      }
    };
  }
});

// src/registry/logger.ts
function createToolLogger(toolId, enabled = true) {
  const isInteractive = process.stdout.isTTY && !process.env.CI;
  return isInteractive ? new NullLogger() : new ConsoleLogger(`[${toolId}]`, enabled);
}
var ConsoleLogger, NullLogger;
var init_logger = __esm({
  "src/registry/logger.ts"() {
    init_esm_shims();
    ConsoleLogger = class {
      constructor(prefix = "[Tool]", enabled = true) {
        this.prefix = prefix;
        this.enabled = enabled;
      }
      debug(message, ...args) {
        if (this.enabled && process.env.DEBUG === "true") {
          console.log(`${this.prefix} DEBUG:`, message, ...args);
        }
      }
      info(message, ...args) {
        if (this.enabled) {
          console.log(`${this.prefix} INFO:`, message, ...args);
        }
      }
      warn(message, ...args) {
        if (this.enabled) {
          console.warn(`${this.prefix} WARN:`, message, ...args);
        }
      }
      error(message, ...args) {
        if (this.enabled) {
          console.error(`${this.prefix} ERROR:`, message, ...args);
        }
      }
    };
    NullLogger = class {
      debug() {
      }
      info() {
      }
      warn() {
      }
      error() {
      }
    };
  }
});

// src/registry/registry.ts
function createToolRegistry(workingDirectory) {
  return new ToolRegistryImpl(workingDirectory);
}
var ToolRegistryImpl;
var init_registry = __esm({
  "src/registry/registry.ts"() {
    init_esm_shims();
    init_validation();
    init_composition();
    init_confirmation_service();
    init_logger();
    ToolRegistryImpl = class {
      constructor(workingDirectory = process.cwd()) {
        this.tools = /* @__PURE__ */ new Map();
        this.context = {
          registry: this,
          workingDirectory,
          confirmationService: ConfirmationService.getInstance(),
          state: /* @__PURE__ */ new Map()
        };
      }
      /**
       * Register a new tool
       */
      register(tool) {
        if (this.tools.has(tool.id)) {
          throw new Error(`Tool with id '${tool.id}' already registered`);
        }
        this.tools.set(tool.id, {
          definition: tool,
          initialized: false,
          executionCount: 0,
          totalDuration: 0
        });
      }
      /**
       * Unregister a tool
       */
      async unregister(toolId) {
        const tool = this.tools.get(toolId);
        if (!tool) {
          throw new Error(`Tool '${toolId}' not found`);
        }
        if (tool.definition.cleanup && tool.initialized) {
          await tool.definition.cleanup(this.context);
        }
        this.tools.delete(toolId);
      }
      /**
       * Get a registered tool
       */
      get(toolId) {
        return this.tools.get(toolId);
      }
      /**
       * List tools with optional filter
       */
      list(filter) {
        let tools = Array.from(this.tools.values()).map((t) => t.definition);
        if (filter) {
          if (filter.category) {
            tools = tools.filter((t) => t.category === filter.category);
          }
          if (filter.capabilities && filter.capabilities.length > 0) {
            tools = tools.filter(
              (t) => t.capabilities && filter.capabilities.every((cap) => t.capabilities.includes(cap))
            );
          }
          if (filter.tags && filter.tags.length > 0) {
            tools = tools.filter(
              (t) => t.tags && filter.tags.some((tag) => t.tags.includes(tag))
            );
          }
          if (filter.composable !== void 0) {
            tools = tools.filter((t) => t.composable === filter.composable);
          }
        }
        return tools;
      }
      /**
       * Search tools by query
       */
      search(query) {
        const lowerQuery = query.toLowerCase();
        return Array.from(this.tools.values()).map((t) => t.definition).filter((tool) => {
          const searchText = [
            tool.id,
            tool.name,
            tool.description,
            ...tool.tags || []
          ].join(" ").toLowerCase();
          return searchText.includes(lowerQuery);
        });
      }
      /**
       * Execute a tool
       */
      async execute(toolId, args) {
        const registeredTool = this.tools.get(toolId);
        if (!registeredTool) {
          return {
            success: false,
            error: `Tool '${toolId}' not found`
          };
        }
        const tool = registeredTool.definition;
        const validation = this.validateArguments(toolId, args);
        if (!validation.valid) {
          return {
            success: false,
            error: `Validation failed: ${validation.errors.map((e) => e.message).join(", ")}`
          };
        }
        if (!registeredTool.initialized && tool.initialize) {
          try {
            const initContext = {
              ...this.context,
              logger: createToolLogger(toolId)
            };
            await tool.initialize(initContext);
            registeredTool.initialized = true;
          } catch (error) {
            return {
              success: false,
              error: `Failed to initialize tool: ${error instanceof Error ? error.message : String(error)}`
            };
          }
        }
        const startTime = Date.now();
        try {
          const executionContext = {
            ...this.context,
            logger: createToolLogger(toolId)
          };
          const result = await tool.execute(args, executionContext);
          const duration = Date.now() - startTime;
          registeredTool.executionCount++;
          registeredTool.lastExecuted = /* @__PURE__ */ new Date();
          registeredTool.totalDuration += duration;
          return result;
        } catch (error) {
          return {
            success: false,
            error: `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }
      /**
       * Create a composed tool
       */
      compose(pattern, toolIds, config2) {
        const tools = toolIds.map((id) => {
          const tool = this.get(id);
          if (!tool) {
            throw new Error(`Tool '${id}' not found for composition`);
          }
          return tool.definition;
        });
        return createComposedTool(pattern, tools, config2 || {});
      }
      /**
       * Validate tool arguments
       */
      validateArguments(toolId, args) {
        const tool = this.get(toolId);
        if (!tool) {
          return {
            valid: false,
            errors: [{ field: "toolId", message: `Tool '${toolId}' not found` }]
          };
        }
        return validateArguments(tool.definition.arguments || [], args);
      }
      /**
       * Get the registry context
       */
      getContext() {
        return this.context;
      }
      /**
       * Update working directory
       */
      setWorkingDirectory(dir) {
        this.context.workingDirectory = dir;
      }
      /**
       * Get tool statistics
       */
      getStats() {
        const tools = Array.from(this.tools.entries());
        const byCategory = {};
        const byCapability = {};
        tools.forEach(([_, tool]) => {
          const def = tool.definition;
          if (def.category) {
            byCategory[def.category] = (byCategory[def.category] || 0) + 1;
          }
          if (def.capabilities) {
            def.capabilities.forEach((cap) => {
              byCapability[cap] = (byCapability[cap] || 0) + 1;
            });
          }
        });
        const mostUsed = tools.map(([id, tool]) => ({ toolId: id, count: tool.executionCount })).filter((t) => t.count > 0).sort((a, b) => b.count - a.count).slice(0, 10);
        return {
          totalTools: tools.length,
          byCategory,
          byCapability,
          mostUsed
        };
      }
      /**
       * Get execution stats in the format expected by tests
       */
      getExecutionStats() {
        const stats = {};
        this.tools.forEach((tool, id) => {
          stats[id] = {
            executionCount: tool.executionCount,
            totalDuration: tool.totalDuration
          };
        });
        return stats;
      }
    };
  }
});

// src/registry/builder.ts
var init_builder = __esm({
  "src/registry/builder.ts"() {
    init_esm_shims();
  }
});

// src/registry/adapters.ts
function toolDefinitionToGrokTool(tool) {
  const properties = {};
  const required = [];
  if (tool.arguments) {
    for (const arg of tool.arguments) {
      properties[arg.name] = argumentSpecToProperty(arg);
      if (arg.required) {
        required.push(arg.name);
      }
    }
  }
  return {
    type: "function",
    function: {
      name: tool.id,
      description: generateToolDescription(tool),
      parameters: {
        type: "object",
        properties,
        required
      }
    }
  };
}
function argumentSpecToProperty(arg) {
  const property = {
    type: mapArgumentType(arg.type),
    description: arg.description
  };
  if (arg.enum) {
    property.enum = arg.enum;
  }
  if (arg.default !== void 0) {
    property.default = arg.default;
  }
  return property;
}
function mapArgumentType(type) {
  switch (type) {
    case "any":
      return "string";
    // OpenAI doesn't have 'any', use string as fallback
    default:
      return type;
  }
}
function generateToolDescription(tool) {
  const parts = [tool.description];
  if (tool.capabilities && tool.capabilities.length > 0) {
    const capabilities = tool.capabilities.map((cap) => describeCapability(cap)).filter((desc) => desc).join(", ");
    if (capabilities) {
      parts.push(`Capabilities: ${capabilities}`);
    }
  }
  if (tool.tags && tool.tags.length > 0) {
    parts.push(`Tags: ${tool.tags.join(", ")}`);
  }
  if (tool.examples && tool.examples.length > 0) {
    parts.push("\n\nExamples:");
    tool.examples.forEach((example, index) => {
      parts.push(`
Example ${index + 1}: ${example.description}`);
      parts.push(`Arguments: ${JSON.stringify(example.arguments, null, 2)}`);
      if (example.result) {
        parts.push(`Expected result: ${example.result}`);
      }
    });
  }
  return parts.join(". ");
}
function describeCapability(capability) {
  const descriptions = {
    ["file:read" /* FileRead */]: "read files",
    ["file:write" /* FileWrite */]: "write files",
    ["system:execute" /* SystemExecute */]: "execute system commands",
    ["network:access" /* NetworkAccess */]: "access network resources",
    ["user:confirmation" /* UserConfirmation */]: "request user confirmation"
  };
  return descriptions[capability] || "";
}
function generateGrokTools(registry) {
  const tools = registry.list();
  return tools.map((tool) => toolDefinitionToGrokTool(tool));
}
var init_adapters = __esm({
  "src/registry/adapters.ts"() {
    init_esm_shims();
    init_types();
    init_validation();
  }
});

// src/registry/builtin-tools.ts
var builtin_tools_exports = {};
__export(builtin_tools_exports, {
  builtInTools: () => builtInTools,
  builtInToolsMap: () => builtInToolsMap
});
var builtInTools, builtInToolsMap;
var init_builtin_tools = __esm({
  "src/registry/builtin-tools.ts"() {
    init_esm_shims();
    builtInTools = [];
    builtInToolsMap = /* @__PURE__ */ new Map();
  }
});

// src/registry/manifest-loader.ts
import * as fs3 from "fs";
import * as path4 from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
async function loadBuiltInToolsFromManifest() {
  const tools = [];
  try {
    let baseDir;
    if (typeof __dirname !== "undefined") {
      baseDir = __dirname;
    } else if (typeof import.meta.url !== "undefined") {
      const __filename2 = fileURLToPath2(import.meta.url);
      baseDir = path4.dirname(__filename2);
    } else {
      baseDir = process.cwd();
    }
    let manifestPath = path4.join(baseDir, "tool-manifest.json");
    if (!fs3.existsSync(manifestPath)) {
      manifestPath = path4.join(baseDir, "..", "..", "dist", "tool-manifest.json");
    }
    debug.log(`[ManifestLoader] Looking for manifest at: ${manifestPath}`);
    if (!fs3.existsSync(manifestPath)) {
      debug.warn("[ManifestLoader] No tool manifest found, falling back to static imports");
      const { builtInTools: builtInTools2 } = await Promise.resolve().then(() => (init_builtin_tools(), builtin_tools_exports));
      return builtInTools2;
    }
    const manifestContent = fs3.readFileSync(manifestPath, "utf-8");
    const manifest = JSON.parse(manifestContent);
    debug.log(`[ManifestLoader] Found manifest with ${manifest.tools.length} tools`);
    for (const toolInfo of manifest.tools) {
      try {
        const modulePath = path4.isAbsolute(toolInfo.module) ? toolInfo.module : path4.join(path4.dirname(manifestPath), toolInfo.module);
        debug.log(`[ManifestLoader] Loading tool ${toolInfo.id} from ${modulePath}`);
        const module2 = await import(modulePath);
        const tool = module2.default || module2;
        if (isValidTool(tool)) {
          tools.push(tool);
          debug.log(`[ManifestLoader] Successfully loaded tool: ${tool.id}`);
        } else {
          debug.warn(`[ManifestLoader] Invalid tool in ${modulePath}`);
        }
      } catch (error) {
        debug.error(`[ManifestLoader] Failed to load tool ${toolInfo.id}:`, error);
      }
    }
    debug.log(`[ManifestLoader] Loaded ${tools.length} tools from manifest`);
    return tools;
  } catch (error) {
    debug.error("[ManifestLoader] Error loading manifest:", error);
    const { builtInTools: builtInTools2 } = await Promise.resolve().then(() => (init_builtin_tools(), builtin_tools_exports));
    return builtInTools2;
  }
}
function isValidTool(obj) {
  return obj && typeof obj === "object" && typeof obj.id === "string" && typeof obj.description === "string" && typeof obj.execute === "function";
}
var init_manifest_loader = __esm({
  "src/registry/manifest-loader.ts"() {
    init_esm_shims();
    init_debug_logger();
  }
});

// src/registry/loader.ts
import * as fs4 from "fs/promises";
import * as path5 from "path";
import * as os3 from "os";
import * as crypto2 from "crypto";
import { pathToFileURL } from "url";
function shouldShareDependency(request) {
  if (request === "react" || request === "ink" || request.startsWith("ink/")) {
    return true;
  }
  if (request === "@ziggler/clanker" || request.startsWith("@ziggler/clanker/")) {
    return true;
  }
  if (request.startsWith("../../registry") || request.startsWith("../../utils/") || request.startsWith("../../ui/") || request.startsWith("../../store/")) {
    return true;
  }
  const sharedDeps = [
    "chalk",
    "fs-extra",
    "zod",
    "commander",
    "dotenv",
    "openai",
    "axios",
    "uuid",
    "prismjs",
    "immer"
  ];
  return sharedDeps.includes(request);
}
function createToolLoader(registry, options) {
  return new ToolLoader(registry, options);
}
var ToolLoader;
var init_loader = __esm({
  "src/registry/loader.ts"() {
    init_esm_shims();
    init_debug_logger();
    init_manifest_loader();
    ToolLoader = class {
      // filePath -> watcher
      constructor(registry, options = {}) {
        this.registry = registry;
        this.loadedTools = /* @__PURE__ */ new Map();
        // toolId -> {filePath, hash}
        this.watcherCleanup = [];
        this.fileWatchers = /* @__PURE__ */ new Map();
        const homeDir = os3.homedir();
        const clankDir = path5.join(homeDir, ".clanker");
        this.options = {
          directories: options.directories || [process.cwd(), clankDir],
          recursive: options.recursive ?? true,
          extensions: options.extensions || [".ts", ".tsx", ".js", ".jsx"],
          watch: options.watch ?? false,
          loadBuiltins: options.loadBuiltins ?? true
        };
        debug.log(`[ToolLoader] Configured directories:`, this.options.directories);
      }
      /**
       * Load all tools from configured directories
       */
      async loadTools() {
        if (this.options.loadBuiltins) {
          await this.loadBuiltinTools();
        }
        for (const dir of this.options.directories) {
          const toolsDir = path5.join(dir, dir.endsWith("tools") ? "" : "tools");
          debug.log(`[ToolLoader] Loading from directory: ${dir} -> ${toolsDir}`);
          await this.loadFromDirectory(toolsDir);
        }
        if (this.options.watch) {
          await this.setupWatchers();
        }
      }
      /**
       * Load built-in tools from the package
       */
      async loadBuiltinTools() {
        try {
          const tools = await loadBuiltInToolsFromManifest();
          debug.log(`[ToolLoader] Loading ${tools.length} built-in tools`);
          for (const tool of tools) {
            if (this.isValidTool(tool)) {
              this.registry.register(tool);
              const registeredTool = this.registry.get(tool.id);
              if (registeredTool) {
                registeredTool.hash = "builtin";
                registeredTool.filePath = `builtin:${tool.id}`;
              }
              this.loadedTools.set(tool.id, { path: `builtin:${tool.id}`, hash: "builtin" });
              debug.log(`[ToolLoader] Loaded built-in tool: ${tool.id}`);
            } else {
              debug.warn(`[ToolLoader] Invalid built-in tool`);
            }
          }
          debug.log(`[ToolLoader] Successfully loaded ${tools.length} built-in tools`);
        } catch (error) {
          debug.warn("[ToolLoader] Failed to load built-in tools:", error);
        }
      }
      /**
       * Load tools from a directory
       */
      async loadFromDirectory(directory) {
        if (!await this.exists(directory)) {
          debug.log(`[ToolLoader] Directory does not exist: ${directory}`);
          return;
        }
        debug.log(`[ToolLoader] Scanning directory: ${directory}`);
        try {
          await this.scanDirectory(directory, this.options.recursive);
        } catch (error) {
          debug.error(`[ToolLoader] Error scanning directory ${directory}:`, error);
        }
      }
      /**
       * Recursively scan a directory for tool files
       */
      async scanDirectory(directory, recursive) {
        let entries;
        try {
          entries = await fs4.readdir(directory, { withFileTypes: true });
        } catch (error) {
          return;
        }
        const currentLink = entries.find((entry) => entry.name === "current" && entry.isSymbolicLink());
        if (currentLink) {
          const currentPath = path5.join(directory, "current", "index.js");
          if (await this.exists(currentPath)) {
            debug.log(`[ToolLoader] Found package-managed tool at ${currentPath}`);
            await this.loadToolFile(currentPath);
            return;
          }
        }
        const files = entries.filter((entry) => entry.isFile() && this.isToolFile(entry.name)).map((entry) => path5.join(directory, entry.name));
        debug.log(`[ToolLoader] Found ${files.length} tool files in ${directory}`);
        for (const file of files) {
          await this.loadToolFile(file);
        }
        if (!recursive) return;
        const subdirs = entries.filter((entry) => entry.isDirectory()).map((entry) => path5.join(directory, entry.name));
        for (const subdir of subdirs) {
          await this.scanDirectory(subdir, true);
        }
      }
      /**
       * Load a single tool file
       */
      async loadToolFile(filePath2) {
        try {
          debug.log(`[ToolLoader] Attempting to load: ${filePath2}`);
          const fileHash = await this.computeFileHash(filePath2);
          debug.log(`[ToolLoader] File hash for ${filePath2}: ${fileHash.substring(0, 8)}...`);
          const existingEntry = Array.from(this.loadedTools.entries()).find(([_, info]) => info.path === filePath2);
          if (existingEntry && existingEntry[1].hash === fileHash) {
            debug.log(`[ToolLoader] Tool already loaded with same version: ${existingEntry[0]}`);
            return;
          }
          const moduleExports = await this.importModule(filePath2);
          debug.log(`[ToolLoader] Module exports for ${filePath2}:`, Object.keys(moduleExports));
          const tool = await this.extractTool(moduleExports);
          if (!tool) {
            debug.warn(`[ToolLoader] No valid tool found in ${filePath2}`);
            return;
          }
          debug.log(`[ToolLoader] Extracted tool:`, { id: tool.id, name: tool.name });
          if (!this.isValidTool(tool)) {
            debug.warn(`[ToolLoader] Invalid tool in ${filePath2}`);
            return;
          }
          if (this.loadedTools.has(tool.id)) {
            const oldInfo = this.loadedTools.get(tool.id);
            if (oldInfo.hash !== fileHash) {
              debug.log(`[ToolLoader] Tool ${tool.id} has changed, unloading old version`);
              await this.unloadTool(tool.id);
            } else {
              debug.log(`[ToolLoader] Tool ${tool.id} unchanged, skipping reload`);
              return;
            }
          }
          this.registry.register(tool);
          const registeredTool = this.registry.get(tool.id);
          if (registeredTool) {
            registeredTool.hash = fileHash;
            registeredTool.filePath = filePath2;
          }
          this.loadedTools.set(tool.id, { path: filePath2, hash: fileHash });
          debug.log(`[ToolLoader] Loaded tool: ${tool.id} from ${filePath2}`);
        } catch (error) {
          debug.error(`[ToolLoader] Failed to load ${filePath2}:`, error);
        }
      }
      /**
       * Import a module handling TypeScript if needed
       */
      async importModule(filePath) {
        try {
          if (filePath.endsWith(".js")) {
            try {
              const { createRequire } = await import("module");
              const baseUrl = typeof import.meta !== "undefined" && import.meta.url ? import.meta.url : pathToFileURL(process.cwd() + "/").href;
              const require2 = createRequire(baseUrl);
              const loadedModule2 = this.loadWithSharedDependencies(require2, filePath);
              debug.log(`[ToolLoader] Loaded ${filePath} using createRequire with shared deps`);
              return loadedModule2;
            } catch (error) {
              debug.log(`[ToolLoader] createRequire failed for ${filePath}:`, error);
            }
            try {
              const requireFunc = eval("require");
              const loadedModule = this.loadWithSharedDependencies(requireFunc, filePath);
              debug.log(`[ToolLoader] Loaded ${filePath} using direct require with shared deps`);
              return loadedModule;
            } catch (error) {
              debug.log(`[ToolLoader] Direct require failed for ${filePath}:`, error);
            }
            try {
              const fileUrl2 = pathToFileURL(filePath).href;
              const module2 = await import(fileUrl2);
              debug.log(`[ToolLoader] Loaded ${filePath} using dynamic import`);
              return module2;
            } catch (error) {
              debug.log(`[ToolLoader] Dynamic import failed for ${filePath}:`, error);
            }
          }
          const fileUrl = pathToFileURL(filePath).href;
          const module = await import(fileUrl);
          return module;
        } catch (error) {
          debug.error(`[ToolLoader] Import error for ${filePath}:`, error);
          throw error;
        }
      }
      /**
       * Extract tool from module exports
       */
      async extractTool(moduleExports) {
        if (moduleExports.default) {
          const defaultExport = moduleExports.default;
          if (typeof defaultExport === "function") {
            try {
              const result = await defaultExport();
              if (this.isValidTool(result)) return result;
            } catch {
              if (this.isValidTool(defaultExport)) {
                return defaultExport;
              }
            }
          }
          if (this.isValidTool(defaultExport)) {
            return defaultExport;
          }
          if (Array.isArray(defaultExport) && defaultExport.length > 0) {
            const firstTool = defaultExport[0];
            if (this.isValidTool(firstTool)) return firstTool;
          }
        }
        const namedExports = ["tool", "createTool"];
        for (const exportName of namedExports) {
          if (exportName in moduleExports) {
            const exported = moduleExports[exportName];
            if (typeof exported === "function") {
              try {
                const result = await exported();
                if (this.isValidTool(result)) return result;
              } catch {
              }
            }
            if (this.isValidTool(exported)) {
              return exported;
            }
          }
        }
        if (this.isValidTool(moduleExports)) {
          return moduleExports;
        }
        return null;
      }
      /**
       * Validate if an object is a valid tool
       */
      isValidTool(obj) {
        return obj && typeof obj === "object" && typeof obj.id === "string" && typeof obj.description === "string" && typeof obj.execute === "function";
      }
      /**
       * Check if a file should be loaded as a tool
       */
      isToolFile(filename) {
        return this.options.extensions.some((ext) => filename.endsWith(ext));
      }
      /**
       * Check if a path exists
       */
      async exists(path14) {
        try {
          await fs4.access(path14);
          return true;
        } catch {
          return false;
        }
      }
      /**
       * Compute hash of a file
       */
      async computeFileHash(filePath2) {
        try {
          const content = await fs4.readFile(filePath2);
          return crypto2.createHash("sha256").update(content).digest("hex");
        } catch (error) {
          debug.error(`[ToolLoader] Failed to compute hash for ${filePath2}:`, error);
          return "";
        }
      }
      /**
       * Unload a tool and run cleanup
       */
      async unloadTool(toolId) {
        debug.log(`[ToolLoader] Unloading tool: ${toolId}`);
        const tool = this.registry.get(toolId);
        if (tool && tool.definition.cleanup) {
          try {
            const context = {
              registry: this.registry,
              workingDirectory: process.cwd()
            };
            await tool.definition.cleanup(context);
            debug.log(`[ToolLoader] Cleanup completed for ${toolId}`);
          } catch (error) {
            debug.error(`[ToolLoader] Cleanup failed for ${toolId}:`, error);
          }
        }
        await this.registry.unregister(toolId);
        this.loadedTools.delete(toolId);
      }
      /**
       * Reload all tools (for --watch-tools command)
       */
      async reloadAllTools() {
        debug.log("[ToolLoader] Reloading all tools...");
        const toolIds = Array.from(this.loadedTools.keys());
        for (const toolId of toolIds) {
          if (this.loadedTools.get(toolId)?.path.startsWith("builtin:")) {
            continue;
          }
          await this.unloadTool(toolId);
        }
        if (typeof __require !== "undefined" && __require.cache) {
          for (const [toolId, info] of this.loadedTools) {
            if (info.path && !info.path.startsWith("builtin:")) {
              delete __require.cache[info.path];
            }
          }
        }
        await this.loadTools();
        debug.log("[ToolLoader] Tool reload complete");
      }
      /**
       * Set up file watchers for hot reloading
       */
      async setupWatchers() {
        const { watch } = await import("fs");
        for (const dir of this.options.directories) {
          const toolsDir = path5.join(dir, dir.endsWith("tools") ? "" : "tools");
          if (!await this.exists(toolsDir)) continue;
          const watcher = watch(toolsDir, { recursive: true }, async (eventType, filename) => {
            if (!filename || !this.isToolFile(filename)) return;
            const filePath2 = path5.join(toolsDir, filename);
            try {
              const stats = await fs4.stat(filePath2);
              if (stats.isFile()) {
                debug.log(`[ToolLoader] Reloading ${filename}...`);
                await this.loadToolFile(filePath2);
              }
            } catch {
              const toolId = this.findToolByPath(filePath2);
              if (toolId) {
                await this.registry.unregister(toolId);
                this.loadedTools.delete(toolId);
                debug.log(`[ToolLoader] Unregistered ${toolId}`);
              }
            }
          });
          this.watcherCleanup.push(() => watcher.close());
        }
      }
      /**
       * Find tool ID by file path
       */
      findToolByPath(filePath2) {
        for (const [toolId, info] of this.loadedTools.entries()) {
          if (info.path === filePath2) return toolId;
        }
        return void 0;
      }
      /**
       * Get loaded tools info
       */
      getLoadedTools() {
        return Array.from(this.loadedTools.entries()).map(([toolId, info]) => ({
          toolId,
          filePath: info.path,
          hash: info.hash
        }));
      }
      /**
       * Reload all tools
       */
      async reloadTools() {
        debug.log("[ToolLoader] Reloading all tools...");
        const currentTools = new Map(this.loadedTools);
        this.loadedTools.clear();
        for (const [_, info] of currentTools) {
          if (!info.path.startsWith("builtin:")) {
            await this.loadToolFile(info.path);
          }
        }
      }
      /**
       * Clean up resources
       */
      async cleanup() {
        for (const cleanup of this.watcherCleanup) {
          cleanup();
        }
        this.watcherCleanup = [];
        this.loadedTools.clear();
      }
      /**
       * Load a module with shared dependencies from the main clanker package
       */
      loadWithSharedDependencies(requireFunc2, filePath2) {
        const Module = requireFunc2("module");
        const originalResolveFilename = Module._resolveFilename;
        Module._resolveFilename = function(request, parent, isMain) {
          if (shouldShareDependency(request)) {
            try {
              const mainModule = __require.main || module;
              return originalResolveFilename.call(this, request, mainModule, false);
            } catch (e) {
              try {
                return originalResolveFilename.call(this, request, module, false);
              } catch (e2) {
                debug.log(`[ToolLoader] Failed to resolve shared dependency ${request}`);
              }
            }
          }
          return originalResolveFilename.call(this, request, parent, isMain);
        };
        try {
          delete requireFunc2.cache[filePath2];
          const loadedModule2 = requireFunc2(filePath2);
          return loadedModule2;
        } finally {
          Module._resolveFilename = originalResolveFilename;
        }
      }
      /**
       * Create a tool template file
       */
      static async createToolTemplate(toolName, baseDir = process.cwd()) {
        const toolsDir = path5.join(baseDir, ".clank", "tools");
        await fs4.mkdir(toolsDir, { recursive: true });
        const fileName = `${toolName}.ts`;
        const filePath2 = path5.join(toolsDir, fileName);
        try {
          await fs4.access(filePath2);
          throw new Error(`Tool file already exists: ${filePath2}`);
        } catch (error) {
          if (error.code !== "ENOENT") throw error;
        }
        const template = `/**
 * ${toolName} tool
 * 
 * This is a template for creating a custom tool.
 * Edit this file to implement your tool's functionality.
 */

import { createTool, ToolCategory, ToolCapability } from '@ziggle/clanker';

// Using the builder API
export default createTool()
  .id('${toolName}')
  .name('${toolName.charAt(0).toUpperCase() + toolName.slice(1)} Tool')
  .description('Description of what this tool does')
  .category(ToolCategory.Utility)
  .capabilities(ToolCapability.FileRead)
  .tags('custom', 'example')
  
  // Define arguments
  .stringArg('input', 'Input value', { required: true })
  .booleanArg('verbose', 'Enable verbose output', { default: false })
  
  // Define the execution logic
  .execute(async (args, context) => {
    const { input, verbose } = args;
    
    if (verbose) {
      context.logger?.debug('Processing input:', input);
    }
    
    // Your tool logic here
    const result = \`Processed: \${input}\`;
    
    return {
      success: true,
      output: result,
      data: { processed: result }
    };
  })
  .build();
`;
        await fs4.writeFile(filePath2, template, "utf-8");
        debug.log(`Created tool template: ${filePath2}`);
      }
    };
  }
});

// src/registry/index.ts
var init_registry2 = __esm({
  "src/registry/index.ts"() {
    init_esm_shims();
    init_types();
    init_registry();
    init_builder();
    init_composition();
    init_adapters();
    init_validation();
    init_loader();
    init_logger();
  }
});

// src/registry/retry-executor.ts
function analyzeErrorAndSuggestFix(error, args, toolName) {
  const errorLower = error.toLowerCase();
  if ((toolName === "bash" || toolName === "input") && (errorLower.includes("unexpected eof") || errorLower.includes("matching"))) {
    if (args.command && typeof args.command === "string") {
      const fixed = args.command.replace(/'/g, `'"'"'`);
      return { ...args, command: fixed };
    }
    if (args.prompt && typeof args.prompt === "string") {
      const fixed = args.prompt.replace(/"/g, '\\"').replace(/'/g, "\\'");
      return { ...args, prompt: fixed };
    }
  }
  if (errorLower.includes("no such file") || errorLower.includes("not found") || errorLower.includes("does not exist")) {
    if (args.path || args.file_path) {
      const originalPath = args.path || args.file_path;
      if (originalPath.startsWith("./")) {
        return { ...args, path: originalPath.substring(2), file_path: originalPath.substring(2) };
      }
      if (!originalPath.startsWith("/") && !originalPath.startsWith("./")) {
        return { ...args, path: "./" + originalPath, file_path: "./" + originalPath };
      }
      if (toolName === "search" && args.query) {
        const query = args.query;
        if (!query.includes("*")) {
          return { ...args, query: `*${query}*` };
        }
      }
    }
  }
  if (errorLower.includes("permission denied") || errorLower.includes("access denied")) {
    if (toolName === "bash" && args.command && typeof args.command === "string") {
      const cmd = args.command;
      if (!cmd.startsWith("sudo ")) {
        debug.warn("[RetryExecutor] Permission denied, but NOT auto-adding sudo for safety");
        return null;
      }
    }
  }
  if (errorLower.includes("invalid argument") || errorLower.includes("type error")) {
    const newArgs = { ...args };
    for (const [key, value] of Object.entries(newArgs)) {
      if (typeof value === "string" && value.match(/^\d+$/)) {
        newArgs[key] = parseInt(value, 10);
      }
    }
    return newArgs;
  }
  return null;
}
function generateFallbackSuggestions(context) {
  const { toolName, originalArgs, previousErrors } = context;
  const suggestions = [];
  const lastError = previousErrors[previousErrors.length - 1]?.error || "";
  const preamble = `After ${context.attempt} attempts, the last error was: "${lastError}, the original arguments were: ${JSON.stringify(originalArgs)}"`;
  if (toolName === "search") {
    suggestions.push(
      "Try using the list tool to explore the directory structure",
      `Use the bash tool with "find . -name '*pattern*'" for a broader search`,
      "Check if the file has a different extension (e.g., .txt instead of .md)"
    );
  } else if (toolName === "read_file" || toolName === "view_file") {
    suggestions.push(
      "Use the list tool to verify the file exists in the expected location",
      "Try the pwd tool to confirm the current working directory",
      'Use bash with "ls -la" to see all files including hidden ones'
    );
  } else if (toolName === "bash") {
    if (lastError.includes("command not found")) {
      suggestions.push(
        'Check if the command is installed with "which <command>"',
        "Try using the full path to the command",
        "Consider using an alternative command"
      );
    } else if (lastError.includes("permission")) {
      suggestions.push(
        "The command may require elevated permissions",
        "Try a different approach that doesn't require special permissions",
        'Check file ownership and permissions with "ls -la"'
      );
    }
  } else if (toolName === "input") {
    suggestions.push(
      "The input dialog may not be supported in this environment",
      "Consider asking the user to provide the information directly in their message",
      "Try a simpler prompt without special characters"
    );
  }
  suggestions.push(
    "Review the error messages for clues about what went wrong",
    "Consider breaking down the task into smaller steps",
    "Ask the user for clarification or additional information"
  );
  return `${preamble}. Consider these alternative approaches:
${suggestions.map((s) => `- ${s}`).join("\n")}`;
}
function createRetryToolExecutor(registry) {
  return async (toolName, args, maxRetries = 5) => {
    const context = {
      toolName,
      originalArgs: args,
      attempt: 0,
      previousErrors: []
    };
    let currentArgs = args;
    while (context.attempt < maxRetries) {
      context.attempt++;
      debug.log(`[RetryExecutor] Attempt ${context.attempt} for ${toolName}`);
      try {
        const result = await registry.execute(toolName, currentArgs);
        if (result.success) {
          if (context.attempt > 1) {
            debug.log(`[RetryExecutor] Succeeded on attempt ${context.attempt}`);
          }
          return result;
        }
        const error = result.error || "Unknown error";
        context.previousErrors.push({ error, args: currentArgs });
        debug.warn(`[RetryExecutor] Tool ${toolName} failed: ${error}`);
        const fixedArgs = analyzeErrorAndSuggestFix(error, currentArgs, toolName);
        if (fixedArgs && context.attempt < maxRetries) {
          debug.log(`[RetryExecutor] Attempting to fix error with modified arguments`);
          currentArgs = fixedArgs;
          continue;
        }
        if (context.attempt < maxRetries) {
          debug.log(`[RetryExecutor] No automatic fix available, retrying with original args`);
          currentArgs = args;
          continue;
        }
        const fallbackMsg = generateFallbackSuggestions(context);
        return {
          success: false,
          error: `${error}

${fallbackMsg}`,
          data: {
            attempts: context.attempt,
            errors: context.previousErrors
          }
        };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        context.previousErrors.push({ error: errorMsg, args: currentArgs });
        debug.error(`[RetryExecutor] Unexpected error: ${errorMsg}`);
        if (context.attempt >= maxRetries) {
          const fallbackMsg = generateFallbackSuggestions(context);
          return {
            success: false,
            error: `Execution failed: ${errorMsg}

${fallbackMsg}`,
            data: {
              attempts: context.attempt,
              errors: context.previousErrors
            }
          };
        }
      }
    }
    return {
      success: false,
      error: "Max retries exceeded",
      data: {
        attempts: context.attempt,
        errors: context.previousErrors
      }
    };
  };
}
function tryFixJson(jsonString) {
  let cleaned = jsonString.replace(/\}[^}]*$/, "}");
  const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return jsonMatch[0];
  }
  if (!cleaned.trim()) {
    return "{}";
  }
  return null;
}
function createToolExecutorWithRetry(registry) {
  const retryExecutor = createRetryToolExecutor(registry);
  return async (toolName, args) => {
    let parsedArgs = args;
    if (typeof args === "string") {
      try {
        parsedArgs = JSON.parse(args);
      } catch (error) {
        const fixed = tryFixJson(args);
        if (fixed) {
          try {
            parsedArgs = JSON.parse(fixed);
          } catch {
            const tool = registry.get(toolName);
            if (tool && (!tool.definition.arguments || tool.definition.arguments.length === 0)) {
              parsedArgs = {};
            } else {
              parsedArgs = { input: args };
            }
          }
        } else {
          parsedArgs = { input: args };
        }
      }
    }
    return retryExecutor(toolName, parsedArgs, 5);
  };
}
var init_retry_executor = __esm({
  "src/registry/retry-executor.ts"() {
    init_esm_shims();
    init_debug_logger();
  }
});

// src/utils/token-counter.ts
import { get_encoding, encoding_for_model } from "tiktoken";
function createTokenCounter(model) {
  return new TokenCounter(model);
}
var TokenCounter;
var init_token_counter = __esm({
  "src/utils/token-counter.ts"() {
    init_esm_shims();
    TokenCounter = class {
      constructor(model = "gpt-4") {
        try {
          this.encoder = encoding_for_model(model);
        } catch {
          this.encoder = get_encoding("cl100k_base");
        }
      }
      /**
       * Count tokens in a string
       */
      countTokens(text) {
        if (!text) return 0;
        return this.encoder.encode(text).length;
      }
      /**
       * Count tokens in messages array (for chat completions)
       */
      countMessageTokens(messages) {
        let totalTokens = 0;
        for (const message of messages) {
          totalTokens += 3;
          if (message.content && typeof message.content === "string") {
            totalTokens += this.countTokens(message.content);
          }
          if (message.role) {
            totalTokens += this.countTokens(message.role);
          }
          if (message.tool_calls) {
            totalTokens += this.countTokens(JSON.stringify(message.tool_calls));
          }
        }
        totalTokens += 3;
        return totalTokens;
      }
      /**
       * Estimate tokens for streaming content
       * This is an approximation since we don't have the full response yet
       */
      estimateStreamingTokens(accumulatedContent) {
        return this.countTokens(accumulatedContent);
      }
      /**
       * Clean up resources
       */
      dispose() {
        this.encoder.free();
      }
    };
  }
});

// src/clanker/agent.ts
var agent_exports = {};
__export(agent_exports, {
  GrokAgent: () => GrokAgent
});
import { EventEmitter as EventEmitter2 } from "events";
import * as path6 from "path";
var GrokAgent;
var init_agent = __esm({
  "src/clanker/agent.ts"() {
    init_esm_shims();
    init_client();
    init_registry2();
    init_retry_executor();
    init_token_counter();
    init_debug_logger();
    GrokAgent = class extends EventEmitter2 {
      constructor(options) {
        super();
        this.client = new GrokClient(
          options.apiKey,
          options.model,
          options.baseURL
        );
        this.model = options.model || "grok-3-latest";
        this.maxToolRounds = options.maxToolRounds || 30;
        this.tokenCounter = createTokenCounter(this.model);
        this.registry = createToolRegistry();
        this.executeToolWithRegistry = createToolExecutorWithRetry(this.registry);
        const directories = [];
        const homeDir = process.env.HOME || process.env.USERPROFILE || "";
        if (homeDir) {
          directories.push(path6.join(homeDir, ".clanker"));
        }
        if (options.dynamicToolsPath) {
          directories.push(options.dynamicToolsPath);
        }
        if (options.loadDynamicTools) {
          directories.push(process.cwd());
        }
        this.toolLoader = createToolLoader(this.registry, {
          directories: directories.length > 0 ? directories : void 0,
          recursive: true,
          watch: options.watchTools ?? false,
          loadBuiltins: true
        });
      }
      async chat(messages, systemPrompt, stream = false) {
        const allMessages = [];
        if (systemPrompt) {
          allMessages.push({ role: "system", content: systemPrompt });
        }
        allMessages.push(...messages);
        const tools = generateGrokTools(this.registry);
        if (stream) {
          return this.streamChat(allMessages, tools);
        } else {
          return this.nonStreamChat(allMessages, tools);
        }
      }
      async *streamChat(messages, tools) {
        let rounds = 0;
        let currentMessages = [...messages];
        let totalTokens = this.tokenCounter.countMessageTokens(currentMessages);
        while (rounds < this.maxToolRounds) {
          const stream = this.client.chatStream(
            currentMessages,
            tools.length > 0 ? tools : void 0,
            this.model
          );
          let accumulatedContent = "";
          const accumulatedToolCalls = [];
          let currentToolCall = null;
          let lastFinishReason = null;
          for await (const chunk of stream) {
            if (!chunk.choices || chunk.choices.length === 0 || !chunk.choices[0].delta) {
              continue;
            }
            if (chunk.choices[0].delta.tool_calls) {
              for (const toolCallDelta of chunk.choices[0].delta.tool_calls) {
                if (toolCallDelta.index === 0 && !currentToolCall) {
                  currentToolCall = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function?.name || "",
                      arguments: toolCallDelta.function?.arguments || ""
                    }
                  };
                } else if (currentToolCall && toolCallDelta.function?.arguments) {
                  currentToolCall.function.arguments += toolCallDelta.function.arguments;
                }
              }
            }
            if (chunk.choices[0].delta.content !== void 0 && chunk.choices[0].delta.content !== null) {
              const content = chunk.choices[0].delta.content;
              accumulatedContent += content;
              yield {
                type: "content",
                content
              };
              const currentOutputTokens = this.tokenCounter.estimateStreamingTokens(accumulatedContent) + (accumulatedToolCalls.length > 0 ? this.tokenCounter.countTokens(JSON.stringify(accumulatedToolCalls)) : 0);
              yield {
                type: "token_count",
                tokenCount: totalTokens + currentOutputTokens
              };
            }
            if (chunk.choices[0].finish_reason) {
              lastFinishReason = chunk.choices[0].finish_reason;
              if (currentToolCall) {
                accumulatedToolCalls.push(currentToolCall);
              }
              break;
            }
          }
          if (accumulatedToolCalls.length > 0) {
            yield {
              type: "tool_calls",
              toolCalls: accumulatedToolCalls
            };
            const toolResults = await this.executeToolCalls(accumulatedToolCalls);
            const assistantMessage = {
              role: "assistant",
              content: accumulatedContent || "",
              tool_calls: accumulatedToolCalls
            };
            currentMessages.push(assistantMessage);
            totalTokens = this.tokenCounter.countMessageTokens(currentMessages);
            for (let i = 0; i < toolResults.length; i++) {
              const toolResult = toolResults[i];
              yield {
                type: "tool_result",
                toolCall: accumulatedToolCalls[i],
                toolResult
              };
              const toolMessage = {
                role: "tool",
                content: this.formatToolResult(toolResult),
                tool_call_id: accumulatedToolCalls[i].id
              };
              currentMessages.push(toolMessage);
              totalTokens = this.tokenCounter.countMessageTokens(currentMessages);
              yield {
                type: "token_count",
                tokenCount: totalTokens
              };
            }
            rounds++;
            currentToolCall = null;
            debug.log(`[Agent] Tool execution complete, continuing to round ${rounds}`);
          } else if (accumulatedContent) {
            yield {
              type: "done"
            };
            return;
          } else if (lastFinishReason === "tool_calls") {
            rounds++;
          } else {
            yield {
              type: "done"
            };
            return;
          }
        }
        throw new Error(`Maximum tool rounds (${this.maxToolRounds}) exceeded`);
      }
      async nonStreamChat(messages, tools) {
        let rounds = 0;
        let currentMessages = [...messages];
        while (rounds < this.maxToolRounds) {
          const response = await this.client.chat(
            currentMessages,
            tools.length > 0 ? tools : void 0,
            this.model
          );
          const message = response.choices[0]?.message;
          if (!message) {
            throw new Error("No response from API");
          }
          if (message.tool_calls && message.tool_calls.length > 0) {
            const toolResults = await this.executeToolCalls(message.tool_calls);
            currentMessages.push({
              role: "assistant",
              content: message.content,
              tool_calls: message.tool_calls
            });
            for (let i = 0; i < toolResults.length; i++) {
              currentMessages.push({
                role: "tool",
                content: this.formatToolResult(toolResults[i]),
                tool_call_id: message.tool_calls[i].id
              });
            }
            rounds++;
          } else {
            return message.content || "";
          }
        }
        throw new Error(`Maximum tool rounds (${this.maxToolRounds}) exceeded`);
      }
      async executeToolCalls(toolCalls) {
        const results = [];
        for (const toolCall of toolCalls) {
          try {
            const result = await this.executeTool(toolCall);
            results.push(result);
          } catch (error) {
            results.push({
              success: false,
              error: `Tool execution error: ${error instanceof Error ? error.message : String(error)}`
            });
          }
        }
        return results;
      }
      async executeTool(toolCall) {
        const toolName = toolCall.function.name;
        let args;
        try {
          args = JSON.parse(toolCall.function.arguments);
        } catch (error) {
          debug.error(`[Agent] Failed to parse arguments for ${toolName}:`);
          debug.error(`[Agent] Raw arguments: ${JSON.stringify(toolCall.function.arguments)}`);
          debug.error(`[Agent] Error: ${error}`);
          const tool = this.registry.get(toolName);
          let errorMessage = `Failed to parse JSON arguments: ${error instanceof Error ? error.message : String(error)}`;
          errorMessage += `

The raw arguments were: ${toolCall.function.arguments}`;
          if (tool) {
            errorMessage += `

Tool "${toolName}" expects:`;
            if (!tool.definition.arguments || tool.definition.arguments.length === 0) {
              errorMessage += "\n- No arguments required (use empty object: {})";
            } else {
              tool.definition.arguments.forEach((arg) => {
                errorMessage += `
- ${arg.name}: ${arg.type}${arg.required ? " (required)" : " (optional)"}`;
                if (arg.description) {
                  errorMessage += ` - ${arg.description}`;
                }
              });
            }
          }
          return {
            success: false,
            error: errorMessage
          };
        }
        return this.executeToolWithRegistry(toolName, args);
      }
      formatToolResult(result) {
        if (result.success) {
          return result.output || JSON.stringify(result.data) || "Success";
        } else {
          return `Error: ${result.error}`;
        }
      }
      // Public API for registry access
      getRegistry() {
        return this.registry;
      }
      async waitForToolsToLoad() {
        if (this.toolLoader) {
          await this.toolLoader.loadTools();
        }
      }
      // Get tool statistics
      getToolStats() {
        const registryImpl = this.registry;
        return registryImpl.getExecutionStats();
      }
      // Get the underlying Grok client
      getClient() {
        return this.client;
      }
      // Reload dynamic tools
      async reloadDynamicTools() {
        if (this.toolLoader) {
          await this.toolLoader.reloadAllTools();
        }
      }
      // Clean up resources
      dispose() {
        this.tokenCounter.dispose();
        if (this.toolLoader) {
          this.toolLoader.cleanup();
        }
      }
    };
  }
});

// src/package-manager/repository-manager.ts
var repository_manager_exports = {};
__export(repository_manager_exports, {
  RepositoryManager: () => RepositoryManager
});
import * as fs5 from "fs/promises";
import * as path7 from "path";
import * as os4 from "os";
var DEFAULT_REPOSITORY, CORE_TOOLS_REPOSITORY, RepositoryManager;
var init_repository_manager = __esm({
  "src/package-manager/repository-manager.ts"() {
    init_esm_shims();
    init_debug_logger();
    DEFAULT_REPOSITORY = {
      url: "https://github.com/ziggle-dev/clanker-tools",
      name: "Official Clanker Tools",
      description: "The official Clanker tool registry",
      enabled: true,
      addedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    CORE_TOOLS_REPOSITORY = {
      url: "https://github.com/ziggle-dev/clanker-core-tools",
      name: "clanker-core-tools",
      description: "Core tools for Clanker CLI",
      enabled: true,
      addedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    RepositoryManager = class {
      constructor() {
        this.settingsPath = path7.join(os4.homedir(), ".clanker", "settings.json");
      }
      async loadSettings() {
        try {
          const content = await fs5.readFile(this.settingsPath, "utf8");
          const allSettings = JSON.parse(content);
          if (!allSettings.repositories) {
            allSettings.repositories = [DEFAULT_REPOSITORY];
            allSettings.defaultRepository = DEFAULT_REPOSITORY.url;
            await this.saveSettings(allSettings);
          }
          const hasCoreTools = allSettings.repositories.some(
            (r) => r.url === "https://github.com/ziggle-dev/clanker-core-tools"
          );
          if (!hasCoreTools) {
            allSettings.repositories.push(CORE_TOOLS_REPOSITORY);
            await this.saveSettings(allSettings);
          }
          this.settings = {
            repositories: allSettings.repositories,
            defaultRepository: allSettings.defaultRepository || DEFAULT_REPOSITORY.url
          };
        } catch (error) {
          debug.log("[RepositoryManager] Creating default settings");
          this.settings = {
            repositories: [DEFAULT_REPOSITORY],
            defaultRepository: DEFAULT_REPOSITORY.url
          };
          await this.ensureSettingsDir();
          await this.saveSettings({
            repositories: this.settings.repositories,
            defaultRepository: this.settings.defaultRepository
          });
        }
      }
      async saveSettings(allSettings) {
        const existingSettings = await this.loadExistingSettings();
        const mergedSettings = {
          ...existingSettings,
          repositories: allSettings.repositories || this.settings.repositories,
          defaultRepository: allSettings.defaultRepository || this.settings.defaultRepository
        };
        await fs5.writeFile(this.settingsPath, JSON.stringify(mergedSettings, null, 2));
      }
      async loadExistingSettings() {
        try {
          const content = await fs5.readFile(this.settingsPath, "utf8");
          return JSON.parse(content);
        } catch {
          return {};
        }
      }
      async ensureSettingsDir() {
        const dir = path7.dirname(this.settingsPath);
        await fs5.mkdir(dir, { recursive: true });
      }
      async addRepository(repoUrl) {
        await this.loadSettings();
        repoUrl = repoUrl.trim();
        if (!repoUrl.startsWith("http://") && !repoUrl.startsWith("https://")) {
          repoUrl = `https://github.com/${repoUrl}`;
        }
        const existing = this.settings.repositories.find((r) => r.url === repoUrl);
        if (existing) {
          console.log(`\u26A0\uFE0F  Repository already exists: ${existing.name}`);
          return;
        }
        const urlParts = repoUrl.split("/");
        const repoName = urlParts[urlParts.length - 1] || "Custom Repository";
        const newRepo = {
          url: repoUrl,
          name: repoName,
          description: `Custom repository: ${repoUrl}`,
          enabled: true,
          addedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        this.settings.repositories.push(newRepo);
        const allSettings = await this.loadExistingSettings();
        allSettings.repositories = this.settings.repositories;
        allSettings.defaultRepository = this.settings.defaultRepository;
        await this.saveSettings(allSettings);
        console.log(`\u2705 Added repository: ${newRepo.name}`);
        console.log(`   URL: ${repoUrl}`);
        console.log(`
\u{1F4A1} Note: Repository priority is determined by order in settings.json`);
        console.log(`   The official repository remains the highest priority by default.`);
      }
      async removeRepository(repoUrl) {
        await this.loadSettings();
        repoUrl = repoUrl.trim();
        if (!repoUrl.startsWith("http://") && !repoUrl.startsWith("https://")) {
          repoUrl = `https://github.com/${repoUrl}`;
        }
        if (repoUrl === DEFAULT_REPOSITORY.url) {
          console.error("\u274C Cannot remove the official Clanker repository");
          return;
        }
        const index = this.settings.repositories.findIndex((r) => r.url === repoUrl);
        if (index === -1) {
          console.error("\u274C Repository not found:", repoUrl);
          return;
        }
        const removed = this.settings.repositories.splice(index, 1)[0];
        const allSettings = await this.loadExistingSettings();
        allSettings.repositories = this.settings.repositories;
        await this.saveSettings(allSettings);
        console.log(`\u2705 Removed repository: ${removed.name}`);
      }
      async listRepositories() {
        await this.loadSettings();
        console.log("\u{1F4E6} Configured Repositories:\n");
        this.settings.repositories.forEach((repo, index) => {
          const isDefault = repo.url === this.settings.defaultRepository;
          const priority = index + 1;
          console.log(`${priority}. ${repo.name}${isDefault ? " (default)" : ""}`);
          console.log(`   URL: ${repo.url}`);
          if (repo.description) {
            console.log(`   Description: ${repo.description}`);
          }
          console.log(`   Status: ${repo.enabled ? "\u2705 Enabled" : "\u274C Disabled"}`);
          console.log(`   Added: ${new Date(repo.addedAt).toLocaleDateString()}`);
          console.log();
        });
        console.log("\u{1F4A1} Tip: Repository search priority follows the order shown above.");
        console.log("   Edit ~/.clanker/settings.json to change the priority order.");
      }
      async getRepositories() {
        await this.loadSettings();
        return this.settings.repositories.filter((r) => r.enabled);
      }
      async getDefaultRepository() {
        await this.loadSettings();
        return this.settings.defaultRepository;
      }
    };
  }
});

// src/package-manager/registry.ts
import * as fs6 from "fs/promises";
import * as path8 from "path";
var RegistryClient;
var init_registry3 = __esm({
  "src/package-manager/registry.ts"() {
    init_esm_shims();
    init_debug_logger();
    init_repository_manager();
    RegistryClient = class {
      constructor(options = {}) {
        this.cacheTimeout = 1e3;
        this.registryUrl = options.registryUrl || "https://raw.githubusercontent.com/ziggle-dev/clanker-tools/main";
        this.cacheDir = options.cacheDir || path8.join(process.env.HOME || "", ".clanker", "cache");
        this.repoManager = new RepositoryManager();
      }
      /**
       * Fetch the tool registry from all configured repositories
       */
      async fetchRegistry() {
        const repositories = await this.repoManager.getRepositories();
        const allTools = [];
        const errors = [];
        for (const repo of repositories) {
          try {
            debug.log(`[Registry] Fetching from ${repo.name}`);
            const registryUrl = this.getRegistryUrl(repo.url);
            const cacheFile = path8.join(this.cacheDir, `registry-${this.hashUrl(repo.url)}.json`);
            try {
              const cached = await this.readCache(cacheFile);
              if (cached) {
                debug.log(`[Registry] Using cached registry for ${repo.name}`);
                allTools.push(...cached.tools);
                continue;
              }
            } catch {
              debug.log(`[Registry] Cache miss for ${repo.name}`);
            }
            let registry = null;
            if (repo.url.includes("github.com")) {
              registry = await this.fetchFromGitHubReleases(repo);
            }
            if (!registry) {
              const url = `${registryUrl}/registry.json`;
              const response = await fetch(url);
              if (!response.ok) {
                throw new Error(`Failed to fetch from ${repo.name}: ${response.statusText}`);
              }
              registry = await response.json();
            }
            await this.writeCache(cacheFile, registry);
            allTools.push(...registry.tools);
          } catch (error) {
            const errorMsg = `Failed to fetch from ${repo.name}: ${error instanceof Error ? error.message : String(error)}`;
            debug.error(`[Registry] ${errorMsg}`);
            errors.push(errorMsg);
          }
        }
        if (allTools.length === 0 && errors.length > 0) {
          throw new Error(`Failed to fetch from any repository:
${errors.join("\n")}`);
        }
        const uniqueTools = /* @__PURE__ */ new Map();
        for (const tool of allTools) {
          const key = `${tool.org}/${tool.name}`;
          if (!uniqueTools.has(key)) {
            uniqueTools.set(key, tool);
          }
        }
        return {
          version: "1.0.0",
          tools: Array.from(uniqueTools.values()),
          updated: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      /**
       * Fetch metadata for a specific tool from repositories
       */
      async fetchToolMetadata(tool) {
        debug.log(`[Registry] Fetching metadata for ${tool.org}/${tool.name}`);
        const registry = await this.fetchRegistry();
        debug.log(`[Registry] Found ${registry.tools.length} tools in registry`);
        const toolInfo = registry.tools.find(
          (t) => t.org === tool.org && t.name === tool.name
        );
        if (toolInfo) {
          debug.log(`[Registry] Found tool in registry:`, toolInfo);
          const version = toolInfo.version || toolInfo.latest || "1.0.0";
          debug.log(`[Registry] Converting toolInfo to metadata. Version: ${version}`);
          const metadata = {
            id: toolInfo.id || `${toolInfo.org}/${toolInfo.name}`,
            name: `${toolInfo.org}-clanker-tool-${toolInfo.name}`,
            description: toolInfo.description,
            author: toolInfo.author || "Unknown",
            homepage: toolInfo.homepage || toolInfo.repository || "",
            repository: toolInfo.repository || "",
            latest: version,
            versions: {
              [version]: {
                date: toolInfo.updated || toolInfo.created || (/* @__PURE__ */ new Date()).toISOString(),
                minClankerVersion: "0.1.0",
                sha256: "example-hash-will-be-computed"
              }
            },
            tags: toolInfo.keywords || []
          };
          debug.log(`[Registry] Created metadata:`, JSON.stringify(metadata, null, 2));
          return metadata;
        }
        const repositories = await this.repoManager.getRepositories();
        const errors = [];
        for (const repo of repositories) {
          try {
            const registryUrl = this.getRegistryUrl(repo.url);
            const cacheFile = path8.join(this.cacheDir, "tools", `${this.hashUrl(repo.url)}-${tool.org}-${tool.name}.json`);
            try {
              const cached = await this.readCache(cacheFile);
              if (cached) {
                debug.log(`[Registry] Using cached metadata for ${tool.org}/${tool.name} from ${repo.name}`);
                return cached;
              }
            } catch {
              debug.log(`[Registry] Cache miss for ${tool.org}/${tool.name} from ${repo.name}`);
            }
            const url = `${registryUrl}/tools/${tool.org}/${tool.name}/metadata.json`;
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`Not found in ${repo.name}`);
            }
            const metadata = await response.json();
            await this.writeCache(cacheFile, metadata);
            return metadata;
          } catch (error) {
            const errorMsg = `${repo.name}: ${error instanceof Error ? error.message : String(error)}`;
            debug.log(`[Registry] ${errorMsg}`);
            errors.push(errorMsg);
          }
        }
        throw new Error(`Tool not found: ${tool.org}/${tool.name}
Searched in:
${errors.join("\n")}`);
      }
      /**
       * Download a tool file from repositories
       */
      async downloadTool(tool, version) {
        const repositories = await this.repoManager.getRepositories();
        const errors = [];
        for (const repo of repositories) {
          try {
            if (repo.url.includes("github.com")) {
              const releaseBuffer = await this.downloadFromRelease(repo, tool, version);
              if (releaseBuffer) {
                return releaseBuffer;
              }
            }
            const registryUrl = this.getRegistryUrl(repo.url);
            const url = `${registryUrl}/tools/${tool.org}/${tool.name}/${version}/index.js`;
            debug.log(`[Registry] Downloading ${tool.org}/${tool.name}@${version} from ${repo.name} (raw)`);
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`Not found in ${repo.name}: ${response.statusText}`);
            }
            const buffer = await response.arrayBuffer();
            return Buffer.from(buffer);
          } catch (error) {
            const errorMsg = `${repo.name}: ${error instanceof Error ? error.message : String(error)}`;
            debug.log(`[Registry] ${errorMsg}`);
            errors.push(errorMsg);
          }
        }
        throw new Error(`Failed to download tool ${tool.org}/${tool.name}@${version}
Tried:
${errors.join("\n")}`);
      }
      /**
       * Download tool from GitHub release
       */
      async downloadFromRelease(repo, tool, version) {
        try {
          const match = repo.url.match(/github\.com\/([^/]+)\/([^/]+)/);
          if (!match) return null;
          const [, owner, repoName] = match;
          let release = this.currentRelease;
          if (!release) {
            const releaseUrl = `https://api.github.com/repos/${owner}/${repoName}/releases/latest`;
            const releaseResponse = await fetch(releaseUrl, {
              headers: {
                "Accept": "application/vnd.github.v3+json",
                ...process.env.GITHUB_TOKEN && {
                  "Authorization": `token ${process.env.GITHUB_TOKEN}`
                }
              }
            });
            if (!releaseResponse.ok) {
              return null;
            }
            release = await releaseResponse.json();
          }
          const orgAsset = release.assets?.find(
            (asset) => asset.name === `${tool.org}.tar.gz`
          );
          if (!orgAsset) {
            debug.log(`[Registry] No ${tool.org}.tar.gz in release`);
            return null;
          }
          debug.log(`[Registry] Downloading ${tool.org}.tar.gz from release`);
          const response = await fetch(orgAsset.browser_download_url);
          if (!response.ok) {
            throw new Error(`Failed to download archive: ${response.statusText}`);
          }
          const buffer = await response.arrayBuffer();
          return Buffer.from(buffer);
        } catch (error) {
          debug.error(`[Registry] Error downloading from release:`, error);
          return null;
        }
      }
      /**
       * Search for tools in the registry
       */
      async searchTools(query) {
        const registry = await this.fetchRegistry();
        const lowerQuery = query.toLowerCase();
        return registry.tools.filter(
          (tool) => tool.name.toLowerCase().includes(lowerQuery) || tool.description.toLowerCase().includes(lowerQuery) || tool.org.toLowerCase().includes(lowerQuery)
        );
      }
      /**
       * Read from cache
       */
      async readCache(filePath2) {
        try {
          const stat3 = await fs6.stat(filePath2);
          const age = Date.now() - stat3.mtime.getTime();
          if (age > this.cacheTimeout) {
            debug.log(`[Registry] Cache expired for ${filePath2}`);
            return null;
          }
          const content = await fs6.readFile(filePath2, "utf-8");
          return JSON.parse(content);
        } catch {
          return null;
        }
      }
      /**
       * Write to cache
       */
      async writeCache(filePath2, data) {
        try {
          await fs6.mkdir(path8.dirname(filePath2), { recursive: true });
          await fs6.writeFile(filePath2, JSON.stringify(data, null, 2));
        } catch (error) {
          debug.warn(`[Registry] Failed to write cache for ${filePath2}:`, error);
        }
      }
      /**
       * Clear cache
       */
      async clearCache() {
        try {
          await fs6.rm(this.cacheDir, { recursive: true, force: true });
          debug.log("[Registry] Cache cleared");
        } catch (error) {
          debug.warn("[Registry] Failed to clear cache:", error);
        }
      }
      /**
       * Get registry URL from repository URL
       */
      getRegistryUrl(repoUrl) {
        if (repoUrl.includes("github.com")) {
          const match = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
          if (match) {
            const [, owner, repo] = match;
            return `https://raw.githubusercontent.com/${owner}/${repo}/main`;
          }
        }
        return repoUrl;
      }
      /**
       * Hash URL for cache file naming
       */
      hashUrl(url) {
        let hash = 0;
        for (let i = 0; i < url.length; i++) {
          const char = url.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return Math.abs(hash).toString(16);
      }
      /**
       * Fetch tools from GitHub releases
       */
      async fetchFromGitHubReleases(repo) {
        try {
          const match = repo.url.match(/github\.com\/([^/]+)\/([^/]+)/);
          if (!match) return null;
          const [, owner, repoName] = match;
          debug.log(`[Registry] Checking for releases in ${owner}/${repoName}`);
          const releaseUrl = `https://api.github.com/repos/${owner}/${repoName}/releases/latest`;
          const releaseResponse = await fetch(releaseUrl, {
            headers: {
              "Accept": "application/vnd.github.v3+json",
              ...process.env.GITHUB_TOKEN && {
                "Authorization": `token ${process.env.GITHUB_TOKEN}`
              }
            }
          });
          if (!releaseResponse.ok) {
            debug.log(`[Registry] No releases found for ${repo.name} (${releaseResponse.status})`);
            return null;
          }
          const release = await releaseResponse.json();
          const toolsAsset = release.assets?.find(
            (asset) => asset.name === "tools.json"
          );
          if (!toolsAsset) {
            debug.log(`[Registry] No tools.json in release for ${repo.name}`);
            return null;
          }
          debug.log(`[Registry] Downloading tools.json from release ${release.tag_name}`);
          const toolsResponse = await fetch(toolsAsset.browser_download_url);
          if (!toolsResponse.ok) {
            throw new Error(`Failed to download tools.json: ${toolsResponse.statusText}`);
          }
          const toolsIndex = await toolsResponse.json();
          this.currentRelease = release;
          return {
            version: toolsIndex.version || "1.0.0",
            tools: toolsIndex.tools || [],
            updated: toolsIndex.timestamp || (/* @__PURE__ */ new Date()).toISOString()
          };
        } catch (error) {
          debug.error(`[Registry] Error fetching from releases:`, error);
          return null;
        }
      }
    };
  }
});

// src/package-manager/resolver.ts
var VersionResolver;
var init_resolver = __esm({
  "src/package-manager/resolver.ts"() {
    init_esm_shims();
    VersionResolver = class {
      /**
       * Parse a version string (e.g., "1.2.3", "latest", "^1.2.0")
       */
      parseVersionSpec(spec) {
        if (spec === "latest") {
          return { type: "latest", value: "latest" };
        }
        if (spec.startsWith("^") || spec.startsWith("~") || spec.includes("*")) {
          return { type: "range", value: spec };
        }
        return { type: "exact", value: spec };
      }
      /**
       * Resolve a version spec to an exact version
       */
      resolveVersion(metadata, spec) {
        const parsed = this.parseVersionSpec(spec);
        switch (parsed.type) {
          case "latest":
            return metadata.latest;
          case "exact":
            if (!metadata.versions[parsed.value]) {
              throw new Error(`Version ${parsed.value} not found for ${metadata.id}`);
            }
            return parsed.value;
          case "range":
            return this.resolveVersionRange(metadata, parsed.value);
        }
      }
      /**
       * Resolve a version range to the best matching version
       */
      resolveVersionRange(metadata, range) {
        const versions = Object.keys(metadata.versions);
        const sortedVersions = versions.sort(
          (a, b) => this.compareVersions(b, a)
        );
        if (range.startsWith("^")) {
          const baseVersion = range.substring(1);
          const [major] = baseVersion.split(".");
          for (const version of sortedVersions) {
            if (version.startsWith(major + ".")) {
              return version;
            }
          }
        } else if (range.startsWith("~")) {
          const baseVersion = range.substring(1);
          const [major, minor] = baseVersion.split(".");
          for (const version of sortedVersions) {
            if (version.startsWith(`${major}.${minor}.`)) {
              return version;
            }
          }
        }
        return metadata.latest;
      }
      /**
       * Compare two version strings
       */
      compareVersions(a, b) {
        const partsA = a.split(".").map(Number);
        const partsB = b.split(".").map(Number);
        for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
          const partA = partsA[i] || 0;
          const partB = partsB[i] || 0;
          if (partA > partB) return 1;
          if (partA < partB) return -1;
        }
        return 0;
      }
      /**
       * Check if a version satisfies a constraint
       */
      satisfiesVersion(version, constraint) {
        const parsed = this.parseVersionSpec(constraint);
        switch (parsed.type) {
          case "exact":
            return version === parsed.value;
          case "latest":
            return true;
          // Any version satisfies "latest"
          case "range":
            return this.versionInRange(version, parsed.value);
        }
      }
      /**
       * Check if a version is within a range
       */
      versionInRange(version, range) {
        if (range.startsWith("^")) {
          const baseVersion = range.substring(1);
          const [baseMajor] = baseVersion.split(".");
          const [versionMajor] = version.split(".");
          return baseMajor === versionMajor && this.compareVersions(version, baseVersion) >= 0;
        }
        if (range.startsWith("~")) {
          const baseVersion = range.substring(1);
          const [baseMajor, baseMinor] = baseVersion.split(".");
          const [versionMajor, versionMinor] = version.split(".");
          return baseMajor === versionMajor && baseMinor === versionMinor && this.compareVersions(version, baseVersion) >= 0;
        }
        return false;
      }
      /**
       * Check Clanker version compatibility
       */
      checkClankerCompatibility(versionInfo, currentClankerVersion) {
        if (!versionInfo.minClankerVersion) {
          return true;
        }
        return this.compareVersions(currentClankerVersion, versionInfo.minClankerVersion) >= 0;
      }
    };
  }
});

// src/package-manager/experimental.ts
import * as fs7 from "fs/promises";
import * as path9 from "path";
var ExperimentalToolManager;
var init_experimental = __esm({
  "src/package-manager/experimental.ts"() {
    init_esm_shims();
    init_debug_logger();
    ExperimentalToolManager = class {
      constructor(options = {}) {
        this.options = options;
        const baseDir = options.toolsDir || path9.join(process.env.HOME || "", ".clanker", "tools");
        this.manifestPath = path9.join(baseDir, "experimental-manifest.json");
        this.registryUrl = "https://api.github.com/repos/ziggle-dev/clanker-tools";
      }
      /**
       * Check if experimental mode is enabled
       */
      async isEnabled() {
        if (process.env.CLANKER_EXPERIMENTAL === "true") {
          return true;
        }
        try {
          const configPath = path9.join(process.env.HOME || "", ".clanker", "config.json");
          const config2 = await fs7.readFile(configPath, "utf-8");
          const parsed = JSON.parse(config2);
          return parsed.experimental?.enabled === true;
        } catch {
          return false;
        }
      }
      /**
       * Enable experimental mode
       */
      async enable() {
        const configPath = path9.join(process.env.HOME || "", ".clanker", "config.json");
        let config2 = {};
        try {
          const existing = await fs7.readFile(configPath, "utf-8");
          config2 = JSON.parse(existing);
        } catch {
        }
        config2.experimental = {
          enabled: true,
          autoUpgrade: true,
          sources: ["branches", "pull-requests"]
        };
        await fs7.mkdir(path9.dirname(configPath), { recursive: true });
        await fs7.writeFile(configPath, JSON.stringify(config2, null, 2));
        debug.log("[Experimental] Experimental mode enabled");
      }
      /**
       * List available experimental tools from branches
       */
      async listAvailable() {
        const tools = [];
        try {
          const response = await fetch(`${this.registryUrl}/branches`, {
            headers: {
              "Accept": "application/vnd.github.v3+json",
              "User-Agent": "clanker-cli"
            }
          });
          if (!response.ok) {
            throw new Error(`Failed to fetch branches: ${response.statusText}`);
          }
          const branches = await response.json();
          const toolBranches = branches.filter(
            (branch) => branch.name.match(/^[^/]+\/[^/]+@[\d.]+$/)
          );
          for (const branch of toolBranches) {
            const [orgTool, version] = branch.name.split("@");
            const [org, name] = orgTool.split("/");
            tools.push({
              org,
              name,
              version,
              installedAt: "",
              path: "",
              experimental: true,
              source: "branch",
              sourceRef: branch.name
            });
          }
          const prResponse = await fetch(`${this.registryUrl}/pulls?state=open`, {
            headers: {
              "Accept": "application/vnd.github.v3+json",
              "User-Agent": "clanker-cli"
            }
          });
          if (prResponse.ok) {
            const prs = await prResponse.json();
            for (const pr of prs) {
              if (pr.head.ref.match(/^[^/]+\/[^/]+@[\d.]+$/)) {
                const [orgTool, version] = pr.head.ref.split("@");
                const [org, name] = orgTool.split("/");
                tools.push({
                  org,
                  name,
                  version,
                  installedAt: "",
                  path: "",
                  experimental: true,
                  source: "pr",
                  sourceRef: pr.number.toString()
                });
              }
            }
          }
        } catch (error) {
          debug.error("[Experimental] Failed to list available tools:", error);
        }
        return tools;
      }
      /**
       * Install an experimental tool
       */
      async install(toolSpec) {
        debug.log(`[Experimental] Installing experimental tool: ${toolSpec}`);
        let org, name, ref;
        let source;
        if (toolSpec.includes("@pr-")) {
          const [orgTool, prRef] = toolSpec.split("@pr-");
          [org, name] = orgTool.split("/");
          ref = prRef;
          source = "pr";
        } else if (toolSpec.includes("@")) {
          const [orgTool, branchRef] = toolSpec.split("@");
          [org, name] = orgTool.split("/");
          ref = branchRef;
          source = "branch";
        } else {
          throw new Error("Experimental tools must specify a version, branch, or PR number");
        }
        let branchName = ref;
        if (source === "pr") {
          const response = await fetch(`${this.registryUrl}/pulls/${ref}`, {
            headers: {
              "Accept": "application/vnd.github.v3+json",
              "User-Agent": "clanker-cli"
            }
          });
          if (!response.ok) {
            throw new Error(`PR #${ref} not found`);
          }
          const pr = await response.json();
          branchName = pr.head.ref;
        }
        const toolUrl = `https://raw.githubusercontent.com/ziggle-dev/clanker-tools/${branchName}/tools/${org}/${name}`;
        const versionsResponse = await fetch(`${toolUrl}`, {
          headers: { "User-Agent": "clanker-cli" }
        });
        if (!versionsResponse.ok) {
          throw new Error(`Tool ${org}/${name} not found in branch ${branchName}`);
        }
        const version = branchName.split("@")[1] || "experimental";
        const toolDir = path9.join(
          this.options.toolsDir || path9.join(process.env.HOME || "", ".clanker", "tools"),
          org,
          name,
          version
        );
        await fs7.mkdir(toolDir, { recursive: true });
        const indexResponse = await fetch(`${toolUrl}/${version}/index.js`, {
          headers: { "User-Agent": "clanker-cli" }
        });
        if (!indexResponse.ok) {
          throw new Error(`Failed to download tool files`);
        }
        const indexContent = await indexResponse.text();
        await fs7.writeFile(path9.join(toolDir, "index.js"), indexContent);
        const manifestResponse = await fetch(`${toolUrl}/${version}/manifest.json`, {
          headers: { "User-Agent": "clanker-cli" }
        });
        if (manifestResponse.ok) {
          const manifestContent = await manifestResponse.text();
          await fs7.writeFile(path9.join(toolDir, "manifest.json"), manifestContent);
        }
        await this.addToManifest({
          org,
          name,
          version,
          installedAt: (/* @__PURE__ */ new Date()).toISOString(),
          path: toolDir,
          experimental: true,
          source,
          sourceRef: ref
        });
        console.log(`\u2705 Installed experimental tool: ${org}/${name}@${version} from ${source} ${ref}`);
      }
      /**
       * List installed experimental tools
       */
      async listInstalled() {
        try {
          const manifest = await this.loadManifest();
          return manifest.experimental;
        } catch {
          return [];
        }
      }
      /**
       * Upgrade experimental tools to stable versions
       */
      async upgradeToStable() {
        const experimental = await this.listInstalled();
        let upgraded = 0;
        for (const tool of experimental) {
          try {
            const registryResponse = await fetch(
              `https://raw.githubusercontent.com/ziggle-dev/clanker-tools/main/tools/${tool.org}/${tool.name}/metadata.json`,
              { headers: { "User-Agent": "clanker-cli" } }
            );
            if (registryResponse.ok) {
              const metadata = await registryResponse.json();
              if (metadata.versions && metadata.versions[tool.version]) {
                console.log(`\u{1F4E6} Upgrading ${tool.org}/${tool.name}@${tool.version} to stable`);
                await this.removeFromManifest(tool);
                upgraded++;
              }
            }
          } catch (error) {
            debug.error(`[Experimental] Failed to check ${tool.org}/${tool.name}:`, error);
          }
        }
        if (upgraded > 0) {
          console.log(`\u2705 Upgraded ${upgraded} tools to stable versions`);
        } else {
          console.log("\u2139\uFE0F  No experimental tools ready for upgrade");
        }
      }
      /**
       * Load experimental manifest
       */
      async loadManifest() {
        try {
          const content = await fs7.readFile(this.manifestPath, "utf-8");
          return JSON.parse(content);
        } catch {
          return {
            version: "1.0.0",
            experimental: [],
            lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
          };
        }
      }
      /**
       * Save experimental manifest
       */
      async saveManifest(manifest) {
        await fs7.mkdir(path9.dirname(this.manifestPath), { recursive: true });
        await fs7.writeFile(this.manifestPath, JSON.stringify(manifest, null, 2));
      }
      /**
       * Add tool to experimental manifest
       */
      async addToManifest(tool) {
        const manifest = await this.loadManifest();
        manifest.experimental = manifest.experimental.filter(
          (t) => !(t.org === tool.org && t.name === tool.name)
        );
        manifest.experimental.push(tool);
        manifest.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
        await this.saveManifest(manifest);
      }
      /**
       * Remove tool from experimental manifest
       */
      async removeFromManifest(tool) {
        const manifest = await this.loadManifest();
        manifest.experimental = manifest.experimental.filter(
          (t) => !(t.org === tool.org && t.name === tool.name && t.version === tool.version)
        );
        manifest.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
        await this.saveManifest(manifest);
      }
    };
  }
});

// src/package-manager/installer.ts
import * as fs8 from "fs/promises";
import * as path10 from "path";
import * as crypto3 from "crypto";
var ToolInstaller;
var init_installer = __esm({
  "src/package-manager/installer.ts"() {
    init_esm_shims();
    init_debug_logger();
    init_registry3();
    init_resolver();
    init_experimental();
    ToolInstaller = class {
      constructor(options = {}) {
        this.toolsDir = options.toolsDir || path10.join(process.env.HOME || "", ".clanker", "tools");
        this.manifestPath = path10.join(this.toolsDir, "manifest.json");
        this.registry = new RegistryClient(options);
        this.resolver = new VersionResolver();
        this.experimental = new ExperimentalToolManager(options);
      }
      /**
       * Install a tool
       */
      async install(toolSpec, options = {}) {
        if (toolSpec.includes("@pr-") || toolSpec.includes("@") && !toolSpec.match(/@[\d.]+$/)) {
          const isExperimental = await this.experimental.isEnabled();
          if (isExperimental) {
            await this.experimental.install(toolSpec);
            return;
          } else {
            console.log("\u2139\uFE0F  This appears to be an experimental tool. Use --enable-experimental first.");
            return;
          }
        }
        const tool = this.parseToolSpec(toolSpec);
        debug.log(`[Installer] Installing ${tool.org}/${tool.name}${tool.version ? "@" + tool.version : ""}`);
        try {
          const metadata = await this.registry.fetchToolMetadata(tool);
          debug.log(`[Installer] Fetched metadata:`, JSON.stringify(metadata, null, 2));
          const version = this.resolver.resolveVersion(metadata, tool.version || "latest");
          tool.version = version;
          debug.log(`[Installer] Resolved version: ${version}`);
          const manifest = await this.loadManifest();
          const existing = manifest.installedTools.find(
            (t) => t.org === tool.org && t.name === tool.name
          );
          if (existing && existing.version === version && !options.force) {
            console.log(`\u2705 ${tool.org}/${tool.name}@${version} is already installed`);
            return;
          }
          debug.log(`[Installer] Checking version info for version ${version}`);
          debug.log(`[Installer] Available versions:`, Object.keys(metadata.versions));
          const versionInfo = metadata.versions[version];
          const clankerVersion = await this.getClankerVersion();
          if (!this.resolver.checkClankerCompatibility(versionInfo, clankerVersion)) {
            throw new Error(`This tool requires Clanker ${versionInfo.minClankerVersion} or higher (current: ${clankerVersion})`);
          }
          console.log(`\u{1F4E5} Downloading ${tool.org}/${tool.name}@${version}...`);
          const downloadBuffer = await this.registry.downloadTool(tool, version);
          const toolContent = await this.extractToolContent(downloadBuffer, tool);
          if (versionInfo.sha256 && versionInfo.sha256 !== "example-hash-will-be-computed") {
            const hash = crypto3.createHash("sha256").update(toolContent).digest("hex");
            if (hash !== versionInfo.sha256) {
              throw new Error("Checksum verification failed");
            }
          }
          const installPath = await this.installToFilesystem(tool, version, toolContent);
          await this.updateManifest(tool, version, installPath);
          console.log(`\u2705 Successfully installed ${tool.org}/${tool.name}@${version}`);
          if (!options.skipDependencies && versionInfo.dependencies) {
            for (const [depName, depVersion] of Object.entries(versionInfo.dependencies)) {
              console.log(`\u{1F4E6} Installing dependency: ${depName}@${depVersion}`);
              await this.install(`${depName}@${depVersion}`, { ...options, skipDependencies: true });
            }
          }
        } catch (error) {
          console.error(`\u274C Failed to install ${toolSpec}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Uninstall a tool
       */
      async uninstall(toolSpec) {
        const tool = this.parseToolSpec(toolSpec);
        debug.log(`[Installer] Uninstalling ${tool.org}/${tool.name}`);
        try {
          const manifest = await this.loadManifest();
          const installedIndex = manifest.installedTools.findIndex(
            (t) => t.org === tool.org && t.name === tool.name
          );
          if (installedIndex === -1) {
            throw new Error(`Tool ${tool.org}/${tool.name} is not installed`);
          }
          const installed = manifest.installedTools[installedIndex];
          const toolDir = path10.dirname(installed.path);
          await fs8.rm(toolDir, { recursive: true, force: true });
          manifest.installedTools.splice(installedIndex, 1);
          await this.saveManifest(manifest);
          console.log(`\u2705 Successfully uninstalled ${tool.org}/${tool.name}`);
        } catch (error) {
          console.error(`\u274C Failed to uninstall ${toolSpec}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * List installed tools
       */
      async listInstalled() {
        const manifest = await this.loadManifest();
        return manifest.installedTools;
      }
      /**
       * Update a tool to the latest version
       */
      async update(toolSpec) {
        const tool = this.parseToolSpec(toolSpec);
        tool.version = "latest";
        await this.install(`${tool.org}/${tool.name}@latest`, { force: true });
      }
      /**
       * Parse tool specification string
       */
      parseToolSpec(spec) {
        const match = spec.match(/^([^/]+)\/([^@]+)(?:@(.+))?$/);
        if (!match) {
          throw new Error(`Invalid tool specification: ${spec}`);
        }
        return {
          org: match[1],
          name: match[2],
          version: match[3]
        };
      }
      /**
       * Install tool to filesystem
       */
      async installToFilesystem(tool, version, content) {
        const toolDir = path10.join(this.toolsDir, tool.org, tool.name, version);
        const toolFile = path10.join(toolDir, "index.js");
        await fs8.mkdir(toolDir, { recursive: true });
        await fs8.writeFile(toolFile, content);
        const currentLink = path10.join(this.toolsDir, tool.org, tool.name, "current");
        try {
          await fs8.unlink(currentLink);
        } catch {
        }
        await fs8.symlink(version, currentLink);
        return toolFile;
      }
      /**
       * Extract tool content from download buffer
       */
      async extractToolContent(buffer, tool) {
        if (buffer[0] === 31 && buffer[1] === 139) {
          debug.log(`[Installer] Extracting tar.gz for ${tool.org}/${tool.name}`);
          try {
            const zlib = await import("zlib");
            const gunzipped = await new Promise((resolve, reject) => {
              zlib.gunzip(buffer, (err, result) => {
                if (err) reject(err);
                else resolve(result);
              });
            });
            const targetPath = `${tool.org}/${tool.name}/index.js`;
            const files = this.parseTar(gunzipped);
            const toolFile = files.find((f) => f.name.endsWith(targetPath));
            if (toolFile) {
              return toolFile.content;
            }
            const indexFile = files.find((f) => f.name.endsWith("index.js"));
            if (indexFile) {
              return indexFile.content;
            }
            throw new Error("No index.js found in archive");
          } catch (error) {
            debug.error("[Installer] Failed to extract tar.gz:", error);
            throw new Error(`Failed to extract tool: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
        return buffer;
      }
      /**
       * Simple tar parser (basic implementation)
       */
      parseTar(buffer) {
        const files = [];
        let offset = 0;
        while (offset < buffer.length) {
          const header = buffer.slice(offset, offset + 512);
          offset += 512;
          if (header.every((b) => b === 0)) break;
          const nameEnd = header.indexOf(0);
          const name = header.slice(0, nameEnd > 0 ? nameEnd : 100).toString("utf8").trim();
          const sizeStr = header.slice(124, 135).toString("utf8").trim();
          const size = parseInt(sizeStr, 8) || 0;
          if (name && size > 0) {
            const content = buffer.slice(offset, offset + size);
            files.push({ name, content });
          }
          offset += Math.ceil(size / 512) * 512;
        }
        return files;
      }
      /**
       * Load manifest file
       */
      async loadManifest() {
        try {
          const content = await fs8.readFile(this.manifestPath, "utf-8");
          return JSON.parse(content);
        } catch {
          return {
            version: "1.0.0",
            installedTools: [],
            lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
          };
        }
      }
      /**
       * Save manifest file
       */
      async saveManifest(manifest) {
        manifest.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
        await fs8.mkdir(path10.dirname(this.manifestPath), { recursive: true });
        await fs8.writeFile(this.manifestPath, JSON.stringify(manifest, null, 2));
      }
      /**
       * Update manifest with new tool
       */
      async updateManifest(tool, version, installPath) {
        const manifest = await this.loadManifest();
        const existingIndex = manifest.installedTools.findIndex(
          (t) => t.org === tool.org && t.name === tool.name
        );
        if (existingIndex >= 0) {
          manifest.installedTools.splice(existingIndex, 1);
        }
        manifest.installedTools.push({
          org: tool.org,
          name: tool.name,
          version,
          installedAt: (/* @__PURE__ */ new Date()).toISOString(),
          path: installPath
        });
        await this.saveManifest(manifest);
      }
      /**
       * Get current Clanker version
       */
      async getClankerVersion() {
        try {
          const possiblePaths = [
            path10.join(__dirname, "package.json"),
            path10.join(__dirname, "..", "package.json"),
            path10.join(__dirname, "..", "..", "package.json"),
            path10.join(process.cwd(), "package.json")
          ];
          for (const packagePath of possiblePaths) {
            try {
              const content = await fs8.readFile(packagePath, "utf-8");
              const pkg = JSON.parse(content);
              if (pkg.name === "@ziggler/clanker") {
                return pkg.version;
              }
            } catch {
            }
          }
          return "0.1.1";
        } catch {
          return "0.1.1";
        }
      }
    };
  }
});

// src/package-manager/publisher.ts
var publisher_exports = {};
__export(publisher_exports, {
  publishTool: () => publishTool
});
import * as fs9 from "fs/promises";
import * as path11 from "path";
import { exec } from "child_process";
import { promisify } from "util";
import open from "open";
async function publishTool() {
  console.log("\u{1F680} Publishing tool to Clanker registry...\n");
  try {
    const packageJsonPath = path11.join(process.cwd(), "package.json");
    let packageJson;
    try {
      const content = await fs9.readFile(packageJsonPath, "utf8");
      packageJson = JSON.parse(content);
    } catch (error) {
      console.error("\u274C Error: No package.json found in current directory");
      console.error("   Make sure you run this command from your tool project directory");
      process.exit(1);
    }
    const toolName = packageJson.name.replace(/^.*-clanker-tool-/, "");
    const org = packageJson.name.match(/^(.*)-clanker-tool-/)?.[1] || "community";
    const version = packageJson.version || "1.0.0";
    const description = packageJson.description || "";
    const author = packageJson.author || "Unknown";
    console.log("\u{1F4CB} Tool Information:");
    console.log(`   Name: ${toolName}`);
    console.log(`   Organization: ${org}`);
    console.log(`   Version: ${version}`);
    console.log(`   Author: ${author}
`);
    console.log("\u{1F50D} Validating project structure...\n");
    try {
      const { stdout } = await execAsync("npm run validate-tool 2>&1 || true");
      console.log(stdout);
      try {
        await execAsync("npm run validate-tool");
      } catch (validationError) {
        console.error("\n\u274C Validation failed. Fix issues before publishing.");
        process.exit(1);
      }
    } catch (error) {
      console.log("\u26A0\uFE0F  No validate-tool script found, doing basic checks...\n");
      const srcPath = path11.join(process.cwd(), "src");
      try {
        await fs9.access(srcPath);
        const srcFiles = await fs9.readdir(srcPath);
        if (srcFiles.length === 0) {
          throw new Error("src directory is empty");
        }
        console.log("\u2705 Source files found in src/");
      } catch (error2) {
        console.error("\u274C Error: src directory not found or empty");
        console.error("   Your tool source code must be in the src/ directory");
        process.exit(1);
      }
    }
    const readmePath = path11.join(process.cwd(), "README.md");
    let readmeContent = "";
    try {
      readmeContent = await fs9.readFile(readmePath, "utf8");
    } catch {
      console.warn("\u26A0\uFE0F  Warning: No README.md found, creating a basic one");
      readmeContent = `# ${toolName}

${description}

A Clanker tool by ${author}.`;
    }
    const manifest = {
      id: toolName.replace(/-/g, "_"),
      name: toolName,
      version,
      description,
      author,
      repository: `https://github.com/${org}/${packageJson.name}`,
      homepage: packageJson.homepage || "",
      keywords: packageJson.keywords || ["clanker", "tool"],
      created: (/* @__PURE__ */ new Date()).toISOString(),
      updated: (/* @__PURE__ */ new Date()).toISOString()
    };
    const prBody = `## \u{1F527} New Tool: ${toolName}

### Description
${description}

### Author
${author}

### Version
${version}

### Tool Details
- **ID**: \`${manifest.id}\`
- **Organization**: \`${org}\`
- **Keywords**: ${manifest.keywords.join(", ")}

### Source Code Structure
- \u2705 Source code in \`src/\` directory
- \u2705 Build configuration in \`package.json\`
- \u2705 No compiled files included (bin/ directory excluded)

### Build Verification
- \u2705 \`npm install\` runs successfully
- \u2705 \`npm run build\` completes without errors
- \u2705 Tool can be bundled for distribution

### Checklist
- [ ] Tool follows naming conventions
- [ ] Source code is in src/ directory
- [ ] No compiled/bundled files included
- [ ] package.json has build script
- [ ] README.md is complete
- [ ] Tool has been tested locally
- [ ] Code is readable and maintainable

### Files to Add
- \`tools/${org}/${toolName}/src/\` (all source files)
- \`tools/${org}/${toolName}/package.json\`
- \`tools/${org}/${toolName}/README.md\`
- \`tools/${org}/${toolName}/tsconfig.json\` (if using TypeScript)

### Note
The \`bin/\` directory will be automatically generated during the CI/CD build process after merge.
`;
    const prTitle = `Add ${toolName} tool by ${author}`;
    const encodedTitle = encodeURIComponent(prTitle);
    const encodedBody = encodeURIComponent(prBody);
    const baseRepo = "ziggle-dev/clanker-tools";
    const prUrl = `https://github.com/${baseRepo}/compare/main...main?quick_pull=1&title=${encodedTitle}&body=${encodedBody}`;
    console.log("\u{1F4DD} Publishing Instructions:\n");
    console.log("1. Fork the clanker-tools repository:");
    console.log(`   https://github.com/${baseRepo}
`);
    console.log("2. Create the following directory structure in your fork:");
    console.log(`   tools/${org}/${toolName}/`);
    console.log(`   tools/${org}/${toolName}/${version}/
`);
    console.log("3. Copy your project structure:");
    console.log(`   - tools/${org}/${toolName}/src/ (all source files)`);
    console.log(`   - tools/${org}/${toolName}/package.json`);
    console.log(`   - tools/${org}/${toolName}/README.md`);
    console.log(`   - tools/${org}/${toolName}/tsconfig.json (if using TypeScript)`);
    console.log(`
   \u26A0\uFE0F  Do NOT include:`);
    console.log(`   - node_modules/`);
    console.log(`   - bin/ or dist/ directories`);
    console.log(`   - Any compiled/bundled files
`);
    console.log("4. Commit and push to your fork\n");
    console.log("5. Create a pull request\n");
    const manifestPath = path11.join(process.cwd(), "clanker-manifest.json");
    await fs9.writeFile(manifestPath, JSON.stringify(manifest, null, 2));
    console.log(`\u2705 Manifest saved to: ${manifestPath}
`);
    console.log("\u{1F310} Opening GitHub in your browser...");
    console.log("   (If it doesn't open, visit the URL manually)\n");
    await open(`https://github.com/${baseRepo}`);
    console.log("\u{1F4CB} PR Template (copy this for your PR):");
    console.log("\u2500".repeat(60));
    console.log(prBody);
    console.log("\u2500".repeat(60));
  } catch (error) {
    console.error("\u274C Error publishing tool:", error);
    process.exit(1);
  }
}
var execAsync;
var init_publisher = __esm({
  "src/package-manager/publisher.ts"() {
    init_esm_shims();
    execAsync = promisify(exec);
  }
});

// src/package-manager/core-tools.ts
var core_tools_exports = {};
__export(core_tools_exports, {
  CoreToolsManager: () => CoreToolsManager
});
import * as fs10 from "fs/promises";
import * as path12 from "path";
import * as os5 from "os";
var CORE_TOOLS, CoreToolsManager;
var init_core_tools = __esm({
  "src/package-manager/core-tools.ts"() {
    init_esm_shims();
    init_installer();
    init_debug_logger();
    CORE_TOOLS = [
      "clanker/bash",
      "clanker/pwd",
      "clanker/list",
      "clanker/read-file",
      "clanker/write-to-file",
      "clanker/remove",
      "clanker/search",
      "clanker/input",
      "clanker/summarize",
      "clanker/view-file",
      "clanker/multi-edit",
      "clanker/create-todo-list",
      "clanker/list-todos",
      "clanker/update-todo-list"
    ];
    CoreToolsManager = class {
      constructor() {
        this.installer = new ToolInstaller();
        this.coreToolsFile = path12.join(os5.homedir(), ".clanker", "core-tools-installed.json");
      }
      /**
       * Check if core tools are installed and install them if needed
       */
      async ensureCoreToolsInstalled() {
        try {
          debug.log("[CoreTools] Checking core tools installation...");
          const isInstalled = await this.checkInstallationStatus();
          if (isInstalled) {
            debug.log("[CoreTools] Core tools already installed");
            return;
          }
          console.log("\u{1F527} Installing core tools for first-time setup...");
          const results = await Promise.allSettled(
            CORE_TOOLS.map((tool) => this.installTool(tool))
          );
          const succeeded = results.filter((r) => r.status === "fulfilled").length;
          const failed = results.filter((r) => r.status === "rejected").length;
          if (failed > 0) {
            console.log(`\u26A0\uFE0F  Installed ${succeeded}/${CORE_TOOLS.length} core tools (${failed} failed)`);
            console.log("   You can manually install missing tools with: clanker --install <tool>");
          } else {
            console.log(`\u2705 Successfully installed all ${succeeded} core tools`);
          }
          await this.markAsInstalled();
        } catch (error) {
          debug.error("[CoreTools] Failed to ensure core tools:", error);
          console.error("\u26A0\uFE0F  Failed to install core tools. You can install them manually.");
        }
      }
      /**
       * Install a single tool
       */
      async installTool(toolSpec) {
        try {
          debug.log(`[CoreTools] Installing ${toolSpec}...`);
          await this.installer.install(toolSpec);
        } catch (error) {
          debug.error(`[CoreTools] Failed to install ${toolSpec}:`, error);
          throw error;
        }
      }
      /**
       * Check if core tools have been installed
       */
      async checkInstallationStatus() {
        try {
          const data = await fs10.readFile(this.coreToolsFile, "utf-8");
          const status = JSON.parse(data);
          return status.installed === true;
        } catch {
          return false;
        }
      }
      /**
       * Mark core tools as installed
       */
      async markAsInstalled() {
        const dir = path12.dirname(this.coreToolsFile);
        await fs10.mkdir(dir, { recursive: true });
        const status = {
          installed: true,
          version: "1.0.0",
          installedAt: (/* @__PURE__ */ new Date()).toISOString(),
          tools: CORE_TOOLS
        };
        await fs10.writeFile(this.coreToolsFile, JSON.stringify(status, null, 2));
      }
      /**
       * Force reinstall core tools
       */
      async reinstallCoreTools() {
        try {
          await fs10.unlink(this.coreToolsFile).catch(() => {
          });
          await this.ensureCoreToolsInstalled();
        } catch (error) {
          debug.error("[CoreTools] Failed to reinstall:", error);
          throw error;
        }
      }
      /**
       * Get list of core tools
       */
      getCoreTools() {
        return [...CORE_TOOLS];
      }
    };
  }
});

// src/ui/components/ClankerLogo.tsx
import React, { useState, useEffect } from "react";
import { Box, Text } from "ink";
import { useInput } from "ink";
async function streamText(text, setText) {
  let current = "";
  for (const char of text) {
    current += char;
    setText(current);
    await new Promise((resolve) => setTimeout(resolve, 30));
  }
}
function getFallbackText(category) {
  const fallbacks = {
    joke: [
      "**404**: Joke not found. *Please try again.*",
      "There are only **10** types of people: those who understand {green:binary}",
      "!false - It's {red:funny} because it's true"
    ],
    tech_fact: [
      "The first computer bug was an {yellow:actual moth}",
      "**CAPTCHA** stands for *Completely Automated Public Turing test*",
      "The {blue:@ symbol} was used to save space in email"
    ],
    dad_joke: [
      "Why do programmers prefer {gray:dark mode}? Light attracts **bugs**!",
      "I'd tell you a UDP joke, but you might *not get it*",
      "My code doesn't have bugs, it has {red:surprise features}"
    ],
    inspirational: [
      "For the *tinkerers* and **makers** in all of us",
      "Build things that make you {yellow:smile}",
      "Every expert was once a {green:beginner}",
      "**Create**, *iterate*, and never stop {blue:learning}"
    ],
    dark_humor: [
      "We're all just {gray:biological computers} running on anxiety",
      "AI will replace us all... *eventually*",
      "Your code will outlive you. {red:Plan accordingly.}"
    ]
  };
  const options = fallbacks[category] || fallbacks.inspirational;
  return options[Math.floor(Math.random() * options.length)];
}
function parseMarkdownToJSX(text) {
  const parts = [];
  let currentIndex = 0;
  let key = 0;
  const patterns = [
    { regex: /\*\*(.*?)\*\*/g, style: "bold" },
    { regex: /\*(.*?)\*/g, style: "italic" },
    { regex: /\{(\w+):(.*?)\}/g, style: "color" }
  ];
  const allMatches = [];
  patterns.forEach(({ regex, style }) => {
    let match;
    while ((match = regex.exec(text)) !== null) {
      if (style === "color") {
        allMatches.push({
          index: match.index,
          length: match[0].length,
          content: match[2],
          style,
          color: match[1]
        });
      } else {
        allMatches.push({
          index: match.index,
          length: match[0].length,
          content: match[1],
          style
        });
      }
    }
  });
  allMatches.sort((a, b) => a.index - b.index);
  allMatches.forEach((match) => {
    if (match.index > currentIndex) {
      parts.push(/* @__PURE__ */ React.createElement(Text, { key: key++ }, text.substring(currentIndex, match.index)));
    }
    switch (match.style) {
      case "bold":
        parts.push(/* @__PURE__ */ React.createElement(Text, { key: key++, bold: true }, match.content));
        break;
      case "italic":
        parts.push(/* @__PURE__ */ React.createElement(Text, { key: key++, italic: true }, match.content));
        break;
      case "color":
        parts.push(/* @__PURE__ */ React.createElement(Text, { key: key++, color: match.color }, match.content));
        break;
    }
    currentIndex = match.index + match.length;
  });
  if (currentIndex < text.length) {
    parts.push(/* @__PURE__ */ React.createElement(Text, { key: key++ }, text.substring(currentIndex)));
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, parts);
}
var DynamicContent, ClankerLogo;
var init_ClankerLogo = __esm({
  "src/ui/components/ClankerLogo.tsx"() {
    init_esm_shims();
    DynamicContent = ({ agent, onReady }) => {
      const [displayText, setDisplayText] = useState("");
      const [isStreaming, setIsStreaming] = useState(true);
      const [hasFetched, setHasFetched] = useState(false);
      useEffect(() => {
        if (hasFetched) return;
        const fetchContent = async () => {
          setHasFetched(true);
          const categories = ["joke", "tech_fact", "dad_joke", "inspirational", "dark_humor"];
          const weights = [30, 25, 25, 19, 1];
          const random = Math.random() * 100;
          let accumulated = 0;
          let selectedCategory = "inspirational";
          for (let i = 0; i < weights.length; i++) {
            accumulated += weights[i];
            if (random < accumulated) {
              selectedCategory = categories[i];
              break;
            }
          }
          if (!agent) {
            const fallback = getFallbackText(selectedCategory);
            await streamText(fallback, setDisplayText);
            setIsStreaming(false);
            await new Promise((resolve) => setTimeout(resolve, 5e3));
            if (onReady) onReady();
            return;
          }
          try {
            const prompts = {
              joke: "Tell me a very short programmer joke (max 10 words). Be witty and clever.",
              tech_fact: "Share a fascinating tech or robot fact (max 15 words). Make it mind-blowing.",
              dad_joke: "Tell me a tech-related dad joke (max 10 words). Make it groan-worthy.",
              inspirational: "Give an inspirational quote for makers and tinkerers (max 10 words). Be motivating.",
              dark_humor: "Share a darkly humorous tech observation (max 12 words). Be subtly existential."
            };
            const stream = await agent.chat([
              { role: "user", content: prompts[selectedCategory] }
            ], "", true);
            let fullText = "";
            if (typeof stream === "string") {
              fullText = stream;
              await streamText(fullText, setDisplayText);
            } else {
              for await (const chunk of stream) {
                if (chunk.type === "content" && chunk.content) {
                  for (const char of chunk.content) {
                    fullText += char;
                    setDisplayText(fullText);
                    await new Promise((resolve) => setTimeout(resolve, 30));
                  }
                }
              }
            }
            setIsStreaming(false);
            await new Promise((resolve) => setTimeout(resolve, 5e3));
            if (onReady) onReady();
          } catch (error) {
            const fallback = getFallbackText(selectedCategory);
            await streamText(fallback, setDisplayText);
            setIsStreaming(false);
            await new Promise((resolve) => setTimeout(resolve, 5e3));
            if (onReady) onReady();
          }
        };
        fetchContent();
      }, []);
      return /* @__PURE__ */ React.createElement(Text, null, parseMarkdownToJSX(displayText));
    };
    ClankerLogo = ({ agent, onComplete }) => {
      const [shouldSkip, setShouldSkip] = useState(false);
      const [contentReady, setContentReady] = useState(false);
      const [minimumTimeElapsed, setMinimumTimeElapsed] = useState(false);
      const [colorIndex, setColorIndex] = useState(0);
      const [isVisible, setIsVisible] = useState(true);
      const colors = ["red", "yellow", "green", "cyan", "blue", "magenta"];
      useInput((input, key) => {
        if (key.escape) {
          setShouldSkip(true);
        }
      });
      useEffect(() => {
        const colorInterval = setInterval(() => {
          setColorIndex((prev) => (prev + 1) % colors.length);
        }, 200);
        return () => clearInterval(colorInterval);
      }, []);
      useEffect(() => {
        const timer = setTimeout(() => {
          setMinimumTimeElapsed(true);
        }, 5e3);
        return () => clearTimeout(timer);
      }, []);
      useEffect(() => {
        if (shouldSkip && onComplete) {
          setIsVisible(false);
          onComplete();
          return;
        }
        if (contentReady && minimumTimeElapsed && onComplete) {
          setIsVisible(false);
          onComplete();
        }
      }, [onComplete, shouldSkip, contentReady, minimumTimeElapsed]);
      if (!isVisible) {
        return null;
      }
      return /* @__PURE__ */ React.createElement(Box, { flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100%" }, /* @__PURE__ */ React.createElement(
        Box,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderColor: colors[colorIndex],
          paddingX: 3,
          paddingY: 2
        },
        /* @__PURE__ */ React.createElement(Box, { flexDirection: "column", alignItems: "center" }, /* @__PURE__ */ React.createElement(Box, { marginBottom: 1 }, /* @__PURE__ */ React.createElement(Text, { color: colors[colorIndex] }, " \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \n", "\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2554\u255D\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \n", "\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2554\u255D \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D \n", "\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u255A\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u255D  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \n", "\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255A\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551 \n", " \u255A\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D ")), /* @__PURE__ */ React.createElement(Box, { justifyContent: "center", paddingX: 2, paddingY: 1 }, /* @__PURE__ */ React.createElement(DynamicContent, { agent, onReady: () => setContentReady(true) })))
      ), /* @__PURE__ */ React.createElement(Box, { marginTop: 1 }, /* @__PURE__ */ React.createElement(Text, { dimColor: true }, "Press ESC to skip...")));
    };
  }
});

// src/ui/components/chat/ChatLayout.tsx
import React2 from "react";
import { Box as Box2 } from "ink";
var ChatLayout;
var init_ChatLayout = __esm({
  "src/ui/components/chat/ChatLayout.tsx"() {
    init_esm_shims();
    ChatLayout = React2.memo(({ children }) => {
      return /* @__PURE__ */ React2.createElement(Box2, { flexDirection: "column", width: "100%", height: "100%" }, /* @__PURE__ */ React2.createElement(Box2, { flexGrow: 1, overflow: "hidden" }, children));
    });
  }
});

// src/ui/components/command-suggestions.tsx
import React3 from "react";
import { Box as Box3, Text as Text3 } from "ink";
import { useSnapshot } from "valtio";
function CommandSuggestions() {
  const snap = useSnapshot(store);
  const inputValue = snap.inputValue;
  const showCommandSuggestions = snap.showCommandSuggestions;
  const selectedCommandIndex = snap.selectedCommandIndex;
  const commandSuggestions = snap.commandSuggestions;
  if (!showCommandSuggestions) return null;
  const parsedSuggestions = commandSuggestions.map((s) => {
    const [command, ...descParts] = s.split(" - ");
    return { command, description: descParts.join(" - ") };
  });
  const filteredSuggestions = parsedSuggestions.filter(
    (suggestion) => inputValue.startsWith("/") ? suggestion.command.startsWith("/") : suggestion.command.toLowerCase().startsWith(inputValue.toLowerCase())
  ).slice(0, 8);
  return /* @__PURE__ */ React3.createElement(Box3, { marginTop: 1, flexDirection: "column" }, filteredSuggestions.map((suggestion, index) => /* @__PURE__ */ React3.createElement(Box3, { key: index, paddingLeft: 1 }, /* @__PURE__ */ React3.createElement(
    Text3,
    {
      color: index === selectedCommandIndex ? "black" : "white",
      backgroundColor: index === selectedCommandIndex ? "cyan" : void 0
    },
    suggestion.command
  ), /* @__PURE__ */ React3.createElement(Box3, { marginLeft: 1 }, /* @__PURE__ */ React3.createElement(Text3, { color: "gray" }, suggestion.description)))), /* @__PURE__ */ React3.createElement(Box3, { marginTop: 1 }, /* @__PURE__ */ React3.createElement(Text3, { color: "gray", dimColor: true }, "\u2191\u2193 navigate \u2022 Enter/Tab select \u2022 Esc cancel")));
}
var init_command_suggestions = __esm({
  "src/ui/components/command-suggestions.tsx"() {
    init_esm_shims();
    init_store2();
  }
});

// src/ui/utils/markdown-renderer.tsx
import React4 from "react";
import { Box as Box4, Text as Text4 } from "ink";
import { marked } from "marked";
import TerminalRenderer from "marked-terminal";
var MarkdownRenderer;
var init_markdown_renderer = __esm({
  "src/ui/utils/markdown-renderer.tsx"() {
    init_esm_shims();
    marked.setOptions({
      renderer: new TerminalRenderer({
        showSectionPrefix: false,
        width: 80,
        reflowText: true,
        tab: 2,
        firstHeading: (text) => text,
        codespan: (text) => `\x1B[36m${text}\x1B[0m`,
        // Cyan for inline code
        code: (code) => `\x1B[90m${code}\x1B[0m`
        // Gray for code blocks
      })
    });
    MarkdownRenderer = React4.memo(function MarkdownRenderer2({ content, streamingCursor = false }) {
      const rendered = React4.useMemo(() => {
        try {
          return marked.parse(content);
        } catch (error) {
          console.error("[MarkdownRenderer] Error parsing markdown:", error);
          return content;
        }
      }, [content]);
      const lines = React4.useMemo(() => {
        const allLines = rendered.split("\n");
        const MAX_LINES = 500;
        if (allLines.length > MAX_LINES) {
          return [...allLines.slice(0, MAX_LINES - 1), `... (${allLines.length - MAX_LINES} more lines)`];
        }
        return allLines;
      }, [rendered]);
      return /* @__PURE__ */ React4.createElement(Box4, { flexDirection: "column", width: "100%" }, lines.map((line, index) => {
        const isLastLine = index === lines.length - 1;
        if (line === "") {
          return /* @__PURE__ */ React4.createElement(Text4, { key: index }, " ");
        }
        return /* @__PURE__ */ React4.createElement(Text4, { key: index, wrap: "wrap" }, line, isLastLine && streamingCursor && /* @__PURE__ */ React4.createElement(Text4, { color: "cyan" }, "\u2588"));
      }));
    }, (prevProps, nextProps) => {
      return prevProps.content === nextProps.content && prevProps.streamingCursor === nextProps.streamingCursor;
    });
  }
});

// src/ui/components/VirtualScroll.tsx
import React5, { useMemo } from "react";
import { Box as Box5, Text as Text5 } from "ink";
var VirtualScroll;
var init_VirtualScroll = __esm({
  "src/ui/components/VirtualScroll.tsx"() {
    init_esm_shims();
    VirtualScroll = ({
      children,
      maxHeight,
      estimatedItemHeight = 3,
      getItemHeight
    }) => {
      const visibleItems = useMemo(() => {
        if (!children || children.length === 0) return [];
        const items = [];
        let currentHeight = 0;
        for (let i = children.length - 1; i >= 0; i--) {
          const itemHeight = getItemHeight ? getItemHeight(i) : estimatedItemHeight;
          if (currentHeight + itemHeight > maxHeight - 2) {
            break;
          }
          items.unshift(children[i]);
          currentHeight += itemHeight;
        }
        return items;
      }, [children, maxHeight, estimatedItemHeight, getItemHeight]);
      const hiddenCount = children.length - visibleItems.length;
      return /* @__PURE__ */ React5.createElement(Box5, { flexDirection: "column", height: maxHeight, overflow: "hidden", flexShrink: 0 }, hiddenCount > 0 && /* @__PURE__ */ React5.createElement(Box5, { marginBottom: 1, flexShrink: 0 }, /* @__PURE__ */ React5.createElement(Text5, { color: "gray", dimColor: true }, "\u2191 ", hiddenCount, " earlier message", hiddenCount > 1 ? "s" : "")), /* @__PURE__ */ React5.createElement(Box5, { flexDirection: "column", flexGrow: 1, overflow: "hidden", justifyContent: "flex-end" }, visibleItems));
    };
  }
});

// src/ui/components/chat-history.tsx
import React6, { useCallback } from "react";
import { Box as Box6, Text as Text6, useStdout } from "ink";
import { useSnapshot as useSnapshot2 } from "valtio";
import Gradient from "ink-gradient";
import BigText from "ink-big-text";
function formatToolExecution(toolName, args) {
  let primaryArg;
  switch (toolName) {
    case "bash":
      primaryArg = args.command;
      break;
    case "read_file":
    case "write_file":
    case "list":
      primaryArg = args.path || args.file_path;
      break;
    case "search":
      primaryArg = args.query;
      break;
    case "pwd":
      break;
    default:
      const firstArg = Object.values(args).find((v) => typeof v === "string");
      if (firstArg) {
        primaryArg = firstArg;
      }
  }
  if (primaryArg) {
    return /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement(Text6, { underline: true, color: "white" }, toolName), /* @__PURE__ */ React6.createElement(Text6, { color: "gray" }, " ~", ">", " "), /* @__PURE__ */ React6.createElement(Text6, { color: "cyan" }, primaryArg));
  }
  return /* @__PURE__ */ React6.createElement(Text6, { underline: true, color: "white" }, toolName);
}
function ChatHistory({
  messageRegistry: messageRegistry2,
  executionRegistry: executionRegistry2,
  toolRegistry,
  isConfirmationActive = false
}) {
  const snap = useSnapshot2(store);
  const messages = snap.messages;
  const { stdout } = useStdout();
  const terminalHeight = stdout?.rows || 30;
  const maxHeight = Math.max(5, terminalHeight - 12);
  const filteredMessages = isConfirmationActive ? messages.filter((msg) => {
    if (msg.role !== "tool" || !msg.toolCallId) return true;
    const execution = executionRegistry2.get(msg.toolCallId);
    return execution?.status !== "executing";
  }) : messages;
  const chatEntries = filteredMessages.map((entry, index) => {
    const execution = entry.toolCallId ? executionRegistry2.get(entry.toolCallId) : void 0;
    const previousEntry = index > 0 ? filteredMessages[index - 1] : void 0;
    return /* @__PURE__ */ React6.createElement(
      ChatEntry,
      {
        key: `${entry.id}-${execution?.status || "pending"}-${execution?.result ? "done" : "running"}`,
        entry,
        index,
        execution,
        toolRegistry,
        previousEntry
      }
    );
  });
  const getItemHeight = useCallback((index) => {
    const entry = filteredMessages[index];
    if (!entry) return 4;
    let baseHeight = 3;
    switch (entry.role) {
      case "user":
        baseHeight = 3;
        break;
      case "assistant":
        if (entry.content) {
          const lines = entry.content.split("\n").length;
          baseHeight = Math.min(lines + 4, 25);
        } else {
          baseHeight = 3;
        }
        break;
      case "tool":
        const execution = entry.toolCallId ? executionRegistry2.get(entry.toolCallId) : void 0;
        if (execution?.result?.output) {
          const outputLines = String(execution.result.output).split("\n").length;
          baseHeight = Math.min(outputLines + 5, 20);
        } else {
          baseHeight = 4;
        }
        break;
    }
    return baseHeight;
  }, [filteredMessages, executionRegistry2]);
  if (messages.length === 0) {
    return /* @__PURE__ */ React6.createElement(Box6, { flexDirection: "column", height: maxHeight, paddingX: 2 }, /* @__PURE__ */ React6.createElement(Box6, { paddingX: 2, flexShrink: 0, height: 8 }, /* @__PURE__ */ React6.createElement(Box6, { justifyContent: "center", marginBottom: 1 }, /* @__PURE__ */ React6.createElement(Gradient, { name: "passion" }, /* @__PURE__ */ React6.createElement(BigText, { text: "CLANK", font: "3d" }))), /* @__PURE__ */ React6.createElement(Box6, { flexDirection: "column", marginBottom: 0 }, /* @__PURE__ */ React6.createElement(Text6, { dimColor: true }, "Type your request in natural language. Type '/exit' or press Ctrl+C to quit."))));
  }
  if (snap.virtualScrollingEnabled) {
    return /* @__PURE__ */ React6.createElement(
      VirtualScroll,
      {
        maxHeight,
        estimatedItemHeight: 4,
        getItemHeight
      },
      chatEntries
    );
  } else {
    return /* @__PURE__ */ React6.createElement(Box6, { flexDirection: "column", overflow: "hidden", paddingX: 0 }, chatEntries);
  }
}
var shouldAddExtraSpacing, ChatEntry;
var init_chat_history = __esm({
  "src/ui/components/chat-history.tsx"() {
    init_esm_shims();
    init_store2();
    init_markdown_renderer();
    init_VirtualScroll();
    shouldAddExtraSpacing = (entry, previousEntry) => {
      if (!previousEntry) return false;
      if (previousEntry.role === "tool" && entry.role === "assistant") {
        return true;
      }
      if (previousEntry.role === "assistant" && previousEntry.toolCalls && entry.role === "tool") {
        return true;
      }
      return false;
    };
    ChatEntry = ({
      entry,
      index,
      execution,
      toolRegistry,
      previousEntry
    }) => {
      const extraSpacing = shouldAddExtraSpacing(entry, previousEntry);
      switch (entry.role) {
        case "user":
          return /* @__PURE__ */ React6.createElement(Box6, { key: index, flexDirection: "column", marginTop: extraSpacing ? 2 : 1, flexShrink: 0 }, /* @__PURE__ */ React6.createElement(Box6, null, /* @__PURE__ */ React6.createElement(Text6, { color: "gray" }, ">", " ", entry.content)));
        case "assistant":
          if (entry.toolCalls && entry.toolCalls.length > 0 && !entry.content?.trim() && !entry.metadata?.isStreaming) {
            return null;
          }
          return /* @__PURE__ */ React6.createElement(Box6, { key: index, flexDirection: "column", marginTop: extraSpacing ? 3 : 2, marginBottom: 1, flexShrink: 0 }, /* @__PURE__ */ React6.createElement(Box6, { flexDirection: "row", alignItems: "flex-start" }, /* @__PURE__ */ React6.createElement(Text6, { color: "white" }, "\u23FA "), /* @__PURE__ */ React6.createElement(Box6, { flexDirection: "column", flexGrow: 1 }, entry.content && entry.content.trim() ? /* @__PURE__ */ React6.createElement(
            MarkdownRenderer,
            {
              content: entry.content.trim(),
              streamingCursor: entry.metadata?.isStreaming === true
            }
          ) : entry.metadata?.isStreaming && /* @__PURE__ */ React6.createElement(Text6, { color: "cyan" }, "\u2588"))));
        case "tool":
          if (!execution) {
            return /* @__PURE__ */ React6.createElement(Box6, { key: index, flexDirection: "column", marginTop: extraSpacing ? 2 : 1, flexShrink: 0 }, /* @__PURE__ */ React6.createElement(Box6, null, /* @__PURE__ */ React6.createElement(Text6, { color: "magenta" }, "\u23FA"), /* @__PURE__ */ React6.createElement(Text6, null, " Tool execution pending...")));
          }
          const isExecuting = execution.status === "executing";
          const result = execution.result;
          const tool = toolRegistry.get(execution.toolName);
          if (tool?.definition?.renderResult) {
            const customRender = tool.definition.renderResult({
              toolName: execution.toolName,
              arguments: execution.arguments,
              result,
              isExecuting
            });
            if (customRender) {
              return /* @__PURE__ */ React6.createElement(Box6, { key: index, flexDirection: "column", marginTop: extraSpacing ? 2 : 1, marginBottom: 1, flexShrink: 0 }, /* @__PURE__ */ React6.createElement(Box6, null, /* @__PURE__ */ React6.createElement(Text6, { color: "magenta" }, "\u23FA"), /* @__PURE__ */ React6.createElement(Text6, null, " "), formatToolExecution(execution.toolName, execution.arguments)), /* @__PURE__ */ React6.createElement(Box6, { flexDirection: "column" }, customRender));
            }
          }
          return /* @__PURE__ */ React6.createElement(Box6, { key: index, flexDirection: "column", marginTop: extraSpacing ? 2 : 1, marginBottom: 1, flexShrink: 0 }, /* @__PURE__ */ React6.createElement(Box6, null, /* @__PURE__ */ React6.createElement(Text6, { color: "magenta" }, "\u23FA"), /* @__PURE__ */ React6.createElement(Text6, null, " "), formatToolExecution(execution.toolName, execution.arguments)), /* @__PURE__ */ React6.createElement(Box6, { marginLeft: 2, flexDirection: "column" }, isExecuting ? /* @__PURE__ */ React6.createElement(Text6, { color: "cyan" }, "\u23BF Executing...") : result ? result.success ? result.output ? /* @__PURE__ */ React6.createElement(Text6, { color: "gray" }, "\u23BF ", result.output) : /* @__PURE__ */ React6.createElement(Text6, { color: "green" }, "\u23BF Completed") : /* @__PURE__ */ React6.createElement(Text6, { color: "red" }, "\u23BF Error: ", result.error) : null));
        default:
          return null;
      }
    };
  }
});

// src/ui/components/chat/ChatInput.tsx
import React7 from "react";
import { Box as Box7, Text as Text7 } from "ink";
import { useSnapshot as useSnapshot3 } from "valtio";
var ChatInput;
var init_ChatInput = __esm({
  "src/ui/components/chat/ChatInput.tsx"() {
    init_esm_shims();
    init_store2();
    ChatInput = React7.memo(() => {
      const snap = useSnapshot3(store);
      const inputValue = snap.inputValue;
      const isProcessing = snap.isProcessing;
      const isStreaming = snap.isStreaming;
      return /* @__PURE__ */ React7.createElement(
        Box7,
        {
          borderStyle: "single",
          borderColor: "gray",
          borderTop: true,
          borderLeft: false,
          borderRight: false,
          borderBottom: false,
          paddingX: 2,
          paddingY: 0,
          marginTop: 1,
          marginBottom: 1,
          width: "100%"
        },
        /* @__PURE__ */ React7.createElement(Text7, { color: "gray" }, "\u276F "),
        /* @__PURE__ */ React7.createElement(Text7, null, inputValue, !isProcessing && !isStreaming && /* @__PURE__ */ React7.createElement(Text7, { color: "white" }, "\u2588"))
      );
    });
  }
});

// src/ui/components/chat/StatusBar.tsx
import React8 from "react";
import { Box as Box8, Text as Text8 } from "ink";
import { useSnapshot as useSnapshot4 } from "valtio";
var StatusBar;
var init_StatusBar = __esm({
  "src/ui/components/chat/StatusBar.tsx"() {
    init_esm_shims();
    init_store2();
    StatusBar = React8.memo(() => {
      const snap = useSnapshot4(store);
      const autoEditEnabled = snap.autoEditEnabled;
      const dbpEnabled = snap.dangerousBypassPermission;
      return /* @__PURE__ */ React8.createElement(Box8, { width: "100%", justifyContent: "space-between" }, /* @__PURE__ */ React8.createElement(Text8, { color: "gray" }, "Ctrl+C to exit"), /* @__PURE__ */ React8.createElement(Box8, null, autoEditEnabled && !dbpEnabled && /* @__PURE__ */ React8.createElement(Text8, { color: "cyan" }, "\u25B6 auto-edit: on"), dbpEnabled && /* @__PURE__ */ React8.createElement(Text8, { backgroundColor: "red", color: "white", bold: true }, " BYPASS ")));
    });
  }
});

// src/ui/components/chat-indicator.tsx
import React9, { useState as useState2, useEffect as useEffect2 } from "react";
import { Box as Box9, Text as Text9, useStdout as useStdout2 } from "ink";
import { useSnapshot as useSnapshot5 } from "valtio";
var ChatProgress;
var init_chat_indicator = __esm({
  "src/ui/components/chat-indicator.tsx"() {
    init_esm_shims();
    init_store2();
    ChatProgress = React9.memo(({ elapsedSeconds }) => {
      const snap = useSnapshot5(store);
      const hasExecutingTools = Array.from(snap.executions.values()).some(
        (execution) => execution.status === "executing"
      );
      const isActive = snap.isProcessing || snap.isStreaming || hasExecutingTools;
      const [progressFrame, setProgressFrame] = useState2(0);
      const [idleFrame, setIdleFrame] = useState2(0);
      const { stdout } = useStdout2();
      const terminalWidth = stdout.columns || 80;
      const loadingTextWidth = 25;
      const marginWidth = 4;
      const tokenDisplayWidth = snap.inputTokenCount > 0 || snap.outputTokenCount > 0 ? 25 : 0;
      const bracketsWidth = 2;
      const availableWidth = terminalWidth - loadingTextWidth - marginWidth - tokenDisplayWidth - bracketsWidth - 5;
      const maxBarWidth = Math.max(40, availableWidth);
      useEffect2(() => {
        if (!isActive) {
          setProgressFrame(0);
          return;
        }
        const totalTokens = snap.inputTokenCount + snap.outputTokenCount;
        const baseSpeed = 50;
        const tokenFactor = Math.max(1, Math.log10(totalTokens + 1));
        const animationSpeed = baseSpeed / tokenFactor;
        const progressInterval = setInterval(() => {
          setProgressFrame((prev) => (prev + 1) % 720);
        }, animationSpeed);
        return () => clearInterval(progressInterval);
      }, [isActive, snap.inputTokenCount, snap.outputTokenCount]);
      useEffect2(() => {
        if (!isActive) {
          setIdleFrame(0);
          return;
        }
        const idleInterval = setInterval(() => {
          setIdleFrame((prev) => (prev + 1) % 360);
        }, 30);
        return () => clearInterval(idleInterval);
      }, [isActive]);
      if (!isActive) return null;
      const createDotsPattern = () => {
        const dots2 = [];
        const dotCount = Math.min(maxBarWidth, 80);
        const inputTokens = snap.inputTokenCount;
        const outputTokens = snap.outputTokenCount;
        const totalTokens = inputTokens + outputTokens;
        const idleWave = Math.sin(idleFrame * 0.02) * 0.5 + 0.5;
        for (let i = 0; i < dotCount; i++) {
          const position = i / dotCount;
          let intensity = 0;
          let color = "gray";
          if (totalTokens > 0) {
            const wavePosition = progressFrame * 0.02 % 1;
            const distanceFromWave = Math.abs(position - wavePosition);
            const waveWidth = 0.3;
            if (distanceFromWave < waveWidth) {
              intensity = 1 - distanceFromWave / waveWidth;
              if (outputTokens > inputTokens) {
                color = "cyan";
              } else {
                color = "green";
              }
            }
          } else {
            intensity = idleWave * (1 - Math.abs(position - 0.5) * 2) * 0.6;
            color = "gray";
          }
          let dotChar = "\xB7";
          if (intensity > 0.8) {
            dotChar = "\u25CF";
          } else if (intensity > 0.6) {
            dotChar = "\u2022";
          } else if (intensity > 0.4) {
            dotChar = "\u25E6";
          } else if (intensity > 0.2) {
            dotChar = "\u2219";
          }
          dots2.push({
            char: dotChar,
            color,
            dim: intensity < 0.3
          });
        }
        return dots2;
      };
      const dots = createDotsPattern();
      const formatElapsedTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      };
      return /* @__PURE__ */ React9.createElement(Box9, { width: "100%" }, /* @__PURE__ */ React9.createElement(Text9, { color: "gray" }, "["), dots.map((dot, i) => /* @__PURE__ */ React9.createElement(Text9, { key: i, color: dot.color, dimColor: dot.dim }, dot.char)), /* @__PURE__ */ React9.createElement(Text9, { color: "gray" }, "]"), (snap.inputTokenCount > 0 || snap.outputTokenCount > 0) && /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(Text9, { color: "gray" }, " \u2022 "), snap.inputTokenCount > 0 && /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(Text9, { color: "green", dimColor: true }, "\u2191", snap.inputTokenCount), snap.outputTokenCount > 0 && /* @__PURE__ */ React9.createElement(Text9, { color: "gray" }, " ")), snap.outputTokenCount > 0 && /* @__PURE__ */ React9.createElement(Text9, { color: "cyan", dimColor: true }, "\u2193", snap.outputTokenCount)), elapsedSeconds > 0 && /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(Text9, { color: "gray" }, " \u2022 "), /* @__PURE__ */ React9.createElement(Text9, { color: "gray", dimColor: true }, formatElapsedTime(elapsedSeconds))));
    });
  }
});

// src/ui/components/chat/LoadingAndStatus.tsx
import React10, { useState as useState3, useEffect as useEffect3, useMemo as useMemo2 } from "react";
import { Box as Box10, Text as Text10 } from "ink";
import { useSnapshot as useSnapshot6 } from "valtio";
var loadingTexts, spinnerFrames, LoadingAndStatus;
var init_LoadingAndStatus = __esm({
  "src/ui/components/chat/LoadingAndStatus.tsx"() {
    init_esm_shims();
    init_store2();
    init_chat_indicator();
    loadingTexts = [
      "Thinking.......",
      "Computing......",
      "Analyzing......",
      "Processing.....",
      "Calculating....",
      "Interfacing....",
      "Optimizing.....",
      "Synthesizing...",
      "Decrypting.....",
      "Calibrating....",
      "Bootstrapping..",
      "Synchronizing..",
      "Compiling......",
      "Downloading...."
    ];
    spinnerFrames = ["\u28F7", "\u28EF", "\u28DF", "\u287F", "\u28BF", "\u28FB", "\u28FD", "\u28FE"];
    LoadingAndStatus = React10.memo(() => {
      const snap = useSnapshot6(store);
      const hasExecutingTools = useMemo2(
        () => Array.from(snap.executions.values()).some(
          (execution) => execution.status === "executing"
        ),
        [snap.executions]
      );
      const isActive = snap.isProcessing || snap.isStreaming || hasExecutingTools;
      const [spinnerFrame, setSpinnerFrame] = useState3(0);
      const [loadingTextIndex, setLoadingTextIndex] = useState3(0);
      const [elapsedSeconds, setElapsedSeconds] = useState3(0);
      const [startTime, setStartTime] = useState3(null);
      useEffect3(() => {
        if (!isActive) {
          setLoadingTextIndex(Math.floor(Math.random() * loadingTexts.length));
          return;
        }
        const textInterval = setInterval(() => {
          setLoadingTextIndex((prev) => (prev + 1) % loadingTexts.length);
        }, 3e3);
        return () => clearInterval(textInterval);
      }, [isActive]);
      useEffect3(() => {
        if (!isActive) {
          setSpinnerFrame(0);
          return;
        }
        const spinnerInterval = setInterval(() => {
          setSpinnerFrame((prev) => (prev + 1) % spinnerFrames.length);
        }, 100);
        return () => clearInterval(spinnerInterval);
      }, [isActive]);
      useEffect3(() => {
        if (!isActive) {
          setElapsedSeconds(0);
          setStartTime(null);
          return;
        }
        if (!startTime) {
          setStartTime(Date.now());
        }
        const timerInterval = setInterval(() => {
          if (startTime) {
            setElapsedSeconds(Math.floor((Date.now() - startTime) / 1e3));
          }
        }, 1e3);
        return () => clearInterval(timerInterval);
      }, [isActive, startTime]);
      const currentLoadingText = loadingTexts[loadingTextIndex];
      return /* @__PURE__ */ React10.createElement(Box10, { width: "100%", marginTop: 1 }, isActive && /* @__PURE__ */ React10.createElement(Box10, { width: "100%", flexDirection: "row", justifyContent: "space-between" }, /* @__PURE__ */ React10.createElement(Box10, { flexDirection: "row", flexGrow: 1 }, /* @__PURE__ */ React10.createElement(Box10, { flexShrink: 0 }, /* @__PURE__ */ React10.createElement(Text10, { color: "cyan" }, spinnerFrames[spinnerFrame], " "), /* @__PURE__ */ React10.createElement(Text10, { color: "gray" }, currentLoadingText)), /* @__PURE__ */ React10.createElement(Box10, { marginLeft: 4, flexGrow: 1 }, /* @__PURE__ */ React10.createElement(ChatProgress, { elapsedSeconds })))));
    });
  }
});

// src/ui/components/model-selection.tsx
import React11 from "react";
import { Box as Box11, Text as Text11 } from "ink";
import { useSnapshot as useSnapshot7 } from "valtio";
var ModelSelection;
var init_model_selection = __esm({
  "src/ui/components/model-selection.tsx"() {
    init_esm_shims();
    init_store2();
    ModelSelection = () => {
      const snap = useSnapshot7(store);
      const showModelSelection = snap.showModelSelection;
      const selectedModelIndex = snap.selectedModelIndex;
      const availableModels = snap.availableModels;
      const currentModel = snap.model || availableModels[0];
      if (!showModelSelection) return null;
      return /* @__PURE__ */ React11.createElement(Box11, { marginTop: 1, flexDirection: "column" }, /* @__PURE__ */ React11.createElement(Box11, { marginBottom: 1 }, /* @__PURE__ */ React11.createElement(Text11, { color: "cyan" }, "Select Grok Model (current: ", currentModel, "):")), availableModels.map((model, index) => /* @__PURE__ */ React11.createElement(Box11, { key: index, paddingLeft: 1 }, /* @__PURE__ */ React11.createElement(
        Text11,
        {
          color: index === selectedModelIndex ? "black" : "white",
          backgroundColor: index === selectedModelIndex ? "cyan" : void 0
        },
        model
      ))), /* @__PURE__ */ React11.createElement(Box11, { marginTop: 1 }, /* @__PURE__ */ React11.createElement(Text11, { color: "gray", dimColor: true }, "\u2191\u2193 navigate \u2022 Enter/Tab select \u2022 Esc cancel")));
    };
  }
});

// src/hooks/input/useMessageInput.ts
import { useCallback as useCallback2, useRef } from "react";
import { useSnapshot as useSnapshot8 } from "valtio";
var useMessageInput;
var init_useMessageInput = __esm({
  "src/hooks/input/useMessageInput.ts"() {
    init_esm_shims();
    init_store2();
    init_debug_logger();
    init_token_counter();
    useMessageInput = ({
      agent,
      messageRegistry: messageRegistry2,
      executionRegistry: executionRegistry2,
      processingStartTime
    }) => {
      const snap = useSnapshot8(store);
      const contentBufferRef = useRef({});
      const sendMessage = useCallback2(
        async (content) => {
          if (!content.trim() || !agent) return;
          const userMessage = {
            role: "user",
            content: content.trim()
          };
          messageRegistry2.addMessage(userMessage);
          const tokenCounter = new TokenCounter(snap.model || "grok-3-mini");
          tokenCounter.countTokens(userMessage.content);
          tokenCounter.dispose();
          actions.setInputValue("");
          actions.setProcessing(true);
          processingStartTime.current = Date.now();
          actions.updateTokenCount(0);
          actions.updateOutputTokenCount(0);
          let currentAssistantMessage = null;
          try {
            const messages = messageRegistry2.toGrokMessages();
            let systemPrompt = "";
            if (snap.autoEditEnabled) {
              systemPrompt += "\n\nIMPORTANT: Auto-edit mode is enabled. Work autonomously without asking for confirmation when making file edits. Proceed directly with implementing solutions and making necessary changes.";
            }
            systemPrompt += "\n\nWhen you have pending tasks in your todo list, work through them autonomously and systematically. Focus on completing tasks without repeatedly asking for confirmation or clarification unless absolutely necessary.";
            systemPrompt += "\n\nIMPORTANT: Use the summarize tool proactively in these situations:\n- When analyzing long files or documentation, summarize key points before proceeding\n- After completing multiple related tasks, summarize what was accomplished\n- When encountering verbose output or logs, summarize the essential information\n- Before presenting findings from research or file exploration, summarize the key insights\n- When dealing with complex codebases, summarize the structure and relationships\nThe summarize tool helps maintain clarity and ensures important information is highlighted efficiently.";
            const contextTokenCounter = new TokenCounter(snap.model || "grok-3-mini");
            const messageTokens = contextTokenCounter.countMessageTokens(messages);
            const systemPromptTokens = systemPrompt ? contextTokenCounter.countTokens(systemPrompt) : 0;
            const totalInputTokens = messageTokens + systemPromptTokens;
            actions.updateInputTokenCount(totalInputTokens);
            contextTokenCounter.dispose();
            debug.log(`[useMessageInput] Total input tokens: ${totalInputTokens} (messages: ${messageTokens}, system: ${systemPromptTokens})`);
            actions.setStreaming(true);
            actions.setProcessing(false);
            debug.log("[useMessageInput] Starting to stream response...");
            const response = await agent.chat(messages, systemPrompt || void 0, true);
            let hasToolCalls = false;
            if (typeof response === "string") {
              messageRegistry2.addMessage({
                role: "assistant",
                content: response
              });
            } else {
              for await (const chunk of response) {
                switch (chunk.type) {
                  case "content":
                    if (chunk.content) {
                      if (!currentAssistantMessage || hasToolCalls) {
                        debug.log("[useMessageInput] Creating new assistant message");
                        currentAssistantMessage = messageRegistry2.addMessage({
                          role: "assistant",
                          content: chunk.content,
                          // Start with first chunk
                          metadata: { isStreaming: true }
                        });
                        hasToolCalls = false;
                        contentBufferRef.current[currentAssistantMessage.id] = chunk.content;
                        debug.log(`[useMessageInput] Created message with initial content: ${chunk.content.substring(0, 50)}...`);
                        continue;
                      }
                      const messageId = currentAssistantMessage.id;
                      if (!contentBufferRef.current[messageId]) {
                        contentBufferRef.current[messageId] = messageRegistry2.getMessages().find((m) => m.id === messageId)?.content || "";
                        contentBufferRef.current[messageId] += chunk.content;
                        messageRegistry2.updateMessage(messageId, {
                          content: contentBufferRef.current[messageId]
                        });
                        debug.log(`[useMessageInput] First chunk displayed immediately for message ${messageId}`);
                      } else {
                        contentBufferRef.current[messageId] += chunk.content;
                        messageRegistry2.updateMessage(messageId, {
                          content: contentBufferRef.current[messageId]
                        });
                      }
                    }
                    break;
                  case "tool_calls":
                    if (chunk.toolCalls) {
                      hasToolCalls = true;
                      if (currentAssistantMessage) {
                        messageRegistry2.updateMessage(currentAssistantMessage.id, {
                          toolCalls: chunk.toolCalls,
                          metadata: { ...currentAssistantMessage.metadata, isStreaming: false }
                        });
                      }
                      for (const toolCall of chunk.toolCalls) {
                        messageRegistry2.addMessage({
                          role: "tool",
                          content: `Calling ${toolCall.function.name}...`,
                          toolCallId: toolCall.id
                        });
                        let args = {};
                        try {
                          args = JSON.parse(toolCall.function.arguments);
                        } catch (error) {
                          debug.error(`Failed to parse tool arguments for tracking: ${error}`);
                        }
                        executionRegistry2.start(
                          toolCall.id,
                          toolCall.function.name,
                          args
                        );
                      }
                    }
                    break;
                  case "tool_result":
                    if (chunk.toolCall && chunk.toolResult) {
                      executionRegistry2.complete(
                        chunk.toolCall.id,
                        chunk.toolResult
                      );
                      const toolMessage = messageRegistry2.getMessages().find(
                        (m) => m.toolCallId === chunk.toolCall?.id
                      );
                      if (toolMessage) {
                        messageRegistry2.updateMessage(toolMessage.id, {
                          content: chunk.toolResult.success ? `\u2713 ${chunk.toolCall.function.name} completed` : `\u2717 ${chunk.toolCall.function.name} failed: ${chunk.toolResult.error}`
                        });
                      }
                      currentAssistantMessage = null;
                    }
                    break;
                  case "token_count":
                    if (chunk.tokenCount !== void 0) {
                      actions.updateTokenCount(chunk.tokenCount);
                      if (currentAssistantMessage) {
                        const currentMsg = messageRegistry2.getMessages().find((m) => m.id === currentAssistantMessage.id);
                        if (currentMsg) {
                          messageRegistry2.updateMessage(currentAssistantMessage.id, {
                            metadata: {
                              ...currentMsg.metadata,
                              tokenCount: chunk.tokenCount
                            }
                          });
                        }
                      }
                    }
                    break;
                  case "done":
                    if (currentAssistantMessage) {
                      const messageId = currentAssistantMessage.id;
                      const finalContent = contentBufferRef.current[messageId];
                      const currentMsg = messageRegistry2.getMessages().find((m) => m.id === messageId);
                      if (finalContent) {
                        messageRegistry2.updateMessage(messageId, {
                          content: finalContent,
                          metadata: {
                            ...currentMsg?.metadata || {},
                            isStreaming: false,
                            processingTime: Date.now() - processingStartTime.current
                          }
                        });
                      } else {
                        messageRegistry2.updateMessage(messageId, {
                          metadata: {
                            ...currentMsg?.metadata || {},
                            isStreaming: false,
                            processingTime: Date.now() - processingStartTime.current
                          }
                        });
                      }
                      delete contentBufferRef.current[messageId];
                    }
                    actions.setStreaming(false);
                    actions.setProcessing(false);
                    debug.log("[useMessageInput] Stream complete, clearing processing flags");
                    return;
                }
              }
            }
          } catch (error) {
            messageRegistry2.addMessage({
              role: "system",
              content: `Error: ${error instanceof Error ? error.message : String(error)}`
            });
          } finally {
            actions.setProcessing(false);
            actions.setStreaming(false);
            processingStartTime.current = 0;
            contentBufferRef.current = {};
            const activeExecutions = Array.from(store.executions.values()).filter((e) => e.status === "executing");
            if (activeExecutions.length > 0) {
              debug.log(`[useMessageInput] Found ${activeExecutions.length} stuck executions, clearing...`);
              activeExecutions.forEach((exec2) => {
                actions.completeExecution(exec2.id, { success: true, output: "Execution completed" });
              });
            }
          }
        },
        [agent, messageRegistry2, executionRegistry2, processingStartTime]
      );
      return {
        sendMessage
      };
    };
  }
});

// src/utils/commands.ts
function getDefaultCommands() {
  return [
    {
      name: "help",
      description: "Show available commands",
      execute: ({ setChatHistory }) => {
        const helpMessage = `Available commands:
/help - Show this help message
/clear - Clear chat history
/model - Change AI model
/save - Save chat history to file
/load - Load chat history from file
/auto - Toggle auto-edit mode
/exit - Exit the application
/tools - List available tools
/stats - Show tool usage statistics`;
        setChatHistory((prev) => [
          ...prev,
          {
            id: `system-${Date.now()}`,
            role: "system",
            content: helpMessage,
            timestamp: /* @__PURE__ */ new Date()
          }
        ]);
      }
    },
    {
      name: "clear",
      description: "Clear chat history",
      execute: ({ setChatHistory }) => {
        setChatHistory([]);
      }
    },
    {
      name: "model",
      description: "Change AI model",
      execute: ({ setShowModelSelection }) => {
        if (setShowModelSelection) {
          setShowModelSelection(true);
        }
      }
    },
    {
      name: "save",
      description: "Save chat history to file",
      usage: "/save [filename]",
      execute: async ({ args, chatHistory, setChatHistory }) => {
        const filename = args || `chat-${Date.now()}.json`;
        try {
          const fs12 = await import("fs/promises");
          await fs12.writeFile(
            filename,
            JSON.stringify(chatHistory, null, 2),
            "utf-8"
          );
          setChatHistory((prev) => [
            ...prev,
            {
              id: `system-${Date.now()}`,
              role: "system",
              content: `Chat history saved to ${filename}`,
              timestamp: /* @__PURE__ */ new Date()
            }
          ]);
        } catch (error) {
          setChatHistory((prev) => [
            ...prev,
            {
              id: `system-${Date.now()}`,
              role: "system",
              content: `Error saving chat: ${error instanceof Error ? error.message : String(error)}`,
              timestamp: /* @__PURE__ */ new Date()
            }
          ]);
        }
      }
    },
    {
      name: "load",
      description: "Load chat history from file",
      usage: "/load <filename>",
      execute: async ({ args, setChatHistory }) => {
        if (!args) {
          setChatHistory((prev) => [
            ...prev,
            {
              id: `system-${Date.now()}`,
              role: "system",
              content: "Please provide a filename: /load <filename>",
              timestamp: /* @__PURE__ */ new Date()
            }
          ]);
          return;
        }
        try {
          const fs12 = await import("fs/promises");
          const data = await fs12.readFile(args, "utf-8");
          const loadedHistory = JSON.parse(data);
          setChatHistory(loadedHistory);
        } catch (error) {
          setChatHistory((prev) => [
            ...prev,
            {
              id: `system-${Date.now()}`,
              role: "system",
              content: `Error loading chat: ${error instanceof Error ? error.message : String(error)}`,
              timestamp: /* @__PURE__ */ new Date()
            }
          ]);
        }
      }
    },
    {
      name: "auto",
      description: "Toggle auto-edit mode",
      execute: ({ setAutoEditEnabled, setChatHistory }) => {
        if (setAutoEditEnabled) {
          setAutoEditEnabled((prev) => {
            const newValue = !prev;
            setChatHistory((history) => [
              ...history,
              {
                id: `system-${Date.now()}`,
                role: "system",
                content: `Auto-edit mode ${newValue ? "enabled" : "disabled"}`,
                timestamp: /* @__PURE__ */ new Date()
              }
            ]);
            return newValue;
          });
        }
      }
    },
    {
      name: "exit",
      description: "Exit the application",
      execute: () => {
        process.exit(0);
      }
    },
    {
      name: "tools",
      description: "List available tools",
      execute: ({ agent, setChatHistory }) => {
        const registry = agent.getRegistry();
        const tools = registry.list();
        const toolsList = tools.map((tool) => `\u2022 ${tool.name} (${tool.id}) - ${tool.description}`).join("\n");
        setChatHistory((prev) => [
          ...prev,
          {
            id: `system-${Date.now()}`,
            role: "system",
            content: `Available tools (${tools.length}):
${toolsList}`,
            timestamp: /* @__PURE__ */ new Date()
          }
        ]);
      }
    },
    {
      name: "stats",
      description: "Show tool usage statistics",
      execute: ({ agent, setChatHistory }) => {
        const stats = agent.getToolStats();
        let statsMessage = "Tool usage statistics:\n";
        const entries = Object.entries(stats);
        if (entries.length === 0) {
          statsMessage += "No tools have been used yet.";
        } else {
          entries.forEach(([toolId, toolStats]) => {
            if (toolStats.executionCount > 0) {
              statsMessage += `\u2022 ${toolId}: ${toolStats.executionCount} calls
`;
            }
          });
        }
        setChatHistory((prev) => [
          ...prev,
          {
            id: `system-${Date.now()}`,
            role: "system",
            content: statsMessage,
            timestamp: /* @__PURE__ */ new Date()
          }
        ]);
      }
    }
  ];
}
var init_commands = __esm({
  "src/utils/commands.ts"() {
    init_esm_shims();
  }
});

// src/hooks/input/useCommandInput.ts
import { useCallback as useCallback3, useEffect as useEffect4 } from "react";
import { useSnapshot as useSnapshot9 } from "valtio";
function useCommandInput({ agent, messageRegistry: messageRegistry2 }) {
  const confirmationService = ConfirmationService.getInstance();
  const commands = getDefaultCommands();
  const snap = useSnapshot9(store);
  const inputValue = snap.inputValue;
  const showCommandSuggestions = snap.showCommandSuggestions;
  const selectedCommandIndex = snap.selectedCommandIndex;
  const setShowCommandSuggestions = (show) => {
    store.showCommandSuggestions = show;
  };
  const setSelectedCommandIndex = (index) => {
    store.selectedCommandIndex = index;
  };
  const commandSuggestions = inputValue.startsWith(COMMAND_PREFIX) ? commands.filter(
    (cmd) => cmd.name.toLowerCase().startsWith(inputValue.slice(1).toLowerCase())
  ).map((cmd) => `${COMMAND_PREFIX}${cmd.name} - ${cmd.description}`) : [];
  useEffect4(() => {
    const shouldShow = inputValue.startsWith(COMMAND_PREFIX) && inputValue.length > 1 && commandSuggestions.length > 0;
    setShowCommandSuggestions(shouldShow);
    store.commandSuggestions = commandSuggestions;
  }, [inputValue, commandSuggestions.length, commandSuggestions]);
  const handleCommand = useCallback3(
    async (command) => {
      const parts = command.slice(1).split(" ");
      const cmdName = parts[0].toLowerCase();
      const args = parts.slice(1).join(" ");
      const cmd = commands.find((c) => c.name.toLowerCase() === cmdName);
      if (!cmd) {
        messageRegistry2.addMessage({
          role: "system",
          content: `Unknown command: ${command}`
        });
        return;
      }
      if (cmd.execute) {
        await cmd.execute({
          args,
          agent,
          chatHistory: messageRegistry2.getMessages(),
          setChatHistory: (fn) => {
            if (typeof fn === "function") {
              const currentMessages = messageRegistry2.getMessages();
              const newHistory = fn(currentMessages);
              messageRegistry2.clearMessages();
              newHistory.forEach((msg) => {
                if (msg.id && currentMessages.some((m) => m.id === msg.id)) {
                  const { id, ...msgWithoutId } = msg;
                  messageRegistry2.addMessage(msgWithoutId);
                } else {
                  const { id, ...msgWithoutId } = msg;
                  messageRegistry2.addMessage(msgWithoutId);
                }
              });
            } else if (Array.isArray(fn)) {
              messageRegistry2.clearMessages();
              fn.forEach((msg) => {
                const { id, ...msgWithoutId } = msg;
                messageRegistry2.addMessage(msgWithoutId);
              });
            }
          },
          setInput: actions.setInputValue,
          setShowModelSelection: actions.toggleModelSelector,
          setAutoEditEnabled: actions.setAutoEdit,
          confirmationService
        });
      }
    },
    [agent, messageRegistry2, confirmationService, commands]
  );
  const selectCommandSuggestion = useCallback3(() => {
    if (showCommandSuggestions && commandSuggestions.length > 0) {
      const selectedCommand = commandSuggestions[selectedCommandIndex];
      const cmdName = selectedCommand.split(" - ")[0];
      actions.setInputValue(cmdName);
      setShowCommandSuggestions(false);
      setSelectedCommandIndex(0);
    }
  }, [showCommandSuggestions, commandSuggestions, selectedCommandIndex]);
  const navigateCommandSuggestions = useCallback3((direction) => {
    if (!showCommandSuggestions) return;
    if (direction === "up") {
      setSelectedCommandIndex(
        selectedCommandIndex > 0 ? selectedCommandIndex - 1 : commandSuggestions.length - 1
      );
    } else {
      setSelectedCommandIndex(
        selectedCommandIndex < commandSuggestions.length - 1 ? selectedCommandIndex + 1 : 0
      );
    }
  }, [showCommandSuggestions, selectedCommandIndex, commandSuggestions.length]);
  const cancelCommandSuggestions = useCallback3(() => {
    if (showCommandSuggestions) {
      setShowCommandSuggestions(false);
      setSelectedCommandIndex(0);
    }
  }, [showCommandSuggestions]);
  return {
    showCommandSuggestions,
    selectedCommandIndex,
    commandSuggestions,
    handleCommand,
    selectCommandSuggestion,
    navigateCommandSuggestions,
    cancelCommandSuggestions,
    isCommand: inputValue.startsWith(COMMAND_PREFIX)
  };
}
var COMMAND_PREFIX;
var init_useCommandInput = __esm({
  "src/hooks/input/useCommandInput.ts"() {
    init_esm_shims();
    init_store2();
    init_commands();
    init_confirmation_service();
    COMMAND_PREFIX = "/";
  }
});

// src/hooks/input/useInputHistory.ts
import { useState as useState4, useCallback as useCallback4 } from "react";
import { useSnapshot as useSnapshot10 } from "valtio";
function useInputHistory({ messageRegistry: messageRegistry2 }) {
  const snap = useSnapshot10(store);
  const inputValue = snap.inputValue;
  const [historyIndex, setHistoryIndex] = useState4(null);
  const [currentInput, setCurrentInput] = useState4("");
  const navigateHistory = useCallback4((direction) => {
    const userMessages = messageRegistry2.getMessagesByRole("user");
    if (direction === "up") {
      if (userMessages.length > 0) {
        if (historyIndex === null) {
          setCurrentInput(inputValue);
          setHistoryIndex(userMessages.length - 1);
          actions.setInputValue(userMessages[userMessages.length - 1].content);
        } else if (historyIndex > 0) {
          setHistoryIndex(historyIndex - 1);
          actions.setInputValue(userMessages[historyIndex - 1].content);
        }
      }
    } else {
      if (historyIndex !== null) {
        if (historyIndex < userMessages.length - 1) {
          setHistoryIndex(historyIndex + 1);
          actions.setInputValue(userMessages[historyIndex + 1].content);
        } else {
          setHistoryIndex(null);
          actions.setInputValue(currentInput);
        }
      }
    }
  }, [messageRegistry2, inputValue, historyIndex, currentInput]);
  const resetHistory = useCallback4(() => {
    setHistoryIndex(null);
    setCurrentInput("");
  }, []);
  const saveToHistory = useCallback4((input) => {
    if (input.trim()) {
      actions.addToHistory(input);
    }
    resetHistory();
  }, [resetHistory]);
  return {
    navigateHistory,
    resetHistory,
    saveToHistory,
    isNavigatingHistory: historyIndex !== null
  };
}
var init_useInputHistory = __esm({
  "src/hooks/input/useInputHistory.ts"() {
    init_esm_shims();
    init_store2();
  }
});

// src/hooks/ui/useModelSelection.ts
import { useCallback as useCallback5 } from "react";
import { useSnapshot as useSnapshot11 } from "valtio";
function useModelSelection({ agent, messageRegistry: messageRegistry2 }) {
  const snap = useSnapshot11(store);
  const showModelSelection = snap.showModelSelection;
  const selectedModelIndex = snap.selectedModelIndex;
  const availableModels = snap.availableModels;
  const setShowModelSelection = (show) => {
    store.showModelSelection = show;
  };
  const setSelectedModelIndex = (index) => {
    store.selectedModelIndex = index;
  };
  const selectModel = useCallback5(() => {
    const selectedModel = availableModels[selectedModelIndex];
    agent.getClient().setModel(selectedModel);
    actions.setModel(selectedModel);
    messageRegistry2.addMessage({
      role: "system",
      content: `Model changed to ${selectedModel}`
    });
    setShowModelSelection(false);
    setSelectedModelIndex(0);
  }, [agent, messageRegistry2, selectedModelIndex, availableModels]);
  const navigateModelSelection = useCallback5((direction) => {
    if (!showModelSelection) return;
    if (direction === "up") {
      setSelectedModelIndex(
        selectedModelIndex > 0 ? selectedModelIndex - 1 : availableModels.length - 1
      );
    } else {
      setSelectedModelIndex(
        selectedModelIndex < availableModels.length - 1 ? selectedModelIndex + 1 : 0
      );
    }
  }, [showModelSelection, selectedModelIndex, availableModels.length]);
  const cancelModelSelection = useCallback5(() => {
    if (showModelSelection) {
      setShowModelSelection(false);
      setSelectedModelIndex(0);
    }
  }, [showModelSelection]);
  return {
    showModelSelection,
    selectedModelIndex,
    availableModels,
    selectModel,
    navigateModelSelection,
    cancelModelSelection
  };
}
var init_useModelSelection = __esm({
  "src/hooks/ui/useModelSelection.ts"() {
    init_esm_shims();
    init_store2();
  }
});

// src/hooks/useInputHandler.ts
import { useSnapshot as useSnapshot12 } from "valtio";
import { useCallback as useCallback6 } from "react";
var useInputHandler;
var init_useInputHandler = __esm({
  "src/hooks/useInputHandler.ts"() {
    init_esm_shims();
    init_store2();
    init_useMessageInput();
    init_useCommandInput();
    init_useInputHistory();
    init_useModelSelection();
    useInputHandler = ({
      agent,
      messageRegistry: messageRegistry2,
      executionRegistry: executionRegistry2,
      processingStartTime
    }) => {
      const snap = useSnapshot12(store);
      const inputValue = snap.inputValue;
      const autoEditEnabled = snap.autoEditEnabled;
      const { sendMessage } = useMessageInput({
        agent,
        messageRegistry: messageRegistry2,
        executionRegistry: executionRegistry2,
        processingStartTime
      });
      const {
        showCommandSuggestions,
        selectedCommandIndex,
        commandSuggestions,
        handleCommand,
        selectCommandSuggestion,
        navigateCommandSuggestions,
        cancelCommandSuggestions,
        isCommand
      } = useCommandInput({ agent, messageRegistry: messageRegistry2 });
      const {
        navigateHistory,
        saveToHistory
      } = useInputHistory({ messageRegistry: messageRegistry2 });
      const {
        showModelSelection,
        selectedModelIndex,
        availableModels,
        selectModel,
        navigateModelSelection,
        cancelModelSelection
      } = useModelSelection({ agent, messageRegistry: messageRegistry2 });
      const handleEnter = useCallback6(async () => {
        if (showCommandSuggestions) {
          selectCommandSuggestion();
        } else if (showModelSelection) {
          selectModel();
        } else if (inputValue.trim()) {
          if (isCommand) {
            await handleCommand(inputValue);
          } else {
            await sendMessage(inputValue);
          }
          saveToHistory(inputValue);
        }
      }, [
        showCommandSuggestions,
        showModelSelection,
        inputValue,
        isCommand,
        selectCommandSuggestion,
        selectModel,
        handleCommand,
        sendMessage,
        saveToHistory
      ]);
      const handleEscape = useCallback6(() => {
        if (showCommandSuggestions) {
          cancelCommandSuggestions();
        } else if (showModelSelection) {
          cancelModelSelection();
        } else {
          actions.setInputValue("");
        }
      }, [
        showCommandSuggestions,
        showModelSelection,
        cancelCommandSuggestions,
        cancelModelSelection
      ]);
      const handleUpArrow = useCallback6(() => {
        if (showCommandSuggestions) {
          navigateCommandSuggestions("up");
        } else if (showModelSelection) {
          navigateModelSelection("up");
        } else {
          navigateHistory("up");
        }
      }, [
        showCommandSuggestions,
        showModelSelection,
        navigateCommandSuggestions,
        navigateModelSelection,
        navigateHistory
      ]);
      const handleDownArrow = useCallback6(() => {
        if (showCommandSuggestions) {
          navigateCommandSuggestions("down");
        } else if (showModelSelection) {
          navigateModelSelection("down");
        } else {
          navigateHistory("down");
        }
      }, [
        showCommandSuggestions,
        showModelSelection,
        navigateCommandSuggestions,
        navigateModelSelection,
        navigateHistory
      ]);
      return {
        input: inputValue,
        showCommandSuggestions,
        selectedCommandIndex,
        showModelSelection,
        selectedModelIndex,
        commandSuggestions,
        availableModels,
        autoEditEnabled,
        handleEnter,
        handleEscape,
        handleUpArrow,
        handleDownArrow
      };
    };
  }
});

// src/hooks/useConfirmationHandler.ts
import { useEffect as useEffect5, useCallback as useCallback7 } from "react";
var useConfirmationHandler;
var init_useConfirmationHandler = __esm({
  "src/hooks/useConfirmationHandler.ts"() {
    init_esm_shims();
    init_store2();
    init_confirmation_service();
    init_types2();
    useConfirmationHandler = () => {
      const confirmationService = ConfirmationService.getInstance();
      useEffect5(() => {
        const handleConfirmationRequest = async (options) => {
          actions.pushStage({
            id: "tool-confirmation",
            type: "tool_confirmation" /* TOOL_CONFIRMATION */,
            props: {
              options,
              onConfirm: (result) => {
                confirmationService.confirmOperation(result.confirmed, result.dontAskAgain);
              },
              onReject: (result) => {
                confirmationService.rejectOperation(result.feedback);
              }
            }
          });
        };
        confirmationService.on("confirmation-requested", handleConfirmationRequest);
        return () => {
          confirmationService.off("confirmation-requested", handleConfirmationRequest);
        };
      }, [confirmationService]);
      const handleConfirmation = useCallback7((dontAskAgain) => {
        actions.respondToConfirmation({ confirmed: true, dontAskAgain });
      }, []);
      const handleRejection = useCallback7((feedback) => {
        actions.respondToConfirmation({ confirmed: false, feedback });
        actions.setProcessing(false);
        actions.setStreaming(false);
        actions.updateProcessingTime(0);
      }, []);
      return {
        handleConfirmation,
        handleRejection
      };
    };
  }
});

// src/hooks/useProcessingTimer.ts
import { useEffect as useEffect6, useRef as useRef2 } from "react";
import { useSnapshot as useSnapshot13 } from "valtio";
function useProcessingTimer() {
  const snap = useSnapshot13(store);
  const isProcessing = snap.isProcessing;
  const isStreaming = snap.isStreaming;
  const processingStartTime = useRef2(0);
  useEffect6(() => {
    let interval;
    if (isProcessing || isStreaming) {
      interval = setInterval(() => {
        if (processingStartTime.current > 0) {
          actions.updateProcessingTime(Date.now() - processingStartTime.current);
        }
      }, 100);
    }
    return () => clearInterval(interval);
  }, [isProcessing, isStreaming]);
  return {
    processingStartTime
  };
}
var init_useProcessingTimer = __esm({
  "src/hooks/useProcessingTimer.ts"() {
    init_esm_shims();
    init_store2();
  }
});

// src/registry/messages.ts
function createMessageRegistry() {
  return messageRegistry;
}
var messageRegistry, createRegistry;
var init_messages = __esm({
  "src/registry/messages.ts"() {
    init_esm_shims();
    init_store2();
    messageRegistry = {
      addMessage(message) {
        actions.addMessage(message);
        return store.messages[store.messages.length - 1];
      },
      updateMessage(id, updates) {
        actions.updateMessage(id, updates);
      },
      removeMessage(id) {
        const index = store.messages.findIndex((m) => m.id === id);
        if (index === -1) return;
        store.messages.splice(index, 1);
        store.messageCount = store.messages.length;
      },
      clearMessages() {
        actions.clearMessages();
      },
      getMessages() {
        return [...store.messages];
      },
      getMessage(id) {
        return store.messages.find((m) => m.id === id);
      },
      getMessagesByRole(role) {
        return store.messages.filter((m) => m.role === role);
      },
      getLastMessage() {
        return store.messages[store.messages.length - 1];
      },
      getLastMessageByRole(role) {
        for (let i = store.messages.length - 1; i >= 0; i--) {
          if (store.messages[i].role === role) {
            return store.messages[i];
          }
        }
        return void 0;
      },
      findMessageWithToolCall(toolCallId) {
        return store.messages.find(
          (m) => m.toolCalls?.some((tc) => tc.id === toolCallId)
        );
      },
      toGrokMessages() {
        return store.messages.map((msg) => {
          const grokMsg = {
            role: msg.role,
            content: msg.content
          };
          if (msg.toolCalls && msg.toolCalls.length > 0) {
            grokMsg.tool_calls = msg.toolCalls;
          }
          if (msg.role === "tool" && msg.toolCallId) {
            grokMsg.tool_call_id = msg.toolCallId;
          }
          return grokMsg;
        });
      },
      getStats() {
        const stats = {
          totalMessages: store.messages.length,
          messagesByRole: {
            user: 0,
            assistant: 0,
            tool: 0,
            system: 0
          },
          averageTokenCount: 0,
          totalTokenCount: 0
        };
        let tokenSum = 0;
        let tokenCount = 0;
        for (const msg of store.messages) {
          stats.messagesByRole[msg.role]++;
          if (msg.metadata?.tokenCount) {
            tokenSum += msg.metadata.tokenCount;
            tokenCount++;
          }
        }
        stats.totalTokenCount = tokenSum;
        stats.averageTokenCount = tokenCount > 0 ? tokenSum / tokenCount : 0;
        return stats;
      },
      // Streaming methods
      startStreaming(messageId) {
        actions.startStreaming(messageId);
      },
      appendToMessage(messageId, content) {
        actions.appendToMessage(messageId, content);
      },
      finishStreaming(messageId, metadata) {
        actions.finishStreaming(messageId, metadata);
      },
      addToolCalls(messageId, toolCalls) {
        actions.addToolCalls(messageId, toolCalls);
      }
    };
    createRegistry = createMessageRegistry;
  }
});

// src/registry/execution.ts
function createExecutionRegistry() {
  return executionRegistry;
}
var executionRegistry;
var init_execution = __esm({
  "src/registry/execution.ts"() {
    init_esm_shims();
    init_store2();
    executionRegistry = {
      start(id, toolName, args) {
        const executionId = actions.addExecution({
          toolName,
          arguments: args
        });
        store.toolCallToExecutionMap = store.toolCallToExecutionMap || /* @__PURE__ */ new Map();
        store.toolCallToExecutionMap.set(id, executionId);
      },
      complete(id, result) {
        const toolCallMap = store.toolCallToExecutionMap;
        const executionId = toolCallMap?.get(id) || id;
        if (result.success) {
          actions.completeExecution(executionId, result);
        } else {
          actions.failExecution(executionId, result.error || "Unknown error");
        }
      },
      get(id) {
        const toolCallMap = store.toolCallToExecutionMap;
        const executionId = toolCallMap?.get(id) || id;
        return actions.getExecution(executionId);
      },
      getHistory() {
        return Array.from(store.executions.values());
      },
      clear() {
        actions.clearExecutions();
      }
    };
  }
});

// src/hooks/useRegistries.ts
function useRegistries() {
  const messageRegistry2 = createRegistry();
  const executionRegistry2 = createExecutionRegistry();
  return {
    messageRegistry: messageRegistry2,
    executionRegistry: executionRegistry2
  };
}
var init_useRegistries = __esm({
  "src/hooks/useRegistries.ts"() {
    init_esm_shims();
    init_messages();
    init_execution();
  }
});

// src/ui/containers/ChatContainer.tsx
import React12, { useCallback as useCallback8, useRef as useRef3 } from "react";
import { Box as Box12, useInput as useInput2 } from "ink";
import { useSnapshot as useSnapshot14 } from "valtio";
function ChatContainer({ agent }) {
  const snap = useSnapshot14(store);
  const { messageRegistry: messageRegistry2, executionRegistry: executionRegistry2 } = useRegistries();
  const toolRegistry = agent.getRegistry();
  const { handleConfirmation, handleRejection } = useConfirmationHandler();
  const processingStartTime = useRef3(Date.now());
  useProcessingTimer();
  const {
    showCommandSuggestions,
    showModelSelection,
    handleEnter,
    handleEscape,
    handleUpArrow,
    handleDownArrow
  } = useInputHandler({
    agent,
    messageRegistry: messageRegistry2,
    executionRegistry: executionRegistry2,
    processingStartTime,
    confirmationOptions: snap.confirmationOptions
  });
  const confirmationService = ConfirmationService.getInstance();
  const handleCtrlC = useCallback8(() => {
    actions.pushStage({ id: "exit-confirmation", type: "exit_confirmation" /* EXIT_CONFIRMATION */ });
  }, []);
  const toggleAutoEdit = useCallback8(() => {
    const newAutoEditState = !snap.autoEditEnabled;
    actions.setAutoEdit(newAutoEditState);
  }, [snap.autoEditEnabled]);
  useInput2((inputChar, key) => {
    if (snap.confirmationOptions) return;
    if (inputChar.charCodeAt(0) === 3 || key.ctrl && inputChar === "c") {
      handleCtrlC();
      return;
    }
    if (key.shift && key.tab) {
      toggleAutoEdit();
      return;
    }
    if (key.return) {
      handleEnter();
      return;
    }
    if (key.escape) {
      handleEscape();
      return;
    }
    if (key.upArrow) {
      handleUpArrow();
      return;
    }
    if (key.downArrow) {
      handleDownArrow();
      return;
    }
    if (key.backspace || key.delete) {
      actions.setInputValue(snap.inputValue.slice(0, -1));
      return;
    }
    if (!key.ctrl && !key.meta && inputChar) {
      if (inputChar === "/" && snap.inputValue === "") {
        actions.pushStage({ id: "command-palette", type: "command_palette" /* COMMAND_PALETTE */ });
        return;
      }
      actions.setInputValue(snap.inputValue + inputChar);
    }
  });
  return /* @__PURE__ */ React12.createElement(ChatLayout, null, /* @__PURE__ */ React12.createElement(Box12, { flexDirection: "column", height: "100%", overflow: "hidden" }, /* @__PURE__ */ React12.createElement(Box12, { flexDirection: "column", flexGrow: 1, overflow: "hidden" }, /* @__PURE__ */ React12.createElement(Box12, { paddingX: 2, flexShrink: 0 }, showCommandSuggestions && /* @__PURE__ */ React12.createElement(CommandSuggestions, null), showModelSelection && /* @__PURE__ */ React12.createElement(ModelSelection, null)), /* @__PURE__ */ React12.createElement(Box12, { paddingX: 2, flexGrow: 1, overflow: "hidden", height: "100%" }, /* @__PURE__ */ React12.createElement(
    ChatHistory,
    {
      messageRegistry: messageRegistry2,
      executionRegistry: executionRegistry2,
      toolRegistry
    }
  ))), /* @__PURE__ */ React12.createElement(Box12, { flexDirection: "column", flexShrink: 0 }, /* @__PURE__ */ React12.createElement(Box12, { paddingX: 2 }, /* @__PURE__ */ React12.createElement(LoadingAndStatus, null)), /* @__PURE__ */ React12.createElement(ChatInput, null), /* @__PURE__ */ React12.createElement(Box12, { paddingX: 2 }, /* @__PURE__ */ React12.createElement(StatusBar, null)))));
}
var init_ChatContainer = __esm({
  "src/ui/containers/ChatContainer.tsx"() {
    init_esm_shims();
    init_ChatLayout();
    init_command_suggestions();
    init_chat_history();
    init_ChatInput();
    init_StatusBar();
    init_LoadingAndStatus();
    init_model_selection();
    init_confirmation_service();
    init_useInputHandler();
    init_useConfirmationHandler();
    init_useProcessingTimer();
    init_useRegistries();
    init_store2();
    init_types2();
  }
});

// src/ui/components/form/Input.tsx
import React13, { useState as useState5, useEffect as useEffect8 } from "react";
import { Box as Box13, Text as Text12, useFocus, useInput as useInput3 } from "ink";
var Input;
var init_Input = __esm({
  "src/ui/components/form/Input.tsx"() {
    init_esm_shims();
    Input = ({
      value,
      onChange,
      placeholder = "",
      label,
      width,
      password = false,
      error = false,
      errorMessage,
      onFocus,
      onBlur,
      autoFocus = false,
      readOnly = false
    }) => {
      const { isFocused } = useFocus({ autoFocus });
      const [cursorPosition, setCursorPosition] = useState5(value.length);
      const [showCursor, setShowCursor] = useState5(true);
      const [showPlaceholder, setShowPlaceholder] = useState5(true);
      useEffect8(() => {
        if (isFocused) {
          onFocus?.();
          setShowPlaceholder(false);
        } else {
          onBlur?.();
          if (!value) {
            setShowPlaceholder(true);
          }
        }
      }, [isFocused, onFocus, onBlur]);
      useEffect8(() => {
        if (isFocused) {
          const interval = setInterval(() => {
            setShowCursor((prev) => !prev);
            if (!value) {
              setShowPlaceholder((prev) => !prev);
            }
          }, 500);
          return () => clearInterval(interval);
        } else {
          setShowCursor(false);
          setShowPlaceholder(true);
        }
      }, [isFocused, value]);
      useInput3((input, key) => {
        if (!isFocused) return;
        if (key.leftArrow) {
          setCursorPosition(Math.max(0, cursorPosition - 1));
        } else if (key.rightArrow) {
          setCursorPosition(Math.min(value.length, cursorPosition + 1));
        } else if (!readOnly && (key.backspace || key.delete)) {
          if (cursorPosition > 0) {
            const newValue = value.slice(0, cursorPosition - 1) + value.slice(cursorPosition);
            onChange(newValue);
            setCursorPosition(cursorPosition - 1);
          }
        } else if (!readOnly && input && !key.ctrl && !key.meta) {
          const newValue = value.slice(0, cursorPosition) + input + value.slice(cursorPosition);
          onChange(newValue);
          setCursorPosition(cursorPosition + input.length);
        }
      });
      useEffect8(() => {
        setCursorPosition(value.length);
      }, [value]);
      const renderValue = () => {
        const displayValue = password ? "\u2022".repeat(value.length) : value;
        if (!displayValue && !isFocused) {
          return /* @__PURE__ */ React13.createElement(Text12, { color: "gray" }, placeholder);
        }
        if (!displayValue && isFocused) {
          return /* @__PURE__ */ React13.createElement(React13.Fragment, null, showPlaceholder && /* @__PURE__ */ React13.createElement(Text12, { color: "gray" }, placeholder), showCursor && !showPlaceholder && /* @__PURE__ */ React13.createElement(Text12, { inverse: true }, " "));
        }
        if (isFocused && showCursor) {
          const beforeCursor = displayValue.slice(0, cursorPosition);
          const afterCursor = displayValue.slice(cursorPosition);
          return /* @__PURE__ */ React13.createElement(React13.Fragment, null, beforeCursor, /* @__PURE__ */ React13.createElement(Text12, { inverse: true }, " "), afterCursor);
        }
        return displayValue;
      };
      const borderColor = error ? "red" : isFocused ? "cyan" : "gray";
      return /* @__PURE__ */ React13.createElement(Box13, { flexDirection: "column", width: "100%" }, label && /* @__PURE__ */ React13.createElement(Box13, null, /* @__PURE__ */ React13.createElement(Text12, { color: error ? "red" : void 0 }, label)), /* @__PURE__ */ React13.createElement(
        Box13,
        {
          borderStyle: "single",
          borderColor,
          width: "100%",
          paddingX: 1,
          flexDirection: "row"
        },
        isFocused && /* @__PURE__ */ React13.createElement(Text12, { color: "cyan" }, "\u276F "),
        !isFocused && /* @__PURE__ */ React13.createElement(Text12, null, " "),
        /* @__PURE__ */ React13.createElement(Text12, null, renderValue())
      ), error && errorMessage && /* @__PURE__ */ React13.createElement(Box13, { marginTop: 1 }, /* @__PURE__ */ React13.createElement(Text12, { color: "red", italic: true }, errorMessage)));
    };
  }
});

// src/ui/components/form/Button.tsx
import React14, { useState as useState6 } from "react";
import { Box as Box14, Text as Text13, useFocus as useFocus2, useInput as useInput4 } from "ink";
var Button;
var init_Button = __esm({
  "src/ui/components/form/Button.tsx"() {
    init_esm_shims();
    Button = ({
      label,
      onPress,
      variant = "primary",
      disabled = false,
      width,
      autoFocus = false,
      filled = false
    }) => {
      const { isFocused } = useFocus2({ autoFocus, isActive: !disabled });
      const [isPressed, setIsPressed] = useState6(false);
      useInput4((input, key) => {
        if (!isFocused || disabled) return;
        if (input === " ") {
          setIsPressed(true);
          setTimeout(() => {
            setIsPressed(false);
            onPress();
          }, 150);
        }
      });
      const getColors = () => {
        if (disabled) {
          return {
            borderColor: "gray",
            textColor: "gray",
            bgColor: void 0
          };
        }
        if (isPressed) {
          return {
            borderColor: "white",
            textColor: "black",
            bgColor: "white"
          };
        }
        if (filled) {
          const filledColors = {
            primary: {
              borderColor: isFocused ? "cyan" : "white",
              textColor: isFocused ? "black" : "white",
              bgColor: isFocused ? "cyan" : void 0
            },
            secondary: {
              borderColor: isFocused ? "cyan" : "gray",
              textColor: isFocused ? "black" : "gray",
              bgColor: isFocused ? "cyan" : void 0
            },
            danger: {
              borderColor: isFocused ? "red" : "white",
              textColor: isFocused ? "white" : "white",
              bgColor: isFocused ? "red" : void 0
            }
          };
          return filledColors[variant];
        }
        const variantColors = {
          primary: {
            borderColor: isFocused ? "cyan" : "blue",
            textColor: isFocused ? "cyan" : "blue",
            bgColor: void 0
          },
          secondary: {
            borderColor: isFocused ? "magenta" : "gray",
            textColor: isFocused ? "magenta" : "white",
            bgColor: void 0
          },
          danger: {
            borderColor: isFocused ? "red" : "red",
            textColor: isFocused ? "redBright" : "red",
            bgColor: void 0
          }
        };
        return variantColors[variant];
      };
      const { borderColor, textColor, bgColor } = getColors();
      const buttonContent = filled && bgColor ? (
        // Filled button - apply background to entire box
        /* @__PURE__ */ React14.createElement(
          Box14,
          {
            borderStyle: "round",
            borderColor,
            width: width || void 0,
            minWidth: label.length + 6
          },
          /* @__PURE__ */ React14.createElement(
            Text13,
            {
              color: textColor,
              backgroundColor: bgColor,
              bold: isFocused && !disabled
            },
            `  ${label}  `
          )
        )
      ) : (
        // Regular button - padding without background
        /* @__PURE__ */ React14.createElement(
          Box14,
          {
            borderStyle: "round",
            borderColor,
            paddingX: 2,
            paddingY: 0,
            width: width || void 0,
            minWidth: label.length + 6
          },
          /* @__PURE__ */ React14.createElement(
            Text13,
            {
              color: textColor,
              backgroundColor: bgColor,
              bold: isFocused && !disabled
            },
            label
          )
        )
      );
      if (isFocused && !disabled) {
        return /* @__PURE__ */ React14.createElement(Box14, null, /* @__PURE__ */ React14.createElement(Text13, { color: borderColor }, "\u25B6 "), buttonContent);
      }
      return /* @__PURE__ */ React14.createElement(Box14, null, /* @__PURE__ */ React14.createElement(Text13, null, "  "), buttonContent);
    };
  }
});

// src/ui/components/form/SelectDropdown.tsx
import React15, { useState as useState7 } from "react";
import { Box as Box15, Text as Text14, useInput as useInput5 } from "ink";
var SelectDropdown;
var init_SelectDropdown = __esm({
  "src/ui/components/form/SelectDropdown.tsx"() {
    init_esm_shims();
    SelectDropdown = ({
      options,
      selectedValue,
      onSelect,
      onClose,
      maxHeight = 10,
      width
    }) => {
      const [highlightedIndex, setHighlightedIndex] = useState7(() => {
        const index = options.findIndex((opt) => opt.value === selectedValue);
        return index >= 0 ? index : 0;
      });
      useInput5((input, key) => {
        if (key.escape) {
          onClose();
          return;
        }
        if (key.upArrow || input === "k") {
          setHighlightedIndex((prev) => prev > 0 ? prev - 1 : options.length - 1);
        } else if (key.downArrow || input === "j") {
          setHighlightedIndex((prev) => prev < options.length - 1 ? prev + 1 : 0);
        } else if (key.return || input === " ") {
          onSelect(options[highlightedIndex].value);
          onClose();
        }
      });
      const visibleStart = Math.max(0, highlightedIndex - Math.floor(maxHeight / 2));
      const visibleEnd = Math.min(options.length, visibleStart + maxHeight);
      const visibleOptions = options.slice(visibleStart, visibleEnd);
      return /* @__PURE__ */ React15.createElement(
        Box15,
        {
          flexDirection: "column",
          borderStyle: "single",
          borderColor: "cyan",
          paddingX: 1,
          paddingY: 0,
          width: "100%"
        },
        visibleStart > 0 && /* @__PURE__ */ React15.createElement(Text14, { dimColor: true }, "\u2191 ", visibleStart, " more..."),
        visibleOptions.map((option, index) => {
          const actualIndex = visibleStart + index;
          const isHighlighted = actualIndex === highlightedIndex;
          const isSelected = option.value === selectedValue;
          return /* @__PURE__ */ React15.createElement(Box15, { key: option.value, paddingX: 0, width: "100%" }, /* @__PURE__ */ React15.createElement(
            Text14,
            {
              color: isHighlighted ? "black" : isSelected ? "cyan" : void 0,
              backgroundColor: isHighlighted ? "cyan" : void 0,
              bold: isSelected,
              wrap: "truncate"
            },
            isHighlighted ? "\u276F " : "  ",
            option.label,
            isSelected && !isHighlighted ? " \u2713" : ""
          ));
        }),
        visibleEnd < options.length && /* @__PURE__ */ React15.createElement(Text14, { dimColor: true }, "\u2193 ", options.length - visibleEnd, " more...")
      );
    };
  }
});

// src/ui/components/form/Select.tsx
import React16, { useState as useState8, useEffect as useEffect11 } from "react";
import { Box as Box16, Text as Text15, useFocus as useFocus3, useInput as useInput6 } from "ink";
var Select;
var init_Select = __esm({
  "src/ui/components/form/Select.tsx"() {
    init_esm_shims();
    init_SelectDropdown();
    Select = ({
      options,
      value,
      onChange,
      label,
      width,
      error = false,
      errorMessage,
      autoFocus = false,
      onFocus,
      onBlur,
      onDropdownOpen,
      vimMode = "normal",
      onAutocompleteAccept,
      onVimModeChange,
      onSearchQueryChange
    }) => {
      const { isFocused } = useFocus3({ autoFocus });
      const [selectedIndex, setSelectedIndex] = useState8(0);
      const [showDropdown, setShowDropdown] = useState8(false);
      const [searchQuery, setSearchQuery] = useState8("");
      useEffect11(() => {
        onDropdownOpen?.(showDropdown);
      }, [showDropdown, onDropdownOpen]);
      useEffect11(() => {
        onSearchQueryChange?.(searchQuery.length > 0);
      }, [searchQuery, onSearchQueryChange]);
      useEffect11(() => {
        if (value) {
          const index = options.findIndex((opt) => opt.value === value);
          if (index >= 0) {
            setSelectedIndex(index);
          }
        }
      }, [value, options]);
      useEffect11(() => {
        if (isFocused) {
          onFocus?.();
        } else {
          onBlur?.();
          setSearchQuery("");
        }
      }, [isFocused, onFocus, onBlur]);
      const getAutocompleteMatch = () => {
        if (!searchQuery) return null;
        return options.find(
          (opt) => opt.label.toLowerCase().startsWith(searchQuery.toLowerCase())
        );
      };
      useInput6((input, key) => {
        if (!isFocused || options.length === 0) return;
        if (showDropdown) return;
        if (input === " " && vimMode === "normal") {
          setShowDropdown(true);
        } else if (key.tab && searchQuery && vimMode === "insert") {
          const match = getAutocompleteMatch();
          if (match) {
            const matchIndex = options.findIndex((opt) => opt.value === match.value);
            setSelectedIndex(matchIndex);
            onChange?.(match.value);
            setSearchQuery("");
            onAutocompleteAccept?.();
            onVimModeChange?.("normal");
            return;
          }
        } else if (vimMode === "insert") {
          if (key.backspace || key.delete) {
            setSearchQuery((prev) => prev.slice(0, -1));
          } else if (input && !key.ctrl && !key.meta && input !== " ") {
            setSearchQuery((prev) => prev + input);
          }
        }
      }, { isActive: true });
      const currentOption = options[selectedIndex] || options[0];
      const borderColor = error ? "red" : isFocused ? "cyan" : "gray";
      const handleDropdownSelect = (selectedValue) => {
        const index = options.findIndex((opt) => opt.value === selectedValue);
        if (index >= 0) {
          setSelectedIndex(index);
          onChange?.(selectedValue);
        }
      };
      if (showDropdown && isFocused) {
        return /* @__PURE__ */ React16.createElement(Box16, { flexDirection: "column", width: "100%" }, label && /* @__PURE__ */ React16.createElement(Box16, null, /* @__PURE__ */ React16.createElement(Text15, { color: error ? "red" : void 0 }, label)), /* @__PURE__ */ React16.createElement(
          SelectDropdown,
          {
            options,
            selectedValue: currentOption?.value,
            onSelect: handleDropdownSelect,
            onClose: () => setShowDropdown(false),
            width
          }
        ));
      }
      return /* @__PURE__ */ React16.createElement(Box16, { flexDirection: "column", width: "100%" }, label && /* @__PURE__ */ React16.createElement(Box16, null, /* @__PURE__ */ React16.createElement(Text15, { color: error ? "red" : void 0 }, label)), /* @__PURE__ */ React16.createElement(
        Box16,
        {
          borderStyle: "single",
          borderColor,
          width: "100%",
          paddingX: 1,
          flexDirection: "row",
          alignItems: "center"
        },
        isFocused && /* @__PURE__ */ React16.createElement(Text15, { color: "cyan" }, "\u276F "),
        !isFocused && /* @__PURE__ */ React16.createElement(Text15, null, "  "),
        /* @__PURE__ */ React16.createElement(Box16, { flexGrow: 1, justifyContent: "space-between", flexDirection: "row" }, searchQuery && vimMode === "insert" ? /* @__PURE__ */ React16.createElement(Box16, null, /* @__PURE__ */ React16.createElement(Text15, null, searchQuery), (() => {
          const match = getAutocompleteMatch();
          if (match && match.label.toLowerCase().startsWith(searchQuery.toLowerCase())) {
            const suggestion = match.label.slice(searchQuery.length);
            return /* @__PURE__ */ React16.createElement(Text15, { dimColor: true }, suggestion);
          }
          return null;
        })()) : /* @__PURE__ */ React16.createElement(Text15, null, currentOption?.label || ""), /* @__PURE__ */ React16.createElement(Box16, { flexGrow: 1 }))
      ), error && errorMessage && /* @__PURE__ */ React16.createElement(Box16, { marginTop: 1 }, /* @__PURE__ */ React16.createElement(Text15, { color: "red", italic: true }, errorMessage)));
    };
  }
});

// src/ui/components/form/Toggle.tsx
import React17 from "react";
import { Box as Box17, Text as Text16, useFocus as useFocus4, useInput as useInput7 } from "ink";
var Toggle;
var init_Toggle = __esm({
  "src/ui/components/form/Toggle.tsx"() {
    init_esm_shims();
    Toggle = ({
      value = false,
      onChange,
      label,
      disabled = false,
      autoFocus = false
    }) => {
      const { isFocused } = useFocus4({
        autoFocus,
        isActive: !disabled
      });
      useInput7((input, key) => {
        if (!isFocused || disabled) return;
        if (input === " " || key.return) {
          onChange?.(!value);
        }
      });
      const borderColor = isFocused ? "cyan" : "gray";
      const textColor = disabled ? "gray" : isFocused ? "cyan" : "white";
      return /* @__PURE__ */ React17.createElement(Box17, { flexDirection: "column", width: "100%" }, label && /* @__PURE__ */ React17.createElement(Box17, null, /* @__PURE__ */ React17.createElement(Text16, { color: disabled ? "gray" : void 0 }, label)), /* @__PURE__ */ React17.createElement(
        Box17,
        {
          borderStyle: "round",
          borderColor,
          paddingX: 1,
          width: 10,
          justifyContent: "center"
        },
        /* @__PURE__ */ React17.createElement(Text16, { color: textColor, bold: isFocused }, value ? "[\u2713]" : "[ ]")
      ));
    };
  }
});

// src/ui/components/form/Form.tsx
import React18, { createContext, useContext, useState as useState9, useEffect as useEffect12, useCallback as useCallback9 } from "react";
import { Box as Box18, Text as Text17, useInput as useInput8 } from "ink";
var FormContext, useForm, Form;
var init_Form = __esm({
  "src/ui/components/form/Form.tsx"() {
    init_esm_shims();
    FormContext = createContext(void 0);
    useForm = () => {
      const context = useContext(FormContext);
      if (!context) {
        throw new Error("useForm must be used within a Form component");
      }
      return context;
    };
    Form = ({
      onSubmit,
      initialValues = {},
      children,
      layout = "vertical"
    }) => {
      const [fields, setFields] = useState9([]);
      const [values, setValues] = useState9(initialValues);
      const [errors, setErrors] = useState9({});
      const [focusedFieldId, setFocusedFieldId] = useState9(null);
      const [isSubmitting, setIsSubmitting] = useState9(false);
      const [dropdownOpen, setDropdownOpen] = useState9(false);
      const [vimMode, setVimMode] = useState9("normal");
      const [shouldBlockTab, setShouldBlockTab] = useState9(false);
      const [hasSearchQuery, setHasSearchQuery] = useState9(false);
      const registerField = useCallback9((field) => {
        setFields((prev) => {
          const filtered = prev.filter((f) => f.id !== field.id);
          return [...filtered, field].sort((a, b) => {
            if (a.row !== b.row) return a.row - b.row;
            return a.column - b.column;
          });
        });
      }, []);
      const unregisterField = useCallback9((id) => {
        setFields((prev) => prev.filter((f) => f.id !== id));
      }, []);
      const setValue = useCallback9((id, value) => {
        setValues((prev) => ({ ...prev, [id]: value }));
        setErrors((prev) => {
          const newErrors = { ...prev };
          delete newErrors[id];
          return newErrors;
        });
      }, []);
      const setError = useCallback9((id, error) => {
        if (error) {
          setErrors((prev) => ({ ...prev, [id]: error }));
        } else {
          setErrors((prev) => {
            const newErrors = { ...prev };
            delete newErrors[id];
            return newErrors;
          });
        }
      }, []);
      const focusField = useCallback9((id) => {
        setFocusedFieldId(id);
      }, []);
      const getNextField = (currentId, direction) => {
        const sortedFields = [...fields].sort((a, b) => {
          if (a.row !== b.row) return a.row - b.row;
          return a.column - b.column;
        });
        const currentIndex = sortedFields.findIndex((f) => f.id === currentId);
        if (currentIndex === -1) return null;
        const currentField = sortedFields[currentIndex];
        switch (direction) {
          case "next": {
            const nextIndex = (currentIndex + 1) % sortedFields.length;
            return sortedFields[nextIndex];
          }
          case "prev": {
            const prevIndex = currentIndex === 0 ? sortedFields.length - 1 : currentIndex - 1;
            return sortedFields[prevIndex];
          }
          case "up": {
            const prevRowFields = sortedFields.filter((f) => f.row === currentField.row - 1);
            if (prevRowFields.length === 0) {
              const lastRow = Math.max(...sortedFields.map((f) => f.row));
              const lastRowFields = sortedFields.filter((f) => f.row === lastRow);
              return lastRowFields.sort(
                (a, b) => Math.abs(a.column - currentField.column) - Math.abs(b.column - currentField.column)
              )[0] || null;
            }
            return prevRowFields.sort(
              (a, b) => Math.abs(a.column - currentField.column) - Math.abs(b.column - currentField.column)
            )[0] || null;
          }
          case "down": {
            const nextRowFields = sortedFields.filter((f) => f.row === currentField.row + 1);
            if (nextRowFields.length === 0) {
              const firstRowFields = sortedFields.filter((f) => f.row === 0);
              return firstRowFields.sort(
                (a, b) => Math.abs(a.column - currentField.column) - Math.abs(b.column - currentField.column)
              )[0] || null;
            }
            return nextRowFields.sort(
              (a, b) => Math.abs(a.column - currentField.column) - Math.abs(b.column - currentField.column)
            )[0] || null;
          }
          case "left": {
            const sameRowFields = sortedFields.filter((f) => f.row === currentField.row);
            if (sameRowFields.length <= 1) return null;
            const currentIndexInRow = sameRowFields.findIndex((f) => f.id === currentId);
            const prevIndex = currentIndexInRow === 0 ? sameRowFields.length - 1 : currentIndexInRow - 1;
            return sameRowFields[prevIndex];
          }
          case "right": {
            const sameRowFields = sortedFields.filter((f) => f.row === currentField.row);
            if (sameRowFields.length <= 1) return null;
            const currentIndexInRow = sameRowFields.findIndex((f) => f.id === currentId);
            const nextIndex = (currentIndexInRow + 1) % sameRowFields.length;
            return sameRowFields[nextIndex];
          }
          default:
            return null;
        }
      };
      const blockNextTab = useCallback9(() => {
        setShouldBlockTab(true);
        setTimeout(() => setShouldBlockTab(false), 250);
      }, []);
      useInput8((input, key) => {
        if (key.tab && shouldBlockTab) {
          setShouldBlockTab(false);
          return;
        }
        if (key.tab && !key.shift) {
          return;
        }
        if (key.escape) {
          setVimMode("normal");
          return;
        }
        if (!focusedFieldId) {
          return;
        }
        if (dropdownOpen) {
          return;
        }
        if (vimMode === "normal") {
          if (input === "i") {
            setVimMode("insert");
            return;
          }
          if (key.upArrow || input === "k") {
            const nextField = getNextField(focusedFieldId, "up");
            if (nextField) {
              setFocusedFieldId(nextField.id);
            }
          } else if (key.downArrow || input === "j") {
            const nextField = getNextField(focusedFieldId, "down");
            if (nextField) {
              setFocusedFieldId(nextField.id);
            }
          } else if (key.leftArrow || input === "h") {
            const nextField = getNextField(focusedFieldId, "left");
            if (nextField) {
              setFocusedFieldId(nextField.id);
            }
          } else if (key.rightArrow || input === "l") {
            const nextField = getNextField(focusedFieldId, "right");
            if (nextField) {
              setFocusedFieldId(nextField.id);
            }
          }
        }
        if (key.return) {
          submitForm();
          return;
        }
      }, { isActive: true });
      const submitForm = useCallback9(async () => {
        const newErrors = {};
        let hasErrors = false;
        for (const field of fields) {
          if (field.required && !values[field.id]) {
            newErrors[field.id] = "This field is required";
            hasErrors = true;
          } else if (field.validation) {
            const error = field.validation(values[field.id]);
            if (error) {
              newErrors[field.id] = error;
              hasErrors = true;
            }
          }
        }
        setErrors(newErrors);
        if (hasErrors) {
          const firstErrorField = fields.find((f) => newErrors[f.id]);
          if (firstErrorField) {
            setFocusedFieldId(firstErrorField.id);
          }
          return;
        }
        setIsSubmitting(true);
        try {
          await onSubmit(values);
        } finally {
          setIsSubmitting(false);
        }
      }, [fields, values, onSubmit]);
      const clearForm = useCallback9(() => {
        setValues(initialValues);
        setErrors({});
        setHasSearchQuery(false);
        if (fields.length > 0) {
          setFocusedFieldId(fields[0].id);
        }
      }, [initialValues, fields]);
      useEffect12(() => {
        if (!focusedFieldId && fields.length > 0) {
          setFocusedFieldId(fields[0].id);
        }
      }, [fields.length]);
      const contextValue = {
        fields,
        values,
        errors,
        focusedFieldId,
        registerField,
        unregisterField,
        setValue,
        setError,
        focusField,
        submitForm,
        isSubmitting,
        dropdownOpen,
        setDropdownOpen,
        vimMode,
        setVimMode,
        blockNextTab,
        shouldBlockTab,
        setHasSearchQuery,
        clearForm
      };
      const focusedField = fields.find((f) => f.id === focusedFieldId);
      const isSelectFocused = focusedField?.type === "select";
      const isInputFocused = focusedField?.type === "input";
      const isButtonFocused = focusedField?.type === "button";
      let contextualTip = "";
      if (dropdownOpen) {
        contextualTip = "\u2191\u2193/jk Nav \u2022 Space/Enter Select \u2022 ESC Cancel";
      } else if (isSelectFocused && vimMode === "insert" && hasSearchQuery) {
        contextualTip = "Type to search \u2022 Tab: complete";
      } else if (isSelectFocused && vimMode === "normal") {
        contextualTip = "Space: dropdown";
      } else if (isInputFocused && vimMode === "normal") {
        contextualTip = "i: insert mode";
      } else if (isButtonFocused) {
        contextualTip = "Space/Enter: select";
      } else {
        contextualTip = "\u2191\u2193\u2190\u2192/hjkl: move \u2022 Enter: save";
      }
      return /* @__PURE__ */ React18.createElement(FormContext.Provider, { value: contextValue }, /* @__PURE__ */ React18.createElement(Box18, { flexDirection: "column", width: "100%" }, /* @__PURE__ */ React18.createElement(Box18, { flexDirection: "row", justifyContent: "space-between", marginBottom: -1 }, /* @__PURE__ */ React18.createElement(
        Box18,
        {
          borderStyle: "round",
          borderColor: "gray",
          paddingX: 1,
          marginLeft: 2
        },
        /* @__PURE__ */ React18.createElement(Text17, { dimColor: true }, "mode: ", vimMode)
      ), /* @__PURE__ */ React18.createElement(
        Box18,
        {
          borderStyle: "round",
          borderColor: "gray",
          paddingX: 1,
          marginRight: 2
        },
        /* @__PURE__ */ React18.createElement(Text17, { dimColor: true }, contextualTip)
      )), /* @__PURE__ */ React18.createElement(
        Box18,
        {
          borderStyle: "round",
          borderColor: "gray",
          paddingX: 2,
          paddingY: 1,
          flexDirection: "column"
        },
        children
      )));
    };
  }
});

// src/ui/components/form/FormInput.tsx
import React19, { useEffect as useEffect13 } from "react";
var FormInput;
var init_FormInput = __esm({
  "src/ui/components/form/FormInput.tsx"() {
    init_esm_shims();
    init_Input();
    init_Form();
    FormInput = ({
      name,
      row = 0,
      column = 0,
      required = false,
      validation,
      ...inputProps
    }) => {
      const {
        registerField,
        unregisterField,
        setValue,
        values,
        errors,
        focusedFieldId,
        vimMode
      } = useForm();
      useEffect13(() => {
        registerField({
          id: name,
          type: "input",
          row,
          column,
          required,
          validation
        });
        return () => {
          unregisterField(name);
        };
      }, [name, row, column, required, validation, registerField, unregisterField]);
      const handleChange = (value) => {
        setValue(name, value);
      };
      return /* @__PURE__ */ React19.createElement(
        Input,
        {
          ...inputProps,
          value: values[name] || "",
          onChange: handleChange,
          error: !!errors[name],
          errorMessage: errors[name],
          autoFocus: focusedFieldId === name,
          readOnly: vimMode === "normal"
        }
      );
    };
  }
});

// src/ui/components/form/FormButton.tsx
import React20, { useEffect as useEffect14 } from "react";
var FormButton;
var init_FormButton = __esm({
  "src/ui/components/form/FormButton.tsx"() {
    init_esm_shims();
    init_Button();
    init_Form();
    FormButton = ({
      name,
      row = 0,
      column = 0,
      type = "button",
      onPress,
      ...buttonProps
    }) => {
      const {
        registerField,
        unregisterField,
        focusedFieldId,
        submitForm,
        isSubmitting
      } = useForm();
      useEffect14(() => {
        registerField({
          id: name,
          type: "button",
          row,
          column
        });
        return () => {
          unregisterField(name);
        };
      }, [name, row, column, registerField, unregisterField]);
      const handlePress = () => {
        if (type === "submit") {
          submitForm();
        } else if (onPress) {
          onPress();
        }
      };
      return /* @__PURE__ */ React20.createElement(
        Button,
        {
          ...buttonProps,
          onPress: handlePress,
          autoFocus: focusedFieldId === name,
          disabled: buttonProps.disabled || type === "submit" && isSubmitting
        }
      );
    };
  }
});

// src/ui/components/form/FormSelect.tsx
import React21, { useEffect as useEffect15 } from "react";
var FormSelect;
var init_FormSelect = __esm({
  "src/ui/components/form/FormSelect.tsx"() {
    init_esm_shims();
    init_Select();
    init_Form();
    FormSelect = ({
      name,
      row = 0,
      column = 0,
      required = false,
      validation,
      options,
      ...selectProps
    }) => {
      const {
        registerField,
        unregisterField,
        setValue,
        values,
        errors,
        focusedFieldId,
        setDropdownOpen,
        vimMode,
        blockNextTab,
        setVimMode,
        setHasSearchQuery
      } = useForm();
      useEffect15(() => {
        registerField({
          id: name,
          type: "select",
          row,
          column,
          required,
          validation
        });
        return () => {
          unregisterField(name);
        };
      }, [name, row, column, required, validation, registerField, unregisterField]);
      const hasInitialized = React21.useRef(false);
      useEffect15(() => {
        if (!hasInitialized.current && values[name] === void 0 && options.length > 0) {
          hasInitialized.current = true;
          setValue(name, options[0].value);
        }
      }, [name, options, setValue]);
      const handleChange = (value) => {
        setValue(name, value);
        selectProps.onChange?.(value);
      };
      return /* @__PURE__ */ React21.createElement(
        Select,
        {
          ...selectProps,
          options,
          value: values[name] || options[0]?.value,
          onChange: handleChange,
          error: !!errors[name],
          errorMessage: errors[name],
          autoFocus: focusedFieldId === name,
          onDropdownOpen: setDropdownOpen,
          vimMode,
          onAutocompleteAccept: blockNextTab,
          onVimModeChange: setVimMode,
          onSearchQueryChange: (hasQuery) => {
            if (focusedFieldId === name) {
              setHasSearchQuery(hasQuery);
            }
          }
        }
      );
    };
  }
});

// src/ui/components/form/FormToggle.tsx
import React22, { useEffect as useEffect16 } from "react";
var FormToggle;
var init_FormToggle = __esm({
  "src/ui/components/form/FormToggle.tsx"() {
    init_esm_shims();
    init_Toggle();
    init_Form();
    FormToggle = ({
      name,
      row = 0,
      column = 0,
      ...toggleProps
    }) => {
      const {
        registerField,
        unregisterField,
        setValue,
        values,
        focusedFieldId
      } = useForm();
      useEffect16(() => {
        registerField({
          id: name,
          type: "toggle",
          row,
          column
        });
        return () => {
          unregisterField(name);
        };
      }, [name, row, column, registerField, unregisterField]);
      const handleChange = (value) => {
        setValue(name, value);
      };
      return /* @__PURE__ */ React22.createElement(
        Toggle,
        {
          ...toggleProps,
          value: values[name] || false,
          onChange: handleChange,
          autoFocus: focusedFieldId === name
        }
      );
    };
  }
});

// src/ui/components/form/FormRow.tsx
import React23, { useState as useState10, useEffect as useEffect17 } from "react";
import { Box as Box19 } from "ink";
var init_FormRow = __esm({
  "src/ui/components/form/FormRow.tsx"() {
    init_esm_shims();
  }
});

// src/ui/components/form/FormGrid.tsx
import React24 from "react";
import { Box as Box20 } from "ink";
var init_FormGrid = __esm({
  "src/ui/components/form/FormGrid.tsx"() {
    init_esm_shims();
  }
});

// src/ui/components/form/ProviderSelect.tsx
import React25 from "react";
var ProviderSelect;
var init_ProviderSelect = __esm({
  "src/ui/components/form/ProviderSelect.tsx"() {
    init_esm_shims();
    init_FormSelect();
    init_Form();
    init_settings_manager();
    ProviderSelect = ({
      onProviderChange,
      ...props
    }) => {
      const { setValue } = useForm();
      const handleChange = (value) => {
        const provider = value;
        const providerConfig = ProviderModels[provider];
        if (providerConfig && providerConfig.defaultModel) {
          setValue("model", providerConfig.defaultModel);
        }
        if (onProviderChange) {
          onProviderChange(provider);
        }
      };
      return /* @__PURE__ */ React25.createElement(
        FormSelect,
        {
          ...props,
          onChange: handleChange
        }
      );
    };
  }
});

// src/ui/components/form/ClearFormButton.tsx
import React26 from "react";
var ClearFormButton;
var init_ClearFormButton = __esm({
  "src/ui/components/form/ClearFormButton.tsx"() {
    init_esm_shims();
    init_FormButton();
    init_Form();
    ClearFormButton = ({
      onClear,
      ...props
    }) => {
      const { clearForm } = useForm();
      const handlePress = () => {
        clearForm();
        onClear?.();
      };
      return /* @__PURE__ */ React26.createElement(
        FormButton,
        {
          ...props,
          onPress: handlePress,
          type: "button"
        }
      );
    };
  }
});

// src/ui/components/form/VimModeIndicator.tsx
import React27 from "react";
import { Box as Box21, Text as Text18 } from "ink";
var init_VimModeIndicator = __esm({
  "src/ui/components/form/VimModeIndicator.tsx"() {
    init_esm_shims();
    init_Form();
  }
});

// src/ui/components/form/FormActionButtons.tsx
import React28 from "react";
import { Box as Box22 } from "ink";
var init_FormActionButtons = __esm({
  "src/ui/components/form/FormActionButtons.tsx"() {
    init_esm_shims();
    init_Button();
    init_Form();
  }
});

// src/ui/components/form/index.ts
var init_form = __esm({
  "src/ui/components/form/index.ts"() {
    init_esm_shims();
    init_Input();
    init_Button();
    init_Select();
    init_Toggle();
    init_Form();
    init_FormInput();
    init_FormButton();
    init_FormSelect();
    init_FormToggle();
    init_FormRow();
    init_FormGrid();
    init_ProviderSelect();
    init_ClearFormButton();
    init_VimModeIndicator();
    init_FormActionButtons();
  }
});

// src/commands/registry.ts
function getCommandRegistry() {
  if (!globalRegistry) {
    globalRegistry = new CommandRegistryImpl();
  }
  return globalRegistry;
}
function registerCommand(command) {
  getCommandRegistry().register(command);
}
var CommandRegistryImpl, globalRegistry;
var init_registry4 = __esm({
  "src/commands/registry.ts"() {
    init_esm_shims();
    CommandRegistryImpl = class {
      constructor() {
        this.commands = /* @__PURE__ */ new Map();
      }
      register(command) {
        if (this.commands.has(command.name)) {
          console.warn(`Command "${command.name}" is already registered, skipping`);
          return;
        }
        this.commands.set(command.name, command);
      }
      unregister(name) {
        this.commands.delete(name);
      }
      get(name) {
        return this.commands.get(name);
      }
      list() {
        return Array.from(this.commands.values());
      }
      listByCategory() {
        const categories = {};
        for (const command of this.commands.values()) {
          const category = command.category || "General";
          if (!categories[category]) {
            categories[category] = [];
          }
          categories[category].push(command);
        }
        for (const category in categories) {
          categories[category].sort((a, b) => a.name.localeCompare(b.name));
        }
        return categories;
      }
    };
    globalRegistry = null;
  }
});

// src/ui/screens/CommandPaletteScreen.tsx
import React29, { useMemo as useMemo3 } from "react";
import { Box as Box23, Text as Text19 } from "ink";
import { useSnapshot as useSnapshot15 } from "valtio";
var CommandPaletteScreen, CommandFormContent;
var init_CommandPaletteScreen = __esm({
  "src/ui/screens/CommandPaletteScreen.tsx"() {
    init_esm_shims();
    init_form();
    init_registry4();
    init_store2();
    init_types2();
    CommandPaletteScreen = () => {
      const registry = getCommandRegistry();
      const snap = useSnapshot15(store);
      const commandOptions = useMemo3(
        () => registry.list().map((cmd) => ({
          value: cmd.name,
          label: `${cmd.name} - ${cmd.description}`
        })),
        []
      );
      const handleSubmit = async (values) => {
        const selectedCommand = values.command;
        if (!selectedCommand) return;
        const commandDef = registry.get(selectedCommand);
        if (!commandDef) return;
        const args = {};
        if (commandDef.arguments) {
          for (const arg of commandDef.arguments) {
            if (values[arg.name] !== void 0) {
              args[arg.name] = values[arg.name];
            }
          }
        }
        if (snap.inputValue === "/") {
          actions.setInputValue("");
        }
        commandDef.exec(args);
        const currentStage = actions.getCurrentStage();
        if (currentStage.type === "command_palette" /* COMMAND_PALETTE */) {
          actions.popStage();
        }
      };
      const handleCancel = () => {
        if (snap.inputValue === "/") {
          actions.setInputValue("");
        }
        actions.popStage();
      };
      const initialValues = {
        command: commandOptions[0]?.value || ""
      };
      return /* @__PURE__ */ React29.createElement(
        Box23,
        {
          width: "100%",
          height: "100%",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center"
        },
        /* @__PURE__ */ React29.createElement(
          Box23,
          {
            borderStyle: "round",
            borderColor: "cyan",
            paddingX: 2,
            paddingY: 1,
            width: 60,
            flexDirection: "column"
          },
          /* @__PURE__ */ React29.createElement(Box23, { marginBottom: 1, justifyContent: "center" }, /* @__PURE__ */ React29.createElement(Text19, { bold: true, color: "cyan" }, "Command Palette")),
          /* @__PURE__ */ React29.createElement(
            Form,
            {
              onSubmit: handleSubmit,
              initialValues
            },
            /* @__PURE__ */ React29.createElement(
              CommandFormContent,
              {
                commandOptions,
                onCancel: handleCancel
              }
            )
          )
        )
      );
    };
    CommandFormContent = ({ commandOptions, onCancel }) => {
      const registry = getCommandRegistry();
      const [selectedCommand, setSelectedCommand] = React29.useState(commandOptions[0]?.value || "");
      const { setValue } = useForm();
      const commandDef = useMemo3(
        () => selectedCommand ? registry.get(selectedCommand) : null,
        [selectedCommand, registry]
      );
      React29.useEffect(() => {
        if (selectedCommand === "settings") {
          const currentSettings = {
            model: store.model,
            theme: store.theme,
            autoEditEnabled: store.autoEditEnabled,
            vsCodeOpenEnabled: store.vsCodeOpenEnabled,
            dangerousBypassPermission: store.dangerousBypassPermission,
            virtualScrollingEnabled: store.virtualScrollingEnabled
          };
          Object.entries(currentSettings).forEach(([key, value]) => {
            setValue(key, value);
          });
        }
      }, [selectedCommand, setValue]);
      const renderArgument = (arg, index) => {
        const row = index + 1;
        switch (arg.type) {
          case "string":
            return /* @__PURE__ */ React29.createElement(
              FormInput,
              {
                key: arg.name,
                name: arg.name,
                label: arg.description || arg.name,
                placeholder: arg.placeholder,
                required: arg.required,
                validation: arg.validation,
                row,
                column: 0
              }
            );
          case "boolean":
            return /* @__PURE__ */ React29.createElement(
              FormToggle,
              {
                key: arg.name,
                name: arg.name,
                label: arg.description || arg.name,
                row,
                column: 0
              }
            );
          case "enum":
            return /* @__PURE__ */ React29.createElement(
              FormSelect,
              {
                key: arg.name,
                name: arg.name,
                label: arg.description || arg.name,
                options: arg.options || [],
                required: arg.required,
                row,
                column: 0
              }
            );
          default:
            return null;
        }
      };
      return /* @__PURE__ */ React29.createElement(React29.Fragment, null, /* @__PURE__ */ React29.createElement(
        FormSelect,
        {
          name: "command",
          label: "Command",
          options: commandOptions,
          row: 0,
          column: 0,
          onChange: setSelectedCommand
        }
      ), commandDef?.arguments?.map((arg, index) => renderArgument(arg, index)), /* @__PURE__ */ React29.createElement(
        Box23,
        {
          flexDirection: "row",
          gap: 2,
          marginTop: 2,
          justifyContent: "flex-end"
        },
        /* @__PURE__ */ React29.createElement(
          FormButton,
          {
            name: "cancel",
            label: "Cancel",
            onPress: onCancel,
            variant: "secondary",
            row: commandDef?.arguments?.length ? commandDef.arguments.length + 1 : 1,
            column: 0
          }
        ),
        /* @__PURE__ */ React29.createElement(
          FormButton,
          {
            name: "execute",
            label: "Execute",
            type: "submit",
            variant: "primary",
            filled: true,
            row: commandDef?.arguments?.length ? commandDef.arguments.length + 1 : 1,
            column: 1
          }
        )
      ));
    };
  }
});

// src/ui/screens/SettingsScreen.tsx
import React30, { useState as useState11, useEffect as useEffect18 } from "react";
import { Box as Box24, Text as Text20 } from "ink";
var CompactClankLogo, SettingsScreen;
var init_SettingsScreen = __esm({
  "src/ui/screens/SettingsScreen.tsx"() {
    init_esm_shims();
    init_form();
    init_settings_manager();
    CompactClankLogo = () => {
      const [colorIndex, setColorIndex] = useState11(0);
      const colors = ["red", "yellow", "green", "cyan", "blue", "magenta"];
      useEffect18(() => {
        const interval = setInterval(() => {
          setColorIndex((prev) => (prev + 1) % colors.length);
        }, 300);
        return () => clearInterval(interval);
      }, []);
      return /* @__PURE__ */ React30.createElement(
        Box24,
        {
          borderStyle: "round",
          borderColor: colors[colorIndex],
          paddingX: 2,
          marginBottom: 2
        },
        /* @__PURE__ */ React30.createElement(Text20, { color: colors[colorIndex] }, "\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\n", "\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2554\u255D\n", "\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2554\u255D \n", "\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u255A\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2588\u2588\u2557 \n", "\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255A\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2557\n", " \u255A\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D")
      );
    };
    SettingsScreen = ({ onComplete, onCancel }) => {
      const settingsManager = SettingsManager.getInstance();
      const [initialValues, setInitialValues] = useState11({});
      const [selectedProvider, setSelectedProvider] = useState11("grok");
      useEffect18(() => {
        const { settings } = settingsManager.loadSettings();
        setInitialValues(settings);
        if (settings.provider) {
          setSelectedProvider(settings.provider);
        }
      }, []);
      const handleSubmit = async (values) => {
        try {
          const settings = {
            apiKey: values.apiKey,
            provider: values.provider || selectedProvider,
            model: values.model || ProviderModels[selectedProvider].defaultModel,
            theme: values.theme || "auto",
            autoEditEnabled: values.autoEditEnabled || false,
            vsCodeOpenEnabled: values.vsCodeOpenEnabled || false,
            dangerousBypassPermission: values.dangerousBypassPermission || false,
            virtualScrollingEnabled: values.virtualScrollingEnabled !== void 0 ? values.virtualScrollingEnabled : true,
            confirmationSettings: values.confirmationSettings || {
              alwaysEdit: false,
              alwaysBash: false,
              alwaysSearch: false
            },
            ...selectedProvider === "custom" && values.customBaseURL ? { customBaseURL: values.customBaseURL } : {}
          };
          console.log("Saving settings:", { ...settings, apiKey: "***" });
          settingsManager.saveSettings(settings);
          onComplete(settings);
        } catch (error) {
          console.error("Failed to save settings:", error);
        }
      };
      const providerOptions = Object.entries(ProviderModels).map(([key, value]) => ({
        value: key,
        label: value.name
      }));
      const modelOptions = [...ProviderModels[selectedProvider]?.models || []];
      const validateApiKey = (value) => {
        if (!value || value.trim().length === 0) {
          return "API key is required";
        }
        if (value.length < 10) {
          return "API key seems too short";
        }
        return void 0;
      };
      const validateBaseURL = (value) => {
        if (!value) return void 0;
        try {
          new URL(value);
          return void 0;
        } catch {
          return "Invalid URL format";
        }
      };
      return /* @__PURE__ */ React30.createElement(Box24, { flexDirection: "column", paddingX: 2, paddingY: 1, width: "100%" }, /* @__PURE__ */ React30.createElement(Box24, { justifyContent: "center" }, /* @__PURE__ */ React30.createElement(CompactClankLogo, null)), /* @__PURE__ */ React30.createElement(Box24, { justifyContent: "center", marginBottom: 2 }, /* @__PURE__ */ React30.createElement(Text20, { bold: true, color: "cyan" }, Object.keys(initialValues).length > 0 ? "Settings" : "Initial Configuration")), /* @__PURE__ */ React30.createElement(Form, { onSubmit: handleSubmit, initialValues }, /* @__PURE__ */ React30.createElement(
        FormInput,
        {
          name: "apiKey",
          label: "Grok API Key",
          placeholder: "sk-...",
          password: true,
          required: true,
          validation: validateApiKey,
          row: 0,
          column: 0
        }
      ), /* @__PURE__ */ React30.createElement(
        ProviderSelect,
        {
          name: "provider",
          label: "Provider",
          options: providerOptions,
          row: 1,
          column: 0,
          onProviderChange: setSelectedProvider
        }
      ), selectedProvider === "custom" && /* @__PURE__ */ React30.createElement(
        FormInput,
        {
          name: "customBaseURL",
          label: "Custom API Base URL",
          placeholder: "https://api.example.com/v1",
          validation: validateBaseURL,
          required: true,
          row: 2,
          column: 0
        }
      ), /* @__PURE__ */ React30.createElement(Box24, { flexDirection: "row", gap: 2 }, selectedProvider !== "custom" && /* @__PURE__ */ React30.createElement(Box24, { flexGrow: 1, flexBasis: "50%" }, /* @__PURE__ */ React30.createElement(
        FormSelect,
        {
          name: "model",
          label: "Default Model",
          options: modelOptions,
          row: 2,
          column: 0
        }
      )), /* @__PURE__ */ React30.createElement(Box24, { flexGrow: 1, flexBasis: selectedProvider === "custom" ? "100%" : "50%" }, /* @__PURE__ */ React30.createElement(
        FormSelect,
        {
          name: "theme",
          label: "Theme",
          options: [
            { label: "Auto", value: "auto" },
            { label: "Light", value: "light" },
            { label: "Dark", value: "dark" }
          ],
          row: selectedProvider === "custom" ? 3 : 2,
          column: selectedProvider === "custom" ? 0 : 1
        }
      ))), /* @__PURE__ */ React30.createElement(Box24, { marginTop: 1, flexDirection: "column", gap: 1 }, /* @__PURE__ */ React30.createElement(
        FormToggle,
        {
          name: "autoEditEnabled",
          label: "Auto-edit (file operations only)",
          row: selectedProvider === "custom" ? 4 : 3,
          column: 0
        }
      ), /* @__PURE__ */ React30.createElement(
        FormToggle,
        {
          name: "vsCodeOpenEnabled",
          label: "VS Code integration",
          row: selectedProvider === "custom" ? 5 : 4,
          column: 0
        }
      ), /* @__PURE__ */ React30.createElement(
        FormToggle,
        {
          name: "dangerousBypassPermission",
          label: "Dangerously bypass permissions\u26A0",
          row: selectedProvider === "custom" ? 6 : 5,
          column: 0
        }
      ), /* @__PURE__ */ React30.createElement(
        FormToggle,
        {
          name: "virtualScrollingEnabled",
          label: "Virtual scrolling",
          row: selectedProvider === "custom" ? 7 : 6,
          column: 0
        }
      )), /* @__PURE__ */ React30.createElement(Box24, { marginTop: 2, marginBottom: -2, flexDirection: "row", justifyContent: "space-between" }, /* @__PURE__ */ React30.createElement(Box24, null, onCancel && /* @__PURE__ */ React30.createElement(
        FormButton,
        {
          name: "cancel",
          label: "Cancel",
          onPress: onCancel,
          variant: "secondary",
          row: selectedProvider === "custom" ? 7 : 6,
          column: 0
        }
      )), /* @__PURE__ */ React30.createElement(Box24, { flexDirection: "row", gap: 1 }, /* @__PURE__ */ React30.createElement(
        ClearFormButton,
        {
          name: "clear",
          label: "Clear",
          variant: "secondary",
          filled: true,
          row: selectedProvider === "custom" ? 4 : 3,
          column: 1
        }
      ), /* @__PURE__ */ React30.createElement(
        FormButton,
        {
          name: "save",
          label: "Save",
          type: "submit",
          variant: "primary",
          filled: true,
          row: selectedProvider === "custom" ? 4 : 3,
          column: 2
        }
      )))));
    };
  }
});

// src/ui/screens/HelpScreen.tsx
import React31 from "react";
import { Box as Box25, Text as Text21, useInput as useInput9 } from "ink";
var HelpScreen;
var init_HelpScreen = __esm({
  "src/ui/screens/HelpScreen.tsx"() {
    init_esm_shims();
    init_store2();
    HelpScreen = () => {
      useInput9((input, key) => {
        if (key.return) {
          actions.popStage();
        }
      });
      return /* @__PURE__ */ React31.createElement(
        Box25,
        {
          width: "100%",
          height: "100%",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center"
        },
        /* @__PURE__ */ React31.createElement(
          Box25,
          {
            borderStyle: "round",
            borderColor: "cyan",
            paddingX: 2,
            paddingY: 1,
            width: 60,
            flexDirection: "column"
          },
          /* @__PURE__ */ React31.createElement(Box25, { marginBottom: 1, justifyContent: "center" }, /* @__PURE__ */ React31.createElement(Text21, { bold: true, color: "cyan" }, "Help")),
          /* @__PURE__ */ React31.createElement(Text21, null, "Commands:"),
          /* @__PURE__ */ React31.createElement(Text21, null, "  /clear - Clear chat history"),
          /* @__PURE__ */ React31.createElement(Text21, null, "  /theme - Change theme"),
          /* @__PURE__ */ React31.createElement(Text21, null, "  /model - Switch AI model"),
          /* @__PURE__ */ React31.createElement(Text21, null, "  /settings - Open settings"),
          /* @__PURE__ */ React31.createElement(Text21, null, "  /toggle-virtual-scroll - Toggle virtual scrolling"),
          /* @__PURE__ */ React31.createElement(Text21, null, "  /help - Show this help"),
          /* @__PURE__ */ React31.createElement(Box25, { marginTop: 1 }, /* @__PURE__ */ React31.createElement(Text21, { dimColor: true }, "Press Enter to close"))
        )
      );
    };
  }
});

// src/ui/components/Modal.tsx
import React32, { useState as useState12 } from "react";
import { Box as Box26, Text as Text22, useInput as useInput10 } from "ink";
var Modal;
var init_Modal = __esm({
  "src/ui/components/Modal.tsx"() {
    init_esm_shims();
    Modal = ({ title, message, options, onSubmit }) => {
      const [selectedIndex, setSelectedIndex] = useState12(0);
      useInput10((input, key) => {
        if (key.upArrow || input === "k") {
          setSelectedIndex((prev) => prev > 0 ? prev - 1 : options.length - 1);
        } else if (key.downArrow || input === "j") {
          setSelectedIndex((prev) => (prev + 1) % options.length);
        } else if (key.return || input === " ") {
          onSubmit({
            selected: options[selectedIndex].value,
            cancelled: false
          });
        }
      });
      return /* @__PURE__ */ React32.createElement(
        Box26,
        {
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          height: "100%"
        },
        /* @__PURE__ */ React32.createElement(
          Box26,
          {
            borderStyle: "round",
            borderColor: "cyan",
            paddingX: 2,
            paddingY: 1,
            minWidth: 40,
            flexDirection: "column"
          },
          /* @__PURE__ */ React32.createElement(Box26, { marginBottom: 1, justifyContent: "center" }, /* @__PURE__ */ React32.createElement(Text22, { bold: true, color: "cyan" }, title)),
          message && /* @__PURE__ */ React32.createElement(Box26, { marginBottom: 1 }, /* @__PURE__ */ React32.createElement(Text22, null, message)),
          /* @__PURE__ */ React32.createElement(Box26, { flexDirection: "column", marginTop: 1 }, options.map((option, index) => {
            const isSelected = index === selectedIndex;
            const color = option.variant === "danger" ? "red" : option.variant === "primary" ? "cyan" : "white";
            return /* @__PURE__ */ React32.createElement(Box26, { key: option.value, paddingY: 0 }, /* @__PURE__ */ React32.createElement(Text22, { color: isSelected ? color : "gray" }, isSelected ? "\u25B6 " : "  ", option.label));
          })),
          /* @__PURE__ */ React32.createElement(Box26, { marginTop: 1 }, /* @__PURE__ */ React32.createElement(Text22, { dimColor: true }, "\u2191\u2193 Navigate \u2022 Enter/Space Select"))
        )
      );
    };
  }
});

// src/ui/screens/ModalScreen.tsx
import React33 from "react";
var ModalScreen;
var init_ModalScreen = __esm({
  "src/ui/screens/ModalScreen.tsx"() {
    init_esm_shims();
    init_Modal();
    init_store2();
    ModalScreen = ({
      title,
      message,
      options,
      onResult
    }) => {
      const handleSubmit = (result) => {
        if (onResult) {
          onResult(result);
        }
        actions.popStage();
      };
      return /* @__PURE__ */ React33.createElement(
        Modal,
        {
          title,
          message,
          options,
          onSubmit: handleSubmit
        }
      );
    };
  }
});

// src/ui/screens/ExitConfirmationModal.tsx
import React34 from "react";
import { useApp } from "ink";
var ExitConfirmationModal;
var init_ExitConfirmationModal = __esm({
  "src/ui/screens/ExitConfirmationModal.tsx"() {
    init_esm_shims();
    init_Modal();
    init_store2();
    ExitConfirmationModal = () => {
      const { exit } = useApp();
      const options = [
        { label: "Cancel", value: "cancel", variant: "secondary" },
        { label: "Exit", value: "exit", variant: "danger" }
      ];
      const handleSubmit = (result) => {
        if (result.selected === "exit") {
          exit();
          setTimeout(() => process.exit(0), 100);
        } else {
          actions.popStage();
          actions.setInputValue("");
        }
      };
      return /* @__PURE__ */ React34.createElement(
        Modal,
        {
          title: "Exit Confirmation",
          message: "Are you sure you want to exit?",
          options,
          onSubmit: handleSubmit
        }
      );
    };
  }
});

// src/ui/screens/ToolConfirmationScreen.tsx
import React35 from "react";
import { Box as Box27, Text as Text23 } from "ink";
var ToolConfirmationFormContent, ToolConfirmationScreen;
var init_ToolConfirmationScreen = __esm({
  "src/ui/screens/ToolConfirmationScreen.tsx"() {
    init_esm_shims();
    init_form();
    init_store2();
    ToolConfirmationFormContent = ({ options, onCancel }) => {
      const { values } = useForm();
      const isApproved = values.approve || false;
      return /* @__PURE__ */ React35.createElement(React35.Fragment, null, /* @__PURE__ */ React35.createElement(
        FormToggle,
        {
          name: "approve",
          label: "Approve this action",
          row: 0,
          column: 0
        }
      ), !isApproved && /* @__PURE__ */ React35.createElement(
        FormInput,
        {
          name: "feedback",
          label: "Reason for rejection (optional)",
          placeholder: "Enter your concerns or feedback...",
          row: 1,
          column: 0
        }
      ), /* @__PURE__ */ React35.createElement(
        FormToggle,
        {
          name: "dontAskAgain",
          label: isApproved ? "Always allow this type of action" : "Never allow this type of action",
          row: isApproved ? 1 : 2,
          column: 0
        }
      ), /* @__PURE__ */ React35.createElement(
        Box27,
        {
          flexDirection: "row",
          gap: 2,
          marginTop: 2,
          justifyContent: "flex-end"
        },
        /* @__PURE__ */ React35.createElement(
          FormButton,
          {
            name: "cancel",
            label: "Cancel",
            onPress: onCancel,
            variant: "secondary",
            row: isApproved ? 2 : 3,
            column: 0
          }
        ),
        /* @__PURE__ */ React35.createElement(
          FormButton,
          {
            name: "submit",
            label: isApproved ? "Approve" : "Reject",
            type: "submit",
            variant: isApproved ? "primary" : "danger",
            filled: true,
            row: isApproved ? 2 : 3,
            column: 1
          }
        )
      ));
    };
    ToolConfirmationScreen = ({
      options,
      onConfirm,
      onReject
    }) => {
      const handleSubmit = (values) => {
        if (values.approve) {
          onConfirm({
            confirmed: true,
            dontAskAgain: values.dontAskAgain || false
          });
        } else {
          onReject({
            confirmed: false,
            feedback: values.feedback || "",
            dontAskAgain: values.dontAskAgain || false
          });
        }
        actions.popStage();
      };
      const handleCancel = () => {
        onReject({
          confirmed: false,
          feedback: "Cancelled by user"
        });
        actions.popStage();
      };
      return /* @__PURE__ */ React35.createElement(
        Box27,
        {
          width: "100%",
          height: "100%",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center"
        },
        /* @__PURE__ */ React35.createElement(
          Box27,
          {
            borderStyle: "round",
            borderColor: "cyan",
            paddingX: 2,
            paddingY: 1,
            width: 80,
            flexDirection: "column"
          },
          /* @__PURE__ */ React35.createElement(Box27, { marginBottom: 1, justifyContent: "center" }, /* @__PURE__ */ React35.createElement(Text23, { bold: true, color: "cyan" }, "Tool Confirmation Required")),
          /* @__PURE__ */ React35.createElement(Box27, { marginBottom: 1 }, /* @__PURE__ */ React35.createElement(Text23, null, "Operation: ", options.operation), /* @__PURE__ */ React35.createElement(Text23, null, "File: ", options.filename)),
          options.content && /* @__PURE__ */ React35.createElement(
            Box27,
            {
              marginBottom: 1,
              borderStyle: "single",
              borderColor: "gray",
              paddingX: 1,
              paddingY: 1,
              height: 10
            },
            /* @__PURE__ */ React35.createElement(Text23, { color: "gray" }, options.content)
          ),
          /* @__PURE__ */ React35.createElement(
            Form,
            {
              onSubmit: handleSubmit,
              initialValues: {
                approve: false,
                feedback: "",
                dontAskAgain: false
              }
            },
            /* @__PURE__ */ React35.createElement(
              ToolConfirmationFormContent,
              {
                options,
                onCancel: handleCancel
              }
            )
          )
        )
      );
    };
  }
});

// src/ui/stage/StageRouter.tsx
import React36, { useCallback as useCallback10 } from "react";
import { Box as Box28, useInput as useInput11 } from "ink";
import { useSnapshot as useSnapshot16 } from "valtio";
var StageRouter;
var init_StageRouter = __esm({
  "src/ui/stage/StageRouter.tsx"() {
    init_esm_shims();
    init_store2();
    init_types2();
    init_ChatContainer();
    init_CommandPaletteScreen();
    init_SettingsScreen();
    init_HelpScreen();
    init_ModalScreen();
    init_ExitConfirmationModal();
    init_ToolConfirmationScreen();
    init_StatusBar();
    init_settings_manager();
    StageRouter = ({ agent }) => {
      const snap = useSnapshot16(store);
      const currentStage = snap.stageStack[snap.stageStack.length - 1];
      const handleCtrlC = useCallback10(() => {
        actions.pushStage({ id: "exit-confirmation", type: "exit_confirmation" /* EXIT_CONFIRMATION */ });
      }, []);
      useInput11((inputChar, key) => {
        if (currentStage.type === "chat" /* CHAT */) return;
        if (inputChar.charCodeAt(0) === 3 || key.ctrl && inputChar === "c") {
          handleCtrlC();
        }
      });
      const renderStage = () => {
        switch (currentStage.type) {
          case "chat" /* CHAT */:
            return /* @__PURE__ */ React36.createElement(ChatContainer, { agent });
          case "command_palette" /* COMMAND_PALETTE */:
            return /* @__PURE__ */ React36.createElement(CommandPaletteScreen, null);
          case "settings" /* SETTINGS */:
            return /* @__PURE__ */ React36.createElement(
              SettingsScreen,
              {
                onComplete: (settings) => {
                  actions.setModel(settings.model);
                  actions.setTheme(settings.theme);
                  actions.setAutoEdit(settings.autoEditEnabled);
                  actions.setVSCodeOpen(settings.vsCodeOpenEnabled);
                  actions.setDangerousBypassPermission(settings.dangerousBypassPermission);
                  actions.updateConfirmationSettings(settings.confirmationSettings);
                  const settingsManager = SettingsManager.getInstance();
                  settingsManager.saveSettings(settings);
                  actions.popStage();
                },
                onCancel: () => actions.popStage()
              }
            );
          case "help" /* HELP */:
            return /* @__PURE__ */ React36.createElement(HelpScreen, null);
          case "modal" /* MODAL */:
            return /* @__PURE__ */ React36.createElement(ModalScreen, { ...currentStage.props });
          case "exit_confirmation" /* EXIT_CONFIRMATION */:
            return /* @__PURE__ */ React36.createElement(ExitConfirmationModal, null);
          case "tool_confirmation" /* TOOL_CONFIRMATION */:
            return /* @__PURE__ */ React36.createElement(
              ToolConfirmationScreen,
              {
                options: currentStage.props.options,
                onConfirm: currentStage.props.onConfirm,
                onReject: currentStage.props.onReject
              }
            );
          default:
            return /* @__PURE__ */ React36.createElement(ChatContainer, { agent });
        }
      };
      return /* @__PURE__ */ React36.createElement(Box28, { width: "100%", height: "100%", flexDirection: "column", overflow: "hidden" }, /* @__PURE__ */ React36.createElement(Box28, { flexGrow: 1, overflow: "hidden" }, renderStage()), currentStage.type !== "chat" /* CHAT */ && /* @__PURE__ */ React36.createElement(Box28, { flexShrink: 0 }, /* @__PURE__ */ React36.createElement(StatusBar, null)));
    };
  }
});

// src/commands/builtin.ts
function registerBuiltinCommands() {
  if (hasRegistered) {
    return;
  }
  hasRegistered = true;
  registerCommand({
    name: "clear",
    description: "Clear the chat history",
    category: "Chat",
    exec: () => {
      actions.clearMessages();
    }
  });
  registerCommand({
    name: "theme",
    description: "Change the application theme",
    category: "Settings",
    arguments: [
      {
        name: "theme",
        type: "enum",
        description: "Theme",
        required: true,
        options: [
          { value: "light", label: "Light" },
          { value: "dark", label: "Dark" },
          { value: "auto", label: "Auto" }
        ]
      }
    ],
    exec: (args) => {
      actions.setTheme(args.theme);
    }
  });
  registerCommand({
    name: "model",
    description: "Switch AI model",
    category: "Settings",
    arguments: [
      {
        name: "model",
        type: "enum",
        description: "Model",
        required: true,
        options: [
          { value: "grok-4-0709", label: "Grok 4" },
          { value: "grok-3", label: "Grok 3" },
          { value: "grok-3-mini", label: "Grok 3 Mini" },
          { value: "grok-3-fast", label: "Grok 3 Fast" },
          { value: "grok-3-mini-fast", label: "Grok 3 Mini Fast" },
          { value: "grok-2-vision-1212", label: "Grok 2 Vision" },
          { value: "grok-2-image-1212", label: "Grok 2 Image" }
        ]
      }
    ],
    exec: (args) => {
      actions.setModel(args.model);
    }
  });
  registerCommand({
    name: "toggle-auto-edit",
    description: "Toggle auto-edit mode (file operations only)",
    category: "Settings",
    arguments: [
      {
        name: "enabled",
        type: "boolean",
        description: "Enable auto-edit for file operations",
        default: false
      }
    ],
    exec: (args) => {
      actions.setAutoEdit(args.enabled);
      const status = args.enabled ? "enabled" : "disabled";
      console.log(`Auto-edit is now ${status} for file operations`);
    }
  });
  registerCommand({
    name: "toggle-vscode",
    description: "Toggle VS Code integration",
    category: "Settings",
    arguments: [
      {
        name: "enabled",
        type: "boolean",
        description: "Enable VS Code integration",
        default: false
      }
    ],
    exec: (args) => {
      actions.setVSCodeOpen(args.enabled);
    }
  });
  registerCommand({
    name: "dbp",
    description: "Toggle dangerously bypass permission",
    category: "Settings",
    arguments: [
      {
        name: "enabled",
        type: "boolean",
        description: "Enable dangerous bypass (skips ALL confirmations)",
        default: false
      }
    ],
    exec: (args) => {
      actions.setDangerousBypassPermission(args.enabled);
      const status = args.enabled ? "ENABLED" : "DISABLED";
      console.log(`\u26A0\uFE0F  Dangerously Bypass Permission is now ${status}`);
    }
  });
  registerCommand({
    name: "toggle-virtual-scroll",
    description: "Toggle virtual scrolling for chat history",
    category: "Settings",
    exec: () => {
      const currentState = store.virtualScrollingEnabled;
      actions.setVirtualScrolling(!currentState);
      const status = !currentState ? "enabled" : "disabled";
      console.log(`\u{1F4DC} Virtual scrolling is now ${status}`);
    }
  });
  registerCommand({
    name: "search",
    description: "Search for text in files",
    category: "Tools",
    arguments: [
      {
        name: "query",
        type: "string",
        description: "Search query",
        required: true,
        placeholder: "Enter search term..."
      },
      {
        name: "path",
        type: "string",
        description: "Path to search in",
        default: ".",
        placeholder: "Path (default: current directory)"
      },
      {
        name: "caseSensitive",
        type: "boolean",
        description: "Case sensitive search",
        default: false
      }
    ],
    exec: async (args) => {
      const message = `Searching for "${args.query}" in ${args.path}${args.caseSensitive ? " (case sensitive)" : ""}`;
      console.log(message);
    }
  });
  registerCommand({
    name: "settings",
    description: "Configure application settings",
    category: "System",
    arguments: [
      {
        name: "model",
        type: "enum",
        description: "AI Model",
        required: false,
        options: [
          { value: "grok-4-0709", label: "Grok 4" },
          { value: "grok-3", label: "Grok 3" },
          { value: "grok-3-mini", label: "Grok 3 Mini" },
          { value: "grok-3-fast", label: "Grok 3 Fast" },
          { value: "grok-3-mini-fast", label: "Grok 3 Mini Fast" },
          { value: "grok-2-vision-1212", label: "Grok 2 Vision" },
          { value: "grok-2-image-1212", label: "Grok 2 Image" }
        ]
      },
      {
        name: "theme",
        type: "enum",
        description: "Theme",
        required: false,
        options: [
          { value: "auto", label: "Auto" },
          { value: "light", label: "Light" },
          { value: "dark", label: "Dark" }
        ]
      },
      {
        name: "autoEditEnabled",
        type: "boolean",
        description: "Auto-edit (file operations only)",
        default: false
      },
      {
        name: "vsCodeOpenEnabled",
        type: "boolean",
        description: "VS Code integration",
        default: false
      },
      {
        name: "dangerousBypassPermission",
        type: "boolean",
        description: "Dangerously bypass permissions \u26A0\uFE0F",
        default: false
      },
      {
        name: "virtualScrollingEnabled",
        type: "boolean",
        description: "Virtual scrolling",
        default: true
      }
    ],
    exec: async (args) => {
      const { SettingsManager: SettingsManager2 } = await Promise.resolve().then(() => (init_settings_manager(), settings_manager_exports));
      const settingsManager = SettingsManager2.getInstance();
      const { settings } = settingsManager.loadSettings();
      const updatedSettings = {
        ...settings,
        ...args
      };
      if (args.model !== void 0) actions.setModel(args.model);
      if (args.theme !== void 0) actions.setTheme(args.theme);
      if (args.autoEditEnabled !== void 0) actions.setAutoEdit(args.autoEditEnabled);
      if (args.vsCodeOpenEnabled !== void 0) actions.setVSCodeOpen(args.vsCodeOpenEnabled);
      if (args.dangerousBypassPermission !== void 0) actions.setDangerousBypassPermission(args.dangerousBypassPermission);
      if (args.virtualScrollingEnabled !== void 0) actions.setVirtualScrolling(args.virtualScrollingEnabled);
      if (settings.apiKey) {
        settingsManager.saveSettings({
          ...settings,
          ...updatedSettings
        });
        console.log("Settings updated successfully");
      } else {
        console.log("Settings updated (not saved - API key required)");
      }
    }
  });
  registerCommand({
    name: "help",
    description: "Show available commands",
    category: "System",
    exec: () => {
      const currentStage = actions.getCurrentStage();
      if (currentStage.type === "command_palette" /* COMMAND_PALETTE */) {
        actions.replaceStage({ id: "help", type: "help" /* HELP */ });
      } else {
        actions.pushStage({ id: "help", type: "help" /* HELP */ });
      }
    }
  });
}
var hasRegistered;
var init_builtin = __esm({
  "src/commands/builtin.ts"() {
    init_esm_shims();
    init_registry4();
    init_store2();
    init_types2();
    hasRegistered = false;
  }
});

// src/ui/containers/AppContainer.tsx
var AppContainer_exports = {};
__export(AppContainer_exports, {
  AppContainer: () => AppContainer
});
import React37, { useState as useState13, useEffect as useEffect19 } from "react";
var AppContainer;
var init_AppContainer = __esm({
  "src/ui/containers/AppContainer.tsx"() {
    init_esm_shims();
    init_ClankerLogo();
    init_StageRouter();
    init_SettingsScreen();
    init_settings_manager();
    init_store2();
    init_builtin();
    init_agent();
    AppContainer = ({ agent: initialAgent, onRequestReload }) => {
      const [showLogo, setShowLogo] = useState13(true);
      const [showSettings, setShowSettings] = useState13(false);
      const [agent, setAgent] = useState13(initialAgent || null);
      const settingsManager = SettingsManager.getInstance();
      useEffect19(() => {
        registerBuiltinCommands();
        actions.loadSettings();
        if (agent) {
          agent.waitForToolsToLoad().then(() => {
            console.log("Tools loaded successfully");
          }).catch((error) => {
            console.error("Failed to load tools:", error);
          });
        }
        if (!agent && settingsManager.needsConfiguration()) {
          setShowSettings(true);
          setShowLogo(false);
        }
      }, [agent]);
      const handleLogoComplete = () => {
        setShowLogo(false);
        if (!agent) {
          setShowSettings(true);
        }
      };
      const handleSettingsComplete = async (settings) => {
        console.log("\n\u2705 Settings saved successfully!");
        try {
          let baseURL;
          if (settings.provider === "custom") {
            baseURL = settings.customBaseURL;
          } else {
            const providerConfig = ProviderModels[settings.provider || "grok"];
            baseURL = providerConfig.baseURL;
          }
          const { CoreToolsManager: CoreToolsManager2 } = await Promise.resolve().then(() => (init_core_tools(), core_tools_exports));
          const coreToolsManager = new CoreToolsManager2();
          await coreToolsManager.ensureCoreToolsInstalled();
          const newAgent = new GrokAgent({
            apiKey: settings.apiKey,
            baseURL,
            model: settings.model || ProviderModels.grok.defaultModel,
            loadDynamicTools: true
          });
          await newAgent.waitForToolsToLoad();
          setAgent(newAgent);
          actions.setAgent(newAgent);
          actions.clearMessages();
          actions.setModel(settings.model);
          actions.setTheme(settings.theme);
          actions.setAutoEdit(settings.autoEditEnabled);
          actions.setVSCodeOpen(settings.vsCodeOpenEnabled);
          actions.setDangerousBypassPermission(settings.dangerousBypassPermission);
          actions.updateConfirmationSettings(settings.confirmationSettings);
          setShowSettings(false);
          setShowLogo(true);
          console.log("Agent initialized successfully");
        } catch (error) {
          console.error("Failed to initialize agent:", error);
        }
      };
      const handleSettingsCancel = () => {
        if (agent) {
          setShowSettings(false);
        }
      };
      if (showSettings) {
        return /* @__PURE__ */ React37.createElement(
          SettingsScreen,
          {
            onComplete: handleSettingsComplete,
            onCancel: agent ? handleSettingsCancel : void 0
          }
        );
      }
      if (showLogo && agent) {
        return /* @__PURE__ */ React37.createElement(ClankerLogo, { agent, onComplete: handleLogoComplete });
      }
      if (agent) {
        return /* @__PURE__ */ React37.createElement(StageRouter, { agent });
      }
      return /* @__PURE__ */ React37.createElement(SettingsScreen, { onComplete: handleSettingsComplete });
    };
  }
});

// src/index.ts
init_esm_shims();
init_agent();
init_confirmation_service();
init_debug_logger();
import { program } from "commander";
import * as dotenv from "dotenv";
import * as fs11 from "fs";
import * as path13 from "path";
import * as os6 from "os";

// src/package-manager/index.ts
init_esm_shims();
init_installer();
init_registry3();
init_experimental();

// src/package-manager/types.ts
init_esm_shims();

// src/package-manager/index.ts
init_experimental();
var ClankerPackageManager = class {
  constructor(options = {}) {
    this.installer = new ToolInstaller(options);
    this.registry = new RegistryClient(options);
    this.experimental = new ExperimentalToolManager(options);
  }
  /**
   * Install a tool
   */
  async install(toolSpec, options) {
    return this.installer.install(toolSpec, options);
  }
  /**
   * Uninstall a tool
   */
  async uninstall(toolSpec) {
    return this.installer.uninstall(toolSpec);
  }
  /**
   * Search for tools
   */
  async search(query, options = {}) {
    try {
      const results = await this.registry.searchTools(query);
      if (results.length === 0) {
        console.log("No tools found matching your query.");
        return;
      }
      const sortedResults = [...results];
      if (options.sortBy) {
        sortedResults.sort((a, b) => {
          switch (options.sortBy) {
            case "name":
              return a.name.localeCompare(b.name);
            case "downloads":
              return (b.downloads || 0) - (a.downloads || 0);
            case "stars":
              return (b.stars || 0) - (a.stars || 0);
            default:
              return 0;
          }
        });
      }
      const limitedResults = options.limit ? sortedResults.slice(0, options.limit) : sortedResults;
      console.log(`
\u{1F50D} Found ${results.length} tools:
`);
      for (const tool of limitedResults) {
        console.log(`${tool.org}/${tool.name} (v${tool.latest})`);
        console.log(`  ${tool.description}`);
        if (tool.downloads || tool.stars) {
          const stats = [];
          if (tool.downloads) stats.push(`${tool.downloads} downloads`);
          if (tool.stars) stats.push(`\u2B50 ${tool.stars}`);
          console.log(`  ${stats.join(" \xB7 ")}`);
        }
        console.log();
      }
      if (options.limit && results.length > options.limit) {
        console.log(`... and ${results.length - options.limit} more results`);
      }
    } catch (error) {
      console.error(`\u274C Search failed: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * List installed tools
   */
  async listInstalled() {
    try {
      const installed = await this.installer.listInstalled();
      if (installed.length === 0) {
        console.log("No tools installed.");
        return;
      }
      console.log(`
\u{1F4E6} Installed tools (${installed.length}):
`);
      for (const tool of installed) {
        console.log(`${tool.org}/${tool.name}@${tool.version}`);
        console.log(`  Installed: ${new Date(tool.installedAt).toLocaleDateString()}`);
        console.log(`  Path: ${tool.path}`);
        console.log();
      }
    } catch (error) {
      console.error(`\u274C Failed to list installed tools: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Update a tool to latest version
   */
  async update(toolSpec) {
    return this.installer.update(toolSpec);
  }
  /**
   * Clear registry cache
   */
  async clearCache() {
    await this.registry.clearCache();
    console.log("\u2705 Cache cleared");
  }
  /**
   * Enable experimental mode
   */
  async enableExperimental() {
    await this.experimental.enable();
    console.log("\u{1F9EA} Experimental mode enabled");
    console.log("\u26A0\uFE0F  Warning: Experimental tools have not been fully reviewed and may be unstable");
  }
  /**
   * List available experimental tools
   */
  async listExperimental() {
    const isEnabled = await this.experimental.isEnabled();
    if (!isEnabled) {
      console.log("\u2139\uFE0F  Experimental mode is not enabled. Use --enable-experimental to enable.");
      return;
    }
    try {
      const tools = await this.experimental.listAvailable();
      if (tools.length === 0) {
        console.log("No experimental tools available.");
        return;
      }
      console.log(`
\u{1F9EA} Available experimental tools (${tools.length}):
`);
      const branches = tools.filter((t) => t.source === "branch");
      const prs = tools.filter((t) => t.source === "pr");
      if (branches.length > 0) {
        console.log("From branches:");
        for (const tool of branches) {
          console.log(`  ${tool.org}/${tool.name}@${tool.version}`);
          console.log(`    Branch: ${tool.sourceRef}`);
        }
        console.log();
      }
      if (prs.length > 0) {
        console.log("From pull requests:");
        for (const tool of prs) {
          console.log(`  ${tool.org}/${tool.name}@pr-${tool.sourceRef}`);
          console.log(`    PR #${tool.sourceRef}`);
        }
      }
      console.log("\n\u2139\uFE0F  Install with: clanker --install org/tool@branch or org/tool@pr-123");
    } catch (error) {
      console.error(`\u274C Failed to list experimental tools: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Install an experimental tool
   */
  async installExperimental(toolSpec) {
    const isEnabled = await this.experimental.isEnabled();
    if (!isEnabled) {
      console.log("\u2139\uFE0F  Experimental mode is not enabled. Use --enable-experimental to enable.");
      return;
    }
    try {
      await this.experimental.install(toolSpec);
    } catch (error) {
      console.error(`\u274C Failed to install experimental tool: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * List installed experimental tools
   */
  async listInstalledExperimental() {
    try {
      const tools = await this.experimental.listInstalled();
      if (tools.length === 0) {
        console.log("No experimental tools installed.");
        return;
      }
      console.log(`
\u{1F9EA} Installed experimental tools (${tools.length}):
`);
      for (const tool of tools) {
        console.log(`${tool.org}/${tool.name}@${tool.version}`);
        console.log(`  Source: ${tool.source === "pr" ? `PR #${tool.sourceRef}` : `Branch ${tool.sourceRef}`}`);
        console.log(`  Installed: ${new Date(tool.installedAt).toLocaleDateString()}`);
        console.log();
      }
    } catch (error) {
      console.error(`\u274C Failed to list experimental tools: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Upgrade experimental tools to stable versions
   */
  async upgradeExperimental() {
    try {
      await this.experimental.upgradeToStable();
    } catch (error) {
      console.error(`\u274C Failed to upgrade experimental tools: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
};

// src/index.ts
dotenv.config({ quiet: true });
function loadApiKey() {
  let apiKey = process.env.CLANKER_API_KEY || process.env.GROK_API_KEY;
  if (!apiKey) {
    try {
      const homeDir = os6.homedir();
      let settingsFile = path13.join(homeDir, ".clanker", "user-settings.json");
      if (!fs11.existsSync(settingsFile)) {
        settingsFile = path13.join(homeDir, ".clanker", "settings.json");
      }
      if (fs11.existsSync(settingsFile)) {
        const settings = JSON.parse(fs11.readFileSync(settingsFile, "utf8"));
        apiKey = settings.apiKey;
      }
    } catch {
    }
  }
  return apiKey;
}
function loadBaseURL() {
  let baseURL = process.env.CLANKER_BASE_URL || process.env.GROK_BASE_URL;
  if (!baseURL) {
    try {
      const homeDir = os6.homedir();
      const settingsFile = path13.join(homeDir, ".clanker", "settings.json");
      if (fs11.existsSync(settingsFile)) {
        const settings = JSON.parse(fs11.readFileSync(settingsFile, "utf8"));
        if (settings.provider) {
          if (settings.provider === "custom") {
            baseURL = settings.customBaseURL;
          } else {
            baseURL = "https://api.x.ai/v1";
          }
        } else {
          baseURL = settings.baseURL;
        }
      }
    } catch {
    }
  }
  return baseURL;
}
async function processPromptHeadless(prompt, apiKey, baseURL, model, loadDynamicTools, dynamicToolsPath, watchTools) {
  try {
    const agent = new GrokAgent({
      apiKey,
      baseURL,
      model: model || process.env.GROK_MODEL || "grok-3-latest",
      loadDynamicTools,
      dynamicToolsPath,
      watchTools
    });
    await agent.waitForToolsToLoad();
    const confirmationService = ConfirmationService.getInstance();
    confirmationService.setSessionFlag("allOperations", true);
    debug.log("Processing prompt with new registry system...\n");
    const registry = agent.getRegistry();
    const tools = registry.list();
    debug.log(`Loaded ${tools.length} tools: ${tools.map((t) => t.id).join(", ")}
`);
    const response = await agent.chat([
      { role: "user", content: prompt }
    ], void 0, false);
    console.log(response);
    const stats = agent.getToolStats();
    if (stats && Object.keys(stats).length > 0) {
      debug.log("\nTool Usage Statistics:");
      Object.entries(stats).forEach(([toolId, toolStats]) => {
        if (toolStats.executionCount > 0) {
          const typedStats = toolStats;
          const durationInSeconds = (typedStats.totalDuration / 1e3).toFixed(2);
          debug.log(`  - ${toolId}: ${typedStats.executionCount} calls, ${durationInSeconds}s total`);
        }
      });
    }
  } catch (error) {
    console.error("\u274C Error processing prompt:", error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}
program.name("grok-registry").description(
  "Test the new dynamic tool registry system for Grok CLI"
).version((() => {
  try {
    const packagePath = path13.join(__dirname, "..", "package.json");
    const packageData = fs11.readFileSync(packagePath, "utf8");
    return JSON.parse(packageData).version;
  } catch {
    return "0.1.32";
  }
})()).option("-d, --directory <dir>", "set working directory", process.cwd()).option("-k, --api-key <key>", "API key (or set CLANKER_API_KEY env var)").option(
  "-u, --base-url <url>",
  "API base URL (or set CLANKER_BASE_URL env var)"
).option(
  "-m, --model <model>",
  "AI model to use (e.g., grok-beta)"
).option(
  "-p, --prompt <prompt>",
  "process a single prompt and exit (headless mode)"
).option(
  "--debug",
  "enable debug logging"
).option(
  "--load-dynamic-tools",
  "load dynamic tools from .clanker/tools directory"
).option(
  "--tools-path <path>",
  "custom path for dynamic tools (default: .clanker/tools)"
).option(
  "--list-tools",
  "list all available tools and exit"
).option(
  "-I, --install <tool>",
  "install a tool (format: org/name or org/name@version)"
).option(
  "-U, --uninstall <tool>",
  "uninstall a tool (format: org/name)"
).option(
  "-S, --search <query>",
  "search for tools in the registry"
).option(
  "-L, --list-installed",
  "list all installed tools"
).option(
  "--update <tool>",
  "update a tool to the latest version"
).option(
  "--clear-cache",
  "clear the package manager cache"
).option(
  "-W, --watch-tools",
  "watch and reload tools from ~/.clanker/tools"
).option(
  "--publish",
  "publish your tool to the Clanker registry"
).option(
  "--add-repo <url>",
  "add a repository to search for tools"
).option(
  "--remove-repo <url>",
  "remove a repository from the search list"
).option(
  "--list-repos",
  "list all configured repositories"
).action(async (options) => {
  if (options.debug) {
    setDebugMode(true, true);
    debug.log("Debug mode enabled");
  }
  if (options.directory) {
    try {
      process.chdir(options.directory);
    } catch (error) {
      console.error(
        `Error changing directory to ${options.directory}:`,
        error instanceof Error ? error.message : String(error)
      );
      process.exit(1);
    }
  }
  try {
    const packageManager = new ClankerPackageManager();
    if (options.install) {
      await packageManager.install(options.install, { force: false });
      return;
    }
    if (options.uninstall) {
      await packageManager.uninstall(options.uninstall);
      return;
    }
    if (options.search) {
      await packageManager.search(options.search, { limit: 20 });
      return;
    }
    if (options.listInstalled) {
      await packageManager.listInstalled();
      return;
    }
    if (options.update) {
      await packageManager.update(options.update);
      return;
    }
    if (options.clearCache) {
      await packageManager.clearCache();
      return;
    }
    if (options.publish) {
      const { publishTool: publishTool2 } = await Promise.resolve().then(() => (init_publisher(), publisher_exports));
      await publishTool2();
      return;
    }
    if (options.addRepo) {
      const { RepositoryManager: RepositoryManager2 } = await Promise.resolve().then(() => (init_repository_manager(), repository_manager_exports));
      const repoManager = new RepositoryManager2();
      await repoManager.addRepository(options.addRepo);
      return;
    }
    if (options.removeRepo) {
      const { RepositoryManager: RepositoryManager2 } = await Promise.resolve().then(() => (init_repository_manager(), repository_manager_exports));
      const repoManager = new RepositoryManager2();
      await repoManager.removeRepository(options.removeRepo);
      return;
    }
    if (options.listRepos) {
      const { RepositoryManager: RepositoryManager2 } = await Promise.resolve().then(() => (init_repository_manager(), repository_manager_exports));
      const repoManager = new RepositoryManager2();
      await repoManager.listRepositories();
      return;
    }
    const apiKey = options.apiKey || loadApiKey();
    const baseURL = options.baseUrl || loadBaseURL();
    const model = options.model;
    if (!apiKey) {
      console.error(
        "\u274C Error: API key required. Set CLANKER_API_KEY environment variable, use --api-key flag, or save to ~/.clanker/user-settings.json"
      );
      process.exit(1);
    }
    if (options.listTools || options.prompt || !options.publish) {
      const { CoreToolsManager: CoreToolsManager2 } = await Promise.resolve().then(() => (init_core_tools(), core_tools_exports));
      const coreToolsManager = new CoreToolsManager2();
      await coreToolsManager.ensureCoreToolsInstalled();
    }
    if (options.listTools) {
      const agent2 = new GrokAgent({
        apiKey,
        baseURL,
        model,
        loadDynamicTools: options.loadDynamicTools,
        dynamicToolsPath: options.toolsPath,
        watchTools: options.watchTools
      });
      await agent2.waitForToolsToLoad();
      const registry = agent2.getRegistry();
      const tools = registry.list();
      console.log("\u{1F4E6} Available Tools:\n");
      tools.forEach((tool) => {
        console.log(`${tool.id} - ${tool.description}`);
        if (tool.arguments && tool.arguments.length > 0) {
          console.log("  Arguments:");
          tool.arguments.forEach((arg) => {
            const required = arg.required ? " (required)" : "";
            console.log(`    - ${arg.name}: ${arg.type}${required} - ${arg.description}`);
          });
        }
        console.log();
      });
      return;
    }
    if (options.prompt) {
      await processPromptHeadless(
        options.prompt,
        apiKey,
        baseURL,
        model,
        options.loadDynamicTools,
        options.toolsPath,
        options.watchTools
      );
      return;
    }
    const { render } = await import("ink");
    const React38 = await import("react");
    const isRawModeSupported = process.stdin.isTTY;
    if (!isRawModeSupported) {
      console.error("\u274C Error: Interactive mode requires a TTY. Use --prompt flag for non-interactive usage.");
      process.exit(1);
    }
    const { actions: actions2, store: store2 } = await Promise.resolve().then(() => (init_store2(), store_exports));
    process.on("SIGINT", () => {
      const state = store2;
      const now = Date.now();
      if (state.exitConfirmation && state.exitConfirmationTime && now - state.exitConfirmationTime < 3e3) {
        process.exit(0);
      } else {
        if (state.inputValue.trim()) {
          actions2.setInputValue("");
        }
        actions2.setExitConfirmation(true);
        setTimeout(() => actions2.setExitConfirmation(false), 3e3);
      }
    });
    const { SettingsManager: SettingsManager2, ProviderModels: ProviderModels2 } = await Promise.resolve().then(() => (init_settings_manager(), settings_manager_exports));
    const settingsManager = SettingsManager2.getInstance();
    const { settings, isValid } = settingsManager.loadSettings();
    let agent;
    if (isValid && settings.apiKey) {
      try {
        let configuredBaseURL;
        if (settings.provider === "custom") {
          configuredBaseURL = settings.customBaseURL;
        } else {
          const providerConfig = ProviderModels2[settings.provider || "grok"];
          configuredBaseURL = providerConfig.baseURL;
        }
        agent = new GrokAgent({
          apiKey: settings.apiKey,
          baseURL: configuredBaseURL || baseURL,
          model: model || settings.model || ProviderModels2.grok.defaultModel,
          loadDynamicTools: options.loadDynamicTools,
          dynamicToolsPath: options.toolsPath,
          watchTools: options.watchTools
        });
        await agent.waitForToolsToLoad();
      } catch (error) {
        console.error("Failed to create agent with saved settings:", error);
      }
    }
    const { AppContainer: AppContainer2 } = await Promise.resolve().then(() => (init_AppContainer(), AppContainer_exports));
    const app = render(React38.createElement(AppContainer2, { agent }));
    app.waitUntilExit().then(() => {
      process.exit(0);
    });
  } catch (error) {
    console.error("\u274C Error initializing Grok CLI:", error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
});
program.parse();
//# sourceMappingURL=index.js.map