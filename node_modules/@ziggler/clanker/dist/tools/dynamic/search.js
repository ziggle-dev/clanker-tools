import React from "react";
import { Box, Text } from "ink";
import { RipgrepSearch } from "../../utils/ripgrep-search";
import { createTool, ToolCategory, ToolCapability, validators } from "../../registry";
import * as path from "path";
import * as fs from "fs/promises";
let ripgrepSearch;
const searchTool = createTool().id("search").name("Unified Search Tool").description("Unified search tool for finding text content or files (similar to Cursor's search)").category(ToolCategory.Search).capabilities(ToolCapability.FileRead).tags("search", "find", "grep", "ripgrep", "rg").stringArg("query", "Text to search for or file name/path pattern", { required: true }).stringArg("search_type", 'Type of search: "text" for content search, "files" for file names, "both" for both', {
  default: "both",
  enum: ["text", "files", "both"]
}).stringArg("include_pattern", 'Glob pattern for files to include (e.g. "*.ts", "*.js")').stringArg("exclude_pattern", 'Glob pattern for files to exclude (e.g. "*.log", "node_modules")').booleanArg("case_sensitive", "Whether search should be case sensitive", { default: false }).booleanArg("whole_word", "Whether to match whole words only", { default: false }).booleanArg("regex", "Whether query is a regex pattern", { default: false }).numberArg("max_results", "Maximum number of results to return", {
  default: 50,
  validate: validators.min(1)
}).arrayArg("file_types", 'File types to search (e.g. ["js", "ts", "py"])').booleanArg("include_hidden", "Whether to include hidden files", { default: false }).onInitialize(async (context) => {
  ripgrepSearch = new RipgrepSearch();
  context.logger?.info("Search tool initialized with RipgrepSearch");
}).execute(async (args, context) => {
  let {
    query,
    search_type = "both",
    include_pattern,
    exclude_pattern,
    case_sensitive = false,
    whole_word = false,
    regex = false,
    max_results = 50,
    file_types,
    include_hidden = false
  } = args;
  if (query.includes("~>")) {
    const parts = query.split("~>").map((p) => p.trim());
    if (parts.length === 2 && parts[0] === "") {
      search_type = "files";
      const patterns = parts[1].split(/\s+/).filter((p) => p);
      if (patterns.length > 0) {
        query = patterns[0];
        if (patterns.length > 1) {
          query = `{${patterns.join(",")}}`;
        }
        regex = true;
      }
    }
  }
  context.logger?.debug(`Searching for: ${query}`);
  context.logger?.debug(`Search type: ${search_type}`);
  context.logger?.debug(`Options: case_sensitive=${case_sensitive}, whole_word=${whole_word}, regex=${regex}`);
  try {
    const results = [];
    let totalMatches = 0;
    if (search_type === "text" || search_type === "both") {
      const textResults = await performTextSearch({
        query,
        case_sensitive,
        whole_word,
        regex,
        max_results,
        file_types,
        include_pattern,
        exclude_pattern,
        include_hidden
      });
      if (textResults.matches.length > 0) {
        context.logger?.info(`Found ${textResults.matches.length} text matches`);
        results.push("=== Text Search Results ===");
        results.push(...textResults.formatted);
        totalMatches += textResults.matches.length;
      }
    }
    if (search_type === "files" || search_type === "both") {
      const fileResults = await performFileSearch({
        query,
        case_sensitive,
        include_pattern,
        exclude_pattern,
        include_hidden,
        max_results: Math.max(0, (max_results || 50) - totalMatches)
      });
      if (fileResults.length > 0) {
        context.logger?.info(`Found ${fileResults.length} file matches`);
        if (results.length > 0) results.push("");
        results.push("=== File Search Results ===");
        results.push(...fileResults);
        totalMatches += fileResults.length;
      }
    }
    if (results.length === 0) {
      context.logger?.info(`No matches found for query: ${query}`);
      return {
        success: true,
        output: "No matches found"
      };
    }
    const summary = [`Found ${totalMatches} match${totalMatches === 1 ? "" : "es"}`];
    if (totalMatches >= max_results) {
      summary.push(`(showing first ${max_results} results)`);
    }
    context.logger?.info(`Search completed: ${totalMatches} total matches`);
    return {
      success: true,
      output: [...summary, "", ...results].join("\n")
    };
  } catch (error) {
    context.logger?.error(`Search failed: ${error instanceof Error ? error.message : String(error)}`);
    return {
      success: false,
      error: `Search failed: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}).renderResult(({ isExecuting, result, arguments: args }) => {
  if (isExecuting) {
    return /* @__PURE__ */ React.createElement(Text, { color: "cyan" }, '\u23BF Searching for "', args.query, '"...');
  }
  if (!result?.success) {
    return /* @__PURE__ */ React.createElement(Text, { color: "red" }, "\u23BF ", result?.error || "Search failed");
  }
  const data = result.data;
  const matchCount = data?.results?.length || 0;
  if (matchCount === 0) {
    return /* @__PURE__ */ React.createElement(Text, { color: "gray" }, "\u23BF No matches found");
  }
  return /* @__PURE__ */ React.createElement(Box, { flexDirection: "column", marginLeft: 2 }, /* @__PURE__ */ React.createElement(Text, { color: "gray" }, "\u23BF Found ", matchCount, " match", matchCount === 1 ? "" : "es"), data.results.slice(0, 5).map((match, i) => /* @__PURE__ */ React.createElement(Text, { key: i, color: "cyan" }, "\u23BF ", match.file, match.line_number ? `:${match.line_number}` : "")), matchCount > 5 && /* @__PURE__ */ React.createElement(Text, { color: "gray", italic: true }, "\u23BF ... and ", matchCount - 5, " more"));
}).build();
var search_default = searchTool;
async function performTextSearch(options) {
  const searchOptions = {
    maxResults: options.max_results,
    caseSensitive: options.case_sensitive,
    wholeWord: options.whole_word,
    regex: options.regex,
    includeHidden: options.include_hidden
  };
  if (options.file_types && options.file_types.length > 0) {
    searchOptions.fileTypes = options.file_types;
  }
  if (options.include_pattern) {
    searchOptions.includes = [options.include_pattern];
  }
  if (options.exclude_pattern) {
    searchOptions.excludes = [options.exclude_pattern];
  }
  const results = await ripgrepSearch.search(options.query, searchOptions);
  const formatted = [];
  const groupedByFile = /* @__PURE__ */ new Map();
  for (const match of results) {
    if (!groupedByFile.has(match.file)) {
      groupedByFile.set(match.file, []);
    }
    groupedByFile.get(match.file).push(match);
  }
  for (const [file, matches] of groupedByFile) {
    formatted.push(`
${file}:`);
    for (const match of matches) {
      const lineNum = match.line_number || match.lineNumber || "?";
      const text = match.line || match.match || "";
      formatted.push(`  ${lineNum}: ${text.trim()}`);
    }
  }
  return { matches: results, formatted };
}
async function performFileSearch(options) {
  const results = [];
  const isRegex = options.query.includes("*") || options.query.includes("?") || options.query.includes("{");
  const searchPattern = options.case_sensitive ? options.query : options.query.toLowerCase();
  async function walkDir(dir, depth = 0) {
    if (results.length >= options.max_results) return;
    if (depth > 20) return;
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (results.length >= options.max_results) break;
        const fullPath = path.join(dir, entry.name);
        const relativePath = path.relative(process.cwd(), fullPath);
        if (!options.include_hidden && entry.name.startsWith(".")) {
          continue;
        }
        if (entry.name === "node_modules" || entry.name === ".git" || entry.name === "dist" || entry.name === "build") {
          continue;
        }
        if (options.exclude_pattern && matchesGlob(relativePath, options.exclude_pattern)) {
          continue;
        }
        if (options.include_pattern && !matchesGlob(relativePath, options.include_pattern)) {
          if (entry.isDirectory()) {
            await walkDir(fullPath, depth + 1);
          }
          continue;
        }
        const nameToCheck = options.case_sensitive ? entry.name : entry.name.toLowerCase();
        const pathToCheck = options.case_sensitive ? relativePath : relativePath.toLowerCase();
        let matches = false;
        if (isRegex) {
          matches = matchesGlob(entry.name, options.query) || matchesGlob(relativePath, options.query);
        } else {
          matches = nameToCheck.includes(searchPattern) || pathToCheck.includes(searchPattern);
        }
        if (matches) {
          results.push(relativePath);
        }
        if (entry.isDirectory()) {
          await walkDir(fullPath, depth + 1);
        }
      }
    } catch (error) {
    }
  }
  await walkDir(process.cwd());
  return results;
}
function matchesGlob(path2, pattern) {
  if (pattern.includes("{") && pattern.includes("}")) {
    const match = pattern.match(/\{([^}]+)\}/);
    if (match) {
      const alternatives = match[1].split(",");
      return alternatives.some((alt) => {
        const expandedPattern = pattern.replace(match[0], alt);
        return matchesGlob(path2, expandedPattern);
      });
    }
  }
  let regex = pattern.replace(/\./g, "\\.").replace(/\*\*/g, "\xA7\xA7\xA7").replace(/\*/g, "[^/]*").replace(/§§§/g, ".*").replace(/\?/g, ".");
  try {
    if (!pattern.includes("/")) {
      const filename = path2.split("/").pop() || path2;
      return new RegExp(`^${regex}$`).test(filename);
    }
    return new RegExp(`^${regex}$`).test(path2);
  } catch {
    return false;
  }
}
export {
  search_default as default
};
