import React from "react";
import { Text, Box } from "ink";
import * as fs from "fs/promises";
import * as path from "path";
import { createTool, ToolCategory, ToolCapability } from "../../registry";
import { ConfirmationService } from "../../utils/confirmation-service";
import { CompactOutput, ToolOutput } from "../../ui/components/tool-output";
import { fileTrackerActions } from "../../store/store";
import { diffParser } from "../../utils/diff-parser";
import { orderInvariantApplicator } from "../../utils/order-invariant-apply";
import { EnhancedDiffView } from "../../ui/components/enhanced-diff-view";
let confirmationService;
const multiEditTool = createTool().id("multi_edit").name("Multi Edit").description("Flexible file editing tool that can add, append, replace, or remove content. Use empty search string to append content.").category(ToolCategory.FileSystem).capabilities(ToolCapability.FileRead, ToolCapability.FileWrite, ToolCapability.UserConfirmation).tags("file", "edit", "replace", "modify", "diff", "append", "add", "remove", "update").stringArg("path", "Path to the file to edit", { required: true }).arrayArg("replacements", "Array of edit operations. Each item should have: search (string - can be empty to append), replace (string - can be empty to remove), and optional mode (exact|fuzzy)", {
  required: false
}).stringArg("diff_format", "Alternative: provide replacements as a diff string in various formats", {
  required: false
}).examples([
  {
    description: "Replace multiple strings",
    arguments: {
      path: "src/config.ts",
      replacements: [
        { search: "localhost", replace: "example.com" },
        { search: "8080", replace: "443" }
      ]
    },
    result: "Replaces all occurrences"
  },
  {
    description: "Append content to file",
    arguments: {
      path: "script.sh",
      replacements: [
        { search: "", replace: "\n# New commands\necho 'Hello World'\n" }
      ]
    },
    result: "Appends new content to end of file"
  },
  {
    description: "Remove lines containing text",
    arguments: {
      path: "config.yaml",
      replacements: [
        { search: "debug: true\n", replace: "" },
        { search: "verbose: true\n", replace: "" }
      ]
    },
    result: "Removes matching lines"
  },
  {
    description: "Add content after specific line",
    arguments: {
      path: "main.py",
      replacements: [
        { search: "import os", replace: "import os\nimport sys" }
      ]
    },
    result: "Adds new import after existing one"
  },
  {
    description: "Using diff format",
    arguments: {
      path: "README.md",
      diff_format: "--- old text\n+++ new text\n\n--- another old\n+++ another new"
    },
    result: "Applies diff-formatted changes"
  }
]).onInitialize(async (context) => {
  confirmationService = ConfirmationService.getInstance();
  context.logger?.debug("Multi Edit tool initialized");
}).execute(async (args, context) => {
  const { path: filePath, replacements, diff_format } = args;
  context.logger?.debug(`Replacing in file: ${filePath}`);
  try {
    if (!fileTrackerActions.hasFile(filePath)) {
      context.logger?.warn(`File ${filePath} has not been read yet`);
      return {
        success: false,
        error: `You must read the file before editing it. Please use read_file to read "${filePath}" first.`
      };
    }
    const content = await fs.readFile(filePath, "utf8");
    if (!fileTrackerActions.verifyFileHash(filePath, content)) {
      context.logger?.warn(`File ${filePath} has been modified since last read`);
      fileTrackerActions.clearFile(filePath);
      return {
        success: false,
        error: `File "${filePath}" has been modified since it was last read. Please use read_file to read the latest version before editing.`
      };
    }
    let blocks = [];
    if (diff_format) {
      const parseResult = diffParser.autoDetectFormat(diff_format);
      blocks = parseResult.blocks;
      if (parseResult.errors.length > 0) {
        context.logger?.warn(`Diff parsing warnings: ${parseResult.errors.join(", ")}`);
      }
    } else if (replacements && replacements.length > 0) {
      blocks = replacements.map((r) => ({
        search: r.search,
        replace: r.replace,
        format: "literal"
      }));
    } else {
      return {
        success: false,
        error: "No replacements provided. Use either replacements array or diff_format."
      };
    }
    const validation = orderInvariantApplicator.validateBlocks(content, blocks);
    if (!validation.valid) {
      return {
        success: false,
        error: `Invalid replacements:
${validation.errors.join("\n")}`
      };
    }
    const result = orderInvariantApplicator.apply(content, blocks);
    const sessionFlags = confirmationService.getSessionFlags();
    if (!sessionFlags.editFiles && !sessionFlags.allOperations) {
      let confirmMessage = `Will apply ${result.stats.appliedCount} replacement(s):

`;
      result.applied.forEach((block, i) => {
        const searchPreview = block.search.length > 50 ? block.search.substring(0, 47) + "..." : block.search;
        const replacePreview = block.replace.length > 50 ? block.replace.substring(0, 47) + "..." : block.replace;
        confirmMessage += `${i + 1}. "${searchPreview}" \u2192 "${replacePreview}"
`;
      });
      if (result.stats.failedCount > 0) {
        confirmMessage += `
Warning: ${result.stats.failedCount} replacement(s) could not be applied.`;
      }
      if (result.stats.conflictCount > 0) {
        confirmMessage += `
Warning: ${result.stats.conflictCount} conflicting replacement(s) detected.`;
      }
      const confirmationResult = await confirmationService.requestConfirmation({
        operation: "Edit file",
        filename: filePath,
        content: confirmMessage
      }, "file_edit");
      if (!confirmationResult.confirmed) {
        context.logger?.info(`File edit cancelled by user`);
        return {
          success: false,
          error: confirmationResult.feedback || "Edit cancelled by user"
        };
      }
    }
    if (result.content) {
      await fs.writeFile(filePath, result.content, "utf8");
      fileTrackerActions.updateFile(filePath, result.content);
    }
    const message = `Successfully applied ${result.stats.appliedCount} replacement(s) in ${filePath}`;
    context.logger?.info(message);
    return {
      success: result.success,
      output: message,
      data: {
        filePath,
        stats: result.stats,
        applied: result.applied,
        failed: result.failed,
        conflicts: result.conflicts,
        originalContent: content,
        newContent: result.content
      }
    };
  } catch (error) {
    context.logger?.error(`Failed to edit file: ${error instanceof Error ? error.message : String(error)}`);
    return {
      success: false,
      error: `Failed to edit file: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}).renderResult(({ isExecuting, result, arguments: args }) => {
  if (isExecuting) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "cyan" }, " Applying replacements..."));
  }
  if (!result) {
    return null;
  }
  if (!result.success) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "red" }, " ", result.error || "Failed to apply replacements"));
  }
  const data = result.data;
  if (!data || !data.stats) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "green" }, " ", result.output));
  }
  const filePath = data.filePath || args.path;
  const ext = path.extname(filePath).slice(1) || "text";
  return /* @__PURE__ */ React.createElement(ToolOutput, null, /* @__PURE__ */ React.createElement(Box, { flexDirection: "column" }, /* @__PURE__ */ React.createElement(Box, { marginBottom: 1, flexDirection: "column" }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Text, { color: "cyan", bold: true }, path.basename(filePath)), /* @__PURE__ */ React.createElement(Text, { color: "gray" }, " \u2022 "), /* @__PURE__ */ React.createElement(Text, { color: "gray", dimColor: true }, path.dirname(filePath), "/")), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Text, { color: "green" }, "\u2713 Applied ", data.stats.appliedCount, "/", data.stats.totalBlocks, " replacements"), data.stats.failedCount > 0 && /* @__PURE__ */ React.createElement(Text, { color: "yellow" }, " (", data.stats.failedCount, " failed)"), data.stats.conflictCount > 0 && /* @__PURE__ */ React.createElement(Text, { color: "red" }, " (", data.stats.conflictCount, " conflicts)"))), data.applied && data.applied.length > 0 && /* @__PURE__ */ React.createElement(Box, { marginTop: 1 }, /* @__PURE__ */ React.createElement(
    EnhancedDiffView,
    {
      blocks: data.applied,
      filePath,
      stats: data.stats,
      maxBlocksToShow: 5
    }
  ))));
}).build();
var multi_edit_default = multiEditTool;
export {
  multi_edit_default as default
};
