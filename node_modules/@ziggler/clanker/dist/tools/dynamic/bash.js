import React from "react";
import { Text } from "ink";
import { exec } from "child_process";
import { promisify } from "util";
import { createTool, ToolCategory, ToolCapability } from "../../registry";
import { ConfirmationService } from "../../utils/confirmation-service";
import { CompactOutput, ToolOutput } from "../../ui/components/tool-output";
import { CodeBlock } from "../../ui/components/code-block";
const execAsync = promisify(exec);
let currentDirectory = process.cwd();
let confirmationService;
const bashTool = createTool().id("bash").name("Bash Command Executor").description("Execute a bash command").category(ToolCategory.System).capabilities(ToolCapability.SystemExecute, ToolCapability.UserConfirmation).tags("bash", "shell", "command", "system").stringArg("command", "The bash command to execute", { required: true }).numberArg("timeout", "Command timeout in milliseconds", {
  default: 3e4,
  validate: (value) => value > 0 || "Timeout must be positive"
}).onInitialize(async (context) => {
  confirmationService = ConfirmationService.getInstance();
  currentDirectory = context.workingDirectory || process.cwd();
}).execute(async (args, context) => {
  const { command, timeout } = args;
  context.logger?.debug(`Executing bash command: ${command}`);
  context.logger?.debug(`Working directory: ${currentDirectory}`);
  context.logger?.debug(`Timeout: ${timeout}ms`);
  try {
    const sessionFlags = confirmationService.getSessionFlags();
    if (!sessionFlags.bashCommands && !sessionFlags.allOperations) {
      const confirmationResult = await confirmationService.requestConfirmation({
        operation: "Run bash command",
        filename: command,
        content: `Command: ${command}
Working directory: ${currentDirectory}`
      }, "bash");
      if (!confirmationResult.confirmed) {
        context.logger?.info(`Command execution cancelled by user`);
        return {
          success: false,
          error: confirmationResult.feedback || "Command execution cancelled by user"
        };
      }
    }
    if (command.startsWith("cd ")) {
      const newDir = command.substring(3).trim();
      try {
        process.chdir(newDir);
        currentDirectory = process.cwd();
        if (context.registry && typeof context.registry === "object" && "setWorkingDirectory" in context.registry) {
          const registryWithSetDir = context.registry;
          registryWithSetDir.setWorkingDirectory(currentDirectory);
        }
        context.logger?.info(`Changed directory to: ${currentDirectory}`);
        return {
          success: true,
          output: `Changed directory to: ${currentDirectory}`
        };
      } catch (error) {
        context.logger?.error(`Failed to change directory: ${error instanceof Error ? error.message : String(error)}`);
        return {
          success: false,
          error: `Cannot change directory: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
    const { stdout, stderr } = await execAsync(command, {
      cwd: currentDirectory,
      timeout,
      maxBuffer: 1024 * 1024
    });
    const output = stdout + (stderr ? `
STDERR: ${stderr}` : "");
    if (stderr) {
      context.logger?.warn(`Command produced stderr output: ${stderr}`);
    }
    context.logger?.info(`Command executed successfully`);
    context.logger?.debug(`Output: ${output.substring(0, 200)}${output.length > 200 ? "..." : ""}`);
    return {
      success: true,
      output: output.trim() || "Command executed successfully (no output)"
    };
  } catch (error) {
    context.logger?.error(`Command failed: ${error instanceof Error ? error.message : String(error)}`);
    return {
      success: false,
      error: `Command failed: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}).renderResult(({ isExecuting, result }) => {
  if (isExecuting) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "cyan" }, " Running command..."));
  }
  if (!result) {
    return null;
  }
  if (!result.success) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "red" }, " ", result.error));
  }
  const output = result.output || "";
  if (!output.trim()) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "gray" }, " (no output)"));
  }
  const lines = output.trim().split("\n");
  if (lines.length === 1) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "gray" }, " ", output.trim()));
  }
  const looksLikeCode = output.includes("{") || output.includes("function") || output.includes("class") || output.includes("import") || output.includes("export") || output.includes("const ") || output.includes("let ") || output.includes("var ");
  if (looksLikeCode) {
    let language = "text";
    if (output.includes("import React") || output.includes("export default")) {
      language = "javascript";
    } else if (output.includes("interface ") || output.includes(": string")) {
      language = "typescript";
    } else if (output.includes("def ") || output.includes("import ")) {
      language = "python";
    } else if (output.includes("package ") || output.includes("func ")) {
      language = "go";
    }
    return /* @__PURE__ */ React.createElement(ToolOutput, null, /* @__PURE__ */ React.createElement(CodeBlock, { content: output.trim(), language }));
  }
  return /* @__PURE__ */ React.createElement(ToolOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "gray" }, output.trim()));
}).build();
var bash_default = bashTool;
const getCurrentDirectory = () => currentDirectory;
export {
  bash_default as default,
  getCurrentDirectory
};
