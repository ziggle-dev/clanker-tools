import React from "react";
import { Text, Box } from "ink";
import * as fs from "fs/promises";
import * as path from "path";
import { createTool, ToolCategory, ToolCapability } from "../../registry";
import { CompactOutput, ToolOutput } from "../../ui/components/tool-output";
import { CodeBlock } from "../../ui/components/code-block";
import { fileTrackerActions } from "../../store/store";
const maxAllowedLines = 100;
const MAX_TOKENS = 25e3;
const CHARS_PER_TOKEN = 4;
const MAX_CHARS = MAX_TOKENS * CHARS_PER_TOKEN;
const viewFileTool = createTool().id("view_file").name("View File or Directory").description(`View contents of a file or list directory contents (max ${MAX_TOKENS.toLocaleString()} tokens)`).category(ToolCategory.FileSystem).capabilities(ToolCapability.FileRead).tags("file", "read", "view", "directory", "list").stringArg("path", "Path to file or directory to view", { required: true }).numberArg("start_line", `Starting line number (1-based). If provided without end_line, shows from this line to end of file or max ${maxAllowedLines} lines`, {
  required: false,
  validate: (value) => value >= 1 || "Start line must be at least 1"
}).numberArg("end_line", `Ending line number (inclusive). If provided, shows lines from start_line to end_line, max ${maxAllowedLines} lines total`, {
  required: false,
  validate: (value) => value >= 1 || "End line must be at least 1"
}).examples([
  {
    description: `View entire file (up to ${maxAllowedLines} lines and ${MAX_TOKENS.toLocaleString()} tokens)`,
    arguments: { path: "src/index.ts" },
    result: "Shows the file content with syntax highlighting"
  },
  {
    description: "View specific line range",
    arguments: { path: "src/app.tsx", start_line: 50, end_line: 100 },
    result: "Shows lines 50-100 of the file"
  },
  {
    description: "View from a line to end of file",
    arguments: { path: "package.json", start_line: 20 },
    result: `Shows from line 20 to end (max ${maxAllowedLines} lines)`
  }
]).execute(async (args, context) => {
  const { path: filePath, start_line, end_line } = args;
  context.logger?.debug(`Viewing path: ${filePath}`);
  if (start_line && end_line) {
    context.logger?.debug(`Line range: ${start_line}-${end_line}`);
  }
  try {
    const stats = await fs.stat(filePath);
    if (stats.isDirectory()) {
      const entries = await fs.readdir(filePath, { withFileTypes: true });
      const formatted = entries.sort((a, b) => {
        if (a.isDirectory() && !b.isDirectory()) return -1;
        if (!a.isDirectory() && b.isDirectory()) return 1;
        return a.name.localeCompare(b.name);
      }).map((entry) => {
        const type = entry.isDirectory() ? "DIR" : "FILE";
        return `[${type}] ${entry.name}`;
      }).join("\n");
      context.logger?.info(`Listed directory: ${filePath} (${entries.length} entries)`);
      return {
        success: true,
        output: `Contents of ${filePath}:
${formatted}`,
        data: {
          type: "directory",
          files: entries.map((e) => e.name + (e.isDirectory() ? "/" : ""))
        }
      };
    } else {
      const content = await fs.readFile(filePath, "utf8");
      const lines = content.split("\n");
      const totalLines = lines.length;
      let startIdx = 0;
      let endIdx = totalLines;
      if (start_line && end_line) {
        startIdx = Math.max(0, Math.min(start_line - 1, totalLines - 1));
        endIdx = Math.max(startIdx + 1, Math.min(end_line, totalLines));
        if (endIdx - startIdx > maxAllowedLines) {
          endIdx = startIdx + maxAllowedLines;
          context.logger?.warn(`Requested ${end_line - start_line + 1} lines, limiting to ${maxAllowedLines}`);
        }
      } else if (start_line) {
        startIdx = Math.max(0, Math.min(start_line - 1, totalLines - 1));
        endIdx = Math.min(totalLines, startIdx + maxAllowedLines);
      } else {
        if (totalLines > maxAllowedLines) {
          endIdx = maxAllowedLines;
        }
      }
      const selectedLines = lines.slice(startIdx, endIdx);
      const selectedContent = selectedLines.join("\n");
      const estimatedTokens = Math.ceil(selectedContent.length / CHARS_PER_TOKEN);
      if (selectedContent.length > MAX_CHARS) {
        context.logger?.error(`Selected content too large: ${estimatedTokens} tokens`);
        return {
          success: false,
          error: `Selected content too large: ${estimatedTokens.toLocaleString()} tokens (max: ${MAX_TOKENS.toLocaleString()} tokens). Please use a smaller line range. Requested lines ${startIdx + 1}-${endIdx} would return ${selectedLines.length} lines.`
        };
      }
      const formatted = selectedLines.map((line, idx) => `${startIdx + idx + 1}: ${line}`).join("\n");
      let rangeInfo = "";
      if (startIdx > 0 || endIdx < totalLines) {
        rangeInfo = ` (lines ${startIdx + 1}-${endIdx} of ${totalLines})`;
      } else if (totalLines > maxAllowedLines) {
        rangeInfo = ` (showing first ${maxAllowedLines} of ${totalLines} lines)`;
      }
      context.logger?.info(`Read file: ${filePath}${rangeInfo} (~${estimatedTokens} tokens)`);
      if (content.length <= MAX_CHARS) {
        fileTrackerActions.updateFile(filePath, content);
      }
      return {
        success: true,
        output: `File: ${filePath}${rangeInfo}:
${formatted}`,
        data: {
          type: "file",
          totalLines,
          displayedLines: selectedLines.length,
          startLine: startIdx + 1,
          endLine: endIdx,
          truncated: endIdx < totalLines,
          estimatedTokens
        }
      };
    }
  } catch (error) {
    context.logger?.error(`Failed to read ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
    return {
      success: false,
      error: `Failed to read ${filePath}: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}).renderResult(({ isExecuting, result, arguments: args }) => {
  if (isExecuting) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "cyan" }, " Reading file..."));
  }
  if (!result || !result.success) {
    return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "red" }, " ", result?.error || "Failed to read file"));
  }
  const filePath = args.path;
  const content = result.output || "";
  const dataType = result.data?.type;
  if (dataType === "directory") {
    const dirData = result.data;
    const items = dirData.files || [];
    if (items.length === 0) {
      return /* @__PURE__ */ React.createElement(CompactOutput, null, /* @__PURE__ */ React.createElement(Text, { color: "gray" }, " Empty directory"));
    }
    return /* @__PURE__ */ React.createElement(ToolOutput, null, /* @__PURE__ */ React.createElement(Box, { flexDirection: "column" }, items.map((item, index) => /* @__PURE__ */ React.createElement(Text, { key: index, color: item.endsWith("/") ? "cyan" : "white" }, item))));
  }
  let lines = content.split("\n");
  if (lines[0] && lines[0].startsWith("File: ")) {
    lines = lines.slice(1);
  }
  let startLineNumber = 1;
  const hasLineNumbers = lines.length > 0 && /^\d+:\s/.test(lines[0]);
  if (hasLineNumbers) {
    const firstLineMatch = lines[0].match(/^(\d+):\s/);
    if (firstLineMatch) {
      startLineNumber = parseInt(firstLineMatch[1], 10);
    }
    lines = lines.map((line) => {
      const match = line.match(/^\d+:\s(.*)$/);
      return match ? match[1] : line;
    });
  }
  const resultData = result.data;
  const totalLines = resultData?.totalLines || lines.length;
  const displayedStartLine = resultData?.startLine || startLineNumber;
  const displayedEndLine = resultData?.endLine || displayedStartLine + lines.length - 1;
  const isPartialView = resultData?.startLine && resultData.startLine > 1;
  const isTruncated = resultData?.truncated || false;
  const ext = path.extname(filePath).slice(1) || "text";
  return /* @__PURE__ */ React.createElement(ToolOutput, null, /* @__PURE__ */ React.createElement(Box, { flexDirection: "column" }, /* @__PURE__ */ React.createElement(Box, { marginBottom: 1, flexDirection: "column" }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Text, { color: "cyan", bold: true }, path.basename(filePath)), /* @__PURE__ */ React.createElement(Text, { color: "gray" }, " \u2022 "), /* @__PURE__ */ React.createElement(Text, { color: "gray", dimColor: true }, path.dirname(filePath), "/")), /* @__PURE__ */ React.createElement(Text, { color: "gray", dimColor: true }, totalLines, " lines", isPartialView ? ` (showing lines ${displayedStartLine}-${displayedEndLine})` : isTruncated ? ` (showing first ${lines.length} lines)` : "", " \u2022 ", ext || "plain text")), /* @__PURE__ */ React.createElement(
    CodeBlock,
    {
      content: lines.join("\n"),
      language: ext,
      showLineNumbers: true,
      startLineNumber: displayedStartLine
    }
  ), isTruncated && /* @__PURE__ */ React.createElement(Box, { marginTop: 1 }, /* @__PURE__ */ React.createElement(Text, { color: "yellow", dimColor: true }, "... ", totalLines - displayedEndLine, " more lines"))));
}).build();
var view_file_default = viewFileTool;
export {
  view_file_default as default
};
